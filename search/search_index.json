{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"tatva: Lego-like building blocks for differentiable FEM <p><code>tatva</code> (\u0924\u0924\u094d\u0924\u094d\u0935) is a Sanskrit word meaning principle or elements of reality. True to its name, <code>tatva</code> provides fundamental Lego-like building blocks (elements) which can be used to construct complex finite element method (FEM) simulations as energy functionals. <code>tatva</code> is a pure Python library for FEM simulations and is built on top of JAX ecosystem, making it easy to use FEM in a differentiable way.</p> Hertzian Contact Surface Advection Diffusion Cohesive Fracture Energy-Centric Solver <p>Energy-based formulation of FEM operators with automatic differentiation via JAX. Just write energy and differentiate it directly.</p> Versitality <p> Operator abstractions that map, integrate, differentiate on arbitrary meshes. Capability to handle mixed-dimension coupling, multi-point constaints, and more. </p> High Performance <p>Built-in sparse differentiation via coloring and matrix-free assembly tailored for mordern architecture such as GPUs. </p>"},{"location":"#installation","title":"Installation","text":"<p>Install the current release from PyPI:</p> <pre><code>pip install tatva\n</code></pre> <p>For development work, clone the repository and install it in editable mode (use your preferred virtual environment tool such as <code>uv</code> or <code>venv</code>):</p> <pre><code>git clone https://github.com/smec-ethz/tatva.git\ncd tatva\npip install -e .\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Create a mesh, pick an element type, and let Operator perform the heavy lifting with JAX arrays:</p> <pre><code>import jax.numpy as jnp\nfrom tatva.element import Tri3\nfrom tatva.mesh import Mesh\nfrom tatva.operator import Operator\n\ncoords = jnp.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\nelements = jnp.array([[0, 1, 2], [0, 2, 3]])\n\nmesh = Mesh(coords, elements)\n\nop = Operator(mesh, Tri3())\nnodal_values = jnp.arange(coords.shape[0], dtype=jnp.float64)\n\n# Integrate a nodal field over the mesh\ntotal = op.integrate(nodal_values)\n\n# Evaluate gradients at all quadrature points\ngradients = op.grad(nodal_values)\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>tatva</code> is distributed under the GNU Lesser General Public License v3.0 or later. See <code>COPYING</code> and <code>COPYING.LESSER</code> for the complete terms. \u00a9 2025 ETH Zurich (SMEC).</p>"},{"location":"about/","title":"About","text":"<p>About</p>"},{"location":"about/#license","title":"License","text":"<p><code>tatva</code> is distributed under the GNU Lesser General Public License v3.0 or later. See <code>COPYING</code> and <code>COPYING.LESSER</code> for the complete terms. \u00a9 2025 ETH Zurich (Mohit Pundir).</p>"},{"location":"about/#where-to-contribute","title":"Where to contribute","text":"<p>If you have a suggestion that would make this better, please fork the repo and create a pull request on github.com/smec-ethz/tatva. Please use that repository to open issues or submit merge requests. You can also simply open an issue with the tag \"enhancement\". Don't forget to give the project a star! Thanks again!</p> <ol> <li>Fork the Project</li> <li>Create your Feature Branch (git checkout -b feature/AmazingFeature)</li> <li>Commit your Changes (git commit -m 'Add some AmazingFeature')</li> <li>Push to the Branch (git push origin feature/AmazingFeature)</li> <li>Open a Pull Request</li> </ol>"},{"location":"getting_started/","title":"Getting started","text":"<p>Getting Started</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install the current release from PyPI:</p> <p>.. code-block:: console</p> <p>pip install tatva</p> <p>For development work, clone the repository and install it in editable mode (use your preferred virtual environment tool such as <code>uv</code> or <code>venv</code>):</p> <p>.. code-block:: console</p> <pre><code>git clone https://github.com/smec-ethz/tatva.git\ncd tatva\npip install -e .\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>Create a mesh, pick an element type, and let Operator perform the heavy lifting with JAX arrays:</p> <p>.. code-block:: python</p> <pre><code>import jax.numpy as jnp\nfrom tatva.element import Tri3\nfrom tatva.mesh import Mesh\nfrom tatva.operator import Operator\n\ncoords = jnp.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\nelements = jnp.array([[0, 1, 2], [0, 2, 3]])\n\nmesh = Mesh(coords, elements)\n\nop = Operator(mesh, Tri3())\nnodal_values = jnp.arange(coords.shape[0], dtype=jnp.float64)\n\n# Integrate a nodal field over the mesh\ntotal = op.integrate(nodal_values)\n\n# Evaluate gradients at all quadrature points\ngradients = op.grad(nodal_values)\n</code></pre>"},{"location":"api/tatva.compound/","title":"Compound","text":""},{"location":"api/tatva.compound/#tatva.compound.Compound","title":"tatva.compound.Compound","text":"<pre><code>Compound(arr: Array | None = None)\n</code></pre> <p>A compound array/state.</p> <p>A helper class to create a compound state with multiple fields. It simplifies packing and unpacking into and from a flat array. Useful to manage fields while working with a flat array for the solver.</p> <p>Parameters:</p> <p>Examples:</p> <p>Create a compound state with fields::</p> <pre><code>class MyState(Compound):\n    u = field(shape=(N, 3))\n    phi = field(shape=(N,), default_factory=lambda: jnp.ones(N))\n\nstate = MyState()\n</code></pre> <p>Use <code>state.arr</code> to access the flat array, and <code>state.u</code>, <code>state.phi</code> to access the individual fields.</p> <p>You can use iterator unpacking to directly unpack the fields from the state::</p> <pre><code>u, phi = MyState(arr)\n</code></pre> <p>Methods:</p> <ul> <li> <code>tree_flatten</code>             \u2013              </li> <li> <code>tree_unflatten</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>fields</code>           \u2013            <p>Built-in immutable sequence.</p> </li> <li> <code>size</code>           \u2013            <p>int([x]) -&gt; integer</p> </li> </ul>"},{"location":"api/tatva.compound/#tatva.compound.Compound(arr)","title":"<code>arr</code>","text":"(<code>Array | None</code>, default:                   <code>None</code> )           \u2013            <p>The flat data array. If None, initializes to zeros.</p>"},{"location":"api/tatva.compound/#tatva.compound.Compound.fields","title":"fields  <code>class-attribute</code>","text":"<pre><code>fields = ()\n</code></pre> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"api/tatva.compound/#tatva.compound.Compound.size","title":"size  <code>class-attribute</code>","text":"<pre><code>size = 0\n</code></pre> <p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p> <p>Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.int().  For floating-point numbers, this truncates towards zero.</p> <p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p> <p>int('0b100', base=0) 4</p>"},{"location":"api/tatva.compound/#tatva.compound.Compound.tree_flatten","title":"tree_flatten","text":"<pre><code>tree_flatten() -&gt; tuple[tuple[Array], Any]\n</code></pre>"},{"location":"api/tatva.compound/#tatva.compound.Compound.tree_unflatten","title":"tree_unflatten  <code>classmethod</code>","text":"<pre><code>tree_unflatten(aux_data: Any, children: tuple[Array]) -&gt; Self\n</code></pre>"},{"location":"api/tatva.element/","title":"Elements","text":""},{"location":"api/tatva.element/#tatva.element.Element","title":"tatva.element.Element","text":"<pre><code>Element()\n</code></pre> <p>Base Module for all finite elements, compatible with JAX.</p> <p>Methods:</p> <ul> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>interpolate</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              <p>Returns the shape functions and their derivatives at a point.</p> </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions with respect to the local coordinates.</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Element.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Element.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre> <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Array, Array, Array]</code>           \u2013            <p>A tuple containing: - Interpolated value at the local coordinates (shape: (n_values,)). - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)). - Determinant of the Jacobian (scalar).</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Element.get_local_values(xi)","title":"<code>xi</code>","text":"(<code>Array</code>)           \u2013            <p>Local coordinates (shape: (n_dim,)).</p>"},{"location":"api/tatva.element/#tatva.element.Element.get_local_values(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>Values at the nodes of the element (shape: (n_nodes, n_values)).</p>"},{"location":"api/tatva.element/#tatva.element.Element.get_local_values(nodal_coords)","title":"<code>nodal_coords</code>","text":"(<code>Array</code>)           \u2013            <p>Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).</p>"},{"location":"api/tatva.element/#tatva.element.Element.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Element.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Element.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre> <p>Returns the shape functions and their derivatives at a point.</p>"},{"location":"api/tatva.element/#tatva.element.Element.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(xi: Array) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions with respect to the local coordinates.</p>"},{"location":"api/tatva.element/#tatva.element.Line2","title":"tatva.element.Line2","text":"<pre><code>Line2()\n</code></pre> <p>A 2-node linear interval element.</p> <p>Methods:</p> <ul> <li> <code>interpolate</code>             \u2013              </li> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions with respect to the local coordinates.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>quad_points</code>           \u2013            </li> <li> <code>quad_weights</code>           \u2013            </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Line2.quad_points","title":"quad_points  <code>class-attribute</code>","text":"<pre><code>quad_points = Array([[0.]], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.quad_weights","title":"quad_weights  <code>class-attribute</code>","text":"<pre><code>quad_weights = Array([2.], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Line2.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(xi: Array) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions with respect to the local coordinates.</p>"},{"location":"api/tatva.element/#tatva.element.Tri3","title":"tatva.element.Tri3","text":"<pre><code>Tri3()\n</code></pre> <p>A 3-node linear triangular element.</p> <p>Methods:</p> <ul> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>interpolate</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              <p>Returns the shape functions evaluated at the local coordinates (xi, eta).</p> </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>quad_points</code>           \u2013            </li> <li> <code>quad_weights</code>           \u2013            </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Tri3.quad_points","title":"quad_points  <code>class-attribute</code>","text":"<pre><code>quad_points = Array([[0.33333334, 0.33333334]], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tri3.quad_weights","title":"quad_weights  <code>class-attribute</code>","text":"<pre><code>quad_weights = Array([0.5], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tri3.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tri3.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre> <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Array, Array, Array]</code>           \u2013            <p>A tuple containing: - Interpolated value at the local coordinates (shape: (n_values,)). - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)). - Determinant of the Jacobian (scalar).</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Tri3.get_local_values(xi)","title":"<code>xi</code>","text":"(<code>Array</code>)           \u2013            <p>Local coordinates (shape: (n_dim,)).</p>"},{"location":"api/tatva.element/#tatva.element.Tri3.get_local_values(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>Values at the nodes of the element (shape: (n_nodes, n_values)).</p>"},{"location":"api/tatva.element/#tatva.element.Tri3.get_local_values(nodal_coords)","title":"<code>nodal_coords</code>","text":"(<code>Array</code>)           \u2013            <p>Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).</p>"},{"location":"api/tatva.element/#tatva.element.Tri3.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tri3.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tri3.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre> <p>Returns the shape functions evaluated at the local coordinates (xi, eta).</p>"},{"location":"api/tatva.element/#tatva.element.Tri3.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(*_args, **_kwargs) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).</p>"},{"location":"api/tatva.element/#tatva.element.Quad4","title":"tatva.element.Quad4","text":"<pre><code>Quad4()\n</code></pre> <p>A 4-node bilinear quadrilateral element.</p> <p>Methods:</p> <ul> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>interpolate</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>quad_points</code>           \u2013            </li> <li> <code>quad_weights</code>           \u2013            </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Quad4.quad_points","title":"quad_points  <code>class-attribute</code>","text":"<pre><code>quad_points = Array([[-0.57735026, -0.57735026],\n       [ 0.57735026, -0.57735026],\n       [-0.57735026,  0.57735026],\n       [ 0.57735026,  0.57735026]], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.quad_weights","title":"quad_weights  <code>class-attribute</code>","text":"<pre><code>quad_weights = Array([1., 1., 1., 1.], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre> <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Array, Array, Array]</code>           \u2013            <p>A tuple containing: - Interpolated value at the local coordinates (shape: (n_values,)). - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)). - Determinant of the Jacobian (scalar).</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Quad4.get_local_values(xi)","title":"<code>xi</code>","text":"(<code>Array</code>)           \u2013            <p>Local coordinates (shape: (n_dim,)).</p>"},{"location":"api/tatva.element/#tatva.element.Quad4.get_local_values(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>Values at the nodes of the element (shape: (n_nodes, n_values)).</p>"},{"location":"api/tatva.element/#tatva.element.Quad4.get_local_values(nodal_coords)","title":"<code>nodal_coords</code>","text":"(<code>Array</code>)           \u2013            <p>Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).</p>"},{"location":"api/tatva.element/#tatva.element.Quad4.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Quad4.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(xi: Array) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta).</p>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4","title":"tatva.element.Tetrahedron4","text":"<pre><code>Tetrahedron4()\n</code></pre> <p>A 4-node linear tetrahedral element.</p> <p>Methods:</p> <ul> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>interpolate</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              <p>Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).</p> </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>quad_points</code>           \u2013            </li> <li> <code>quad_weights</code>           \u2013            </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.quad_points","title":"quad_points  <code>class-attribute</code>","text":"<pre><code>quad_points = Array([[0.25, 0.25, 0.25]], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.quad_weights","title":"quad_weights  <code>class-attribute</code>","text":"<pre><code>quad_weights = Array([0.16666667], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre> <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Array, Array, Array]</code>           \u2013            <p>A tuple containing: - Interpolated value at the local coordinates (shape: (n_values,)). - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)). - Determinant of the Jacobian (scalar).</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.get_local_values(xi)","title":"<code>xi</code>","text":"(<code>Array</code>)           \u2013            <p>Local coordinates (shape: (n_dim,)).</p>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.get_local_values(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>Values at the nodes of the element (shape: (n_nodes, n_values)).</p>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.get_local_values(nodal_coords)","title":"<code>nodal_coords</code>","text":"(<code>Array</code>)           \u2013            <p>Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).</p>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre> <p>Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).</p>"},{"location":"api/tatva.element/#tatva.element.Tetrahedron4.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(*_args, **_kwargs) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions with respect to the local coordinates (xi, eta, zeta).</p>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8","title":"tatva.element.Hexahedron8","text":"<pre><code>Hexahedron8()\n</code></pre> <p>A 8-node linear hexahedral element.</p> <p>Methods:</p> <ul> <li> <code>get_jacobian</code>             \u2013              </li> <li> <code>get_local_values</code>             \u2013              <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> </li> <li> <code>gradient</code>             \u2013              </li> <li> <code>interpolate</code>             \u2013              </li> <li> <code>shape_function</code>             \u2013              <p>Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).</p> </li> <li> <code>shape_function_derivative</code>             \u2013              <p>Returns the derivative of the shape functions.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>           \u2013            </li> <li> <code>quad_points</code>           \u2013            </li> <li> <code>quad_weights</code>           \u2013            </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.a","title":"a  <code>class-attribute</code>","text":"<pre><code>a = Array(0.57735026, dtype=float32, weak_type=True)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.quad_points","title":"quad_points  <code>class-attribute</code>","text":"<pre><code>quad_points = Array([[-0.57735026, -0.57735026, -0.57735026],\n       [ 0.57735026, -0.57735026, -0.57735026],\n       [ 0.57735026,  0.57735026, -0.57735026],\n       [-0.57735026,  0.57735026, -0.57735026],\n       [-0.57735026, -0.57735026,  0.57735026],\n       [ 0.57735026, -0.57735026,  0.57735026],\n       [ 0.57735026,  0.57735026,  0.57735026],\n       [-0.57735026,  0.57735026,  0.57735026]], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.quad_weights","title":"quad_weights  <code>class-attribute</code>","text":"<pre><code>quad_weights = Array([1., 1., 1., 1., 1., 1., 1., 1.], dtype=float32)\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.get_jacobian","title":"get_jacobian","text":"<pre><code>get_jacobian(xi: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array]\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.get_local_values","title":"get_local_values","text":"<pre><code>get_local_values(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; tuple[jax.Array, jax.Array, jax.Array]\n</code></pre> <p>Returns a tuple containing the interpolated value, gradient, and determinant of the Jacobian.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Array, Array, Array]</code>           \u2013            <p>A tuple containing: - Interpolated value at the local coordinates (shape: (n_values,)). - Gradient of the nodal values at the local coordinates (shape: (n_dim, n_values)). - Determinant of the Jacobian (scalar).</p> </li> </ul>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.get_local_values(xi)","title":"<code>xi</code>","text":"(<code>Array</code>)           \u2013            <p>Local coordinates (shape: (n_dim,)).</p>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.get_local_values(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>Values at the nodes of the element (shape: (n_nodes, n_values)).</p>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.get_local_values(nodal_coords)","title":"<code>nodal_coords</code>","text":"(<code>Array</code>)           \u2013            <p>Coordinates of the nodes of the element (shape: (n_nodes, n_dim)).</p>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.gradient","title":"gradient","text":"<pre><code>gradient(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.interpolate","title":"interpolate","text":"<pre><code>interpolate(xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array\n</code></pre>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.shape_function","title":"shape_function","text":"<pre><code>shape_function(xi: Array) -&gt; Array\n</code></pre> <p>Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).</p>"},{"location":"api/tatva.element/#tatva.element.Hexahedron8.shape_function_derivative","title":"shape_function_derivative","text":"<pre><code>shape_function_derivative(xi: Array) -&gt; Array\n</code></pre> <p>Returns the derivative of the shape functions.</p>"},{"location":"api/tatva.lifter/","title":"Lifter","text":""},{"location":"api/tatva.lifter/#tatva.lifter.Lifter","title":"tatva.lifter.Lifter","text":"<pre><code>Lifter(size: int, /, *constraints: Constraint)\n</code></pre> <p>Create a lifter that maps between reduced and full vectors.</p> <p>Parameters:</p> <p>Examples::</p> <pre><code>lifter = Lifter(\n    6,\n    Fixed(jnp.array([0, 5]), 0.0),\n    Periodic(dofs=jnp.array([2]), master_dofs=jnp.array([1])),\n)\nu_reduced = jnp.array([10.0, 20.0, 30.0])\nu_full = lifter.lift_from_zeros(u_reduced)\n# u_full -&gt; [0., 10., 10., 20., 30., 0.]\nu_reduced_back = lifter.reduce(u_full)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add</code>             \u2013              <p>Return a new lifter with <code>condition</code> appended to constraints.</p> </li> <li> <code>lift</code>             \u2013              <p>Lift reduced displacement vector to full size.</p> </li> <li> <code>lift_from_zeros</code>             \u2013              <p>Lift reduced vector to a full vector starting from zeros.</p> </li> <li> <code>reduce</code>             \u2013              <p>Extract the reduced vector by selecting free dofs from <code>u_full</code>.</p> </li> <li> <code>tree_flatten</code>             \u2013              </li> <li> <code>tree_unflatten</code>             \u2013              </li> <li> <code>with_values</code>             \u2013              <p>Update the internal runtime values mapping with the given updates.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>at</code>           \u2013            <p>Return a ValueIndexer for setting runtime values by key.</p> </li> <li> <code>constraints</code>           \u2013            <p>Built-in immutable sequence.</p> </li> </ul>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter(size)","title":"<code>size</code>","text":"(<code>int</code>)           \u2013            <p>Total number of dofs in the full vector.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter(*constraints)","title":"<code>*constraints</code>","text":"(<code>Constraint</code>)           \u2013            <p>Extra constraints (e.g., periodic maps).</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.at","title":"at  <code>property</code>","text":"<pre><code>at\n</code></pre> <p>Return a ValueIndexer for setting runtime values by key.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.constraints","title":"constraints  <code>class-attribute</code>","text":"<pre><code>constraints = ()\n</code></pre> <p>Built-in immutable sequence.</p> <p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterable's items.</p> <p>If the argument is a tuple, the return value is the same object.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.add","title":"add","text":"<pre><code>add(condition: Constraint) -&gt; Self\n</code></pre> <p>Return a new lifter with <code>condition</code> appended to constraints.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.lift","title":"lift","text":"<pre><code>lift(u_reduced: Array, u_full: Array) -&gt; Array\n</code></pre> <p>Lift reduced displacement vector to full size.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>Full vector with free dofs set to <code>u_reduced</code> and constraints</p> </li> <li> <code>Array</code>           \u2013            <p>applied (Dirichlet, periodic, etc.).</p> </li> </ul>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.lift(u_reduced)","title":"<code>u_reduced</code>","text":"(<code>Array</code>)           \u2013            <p>Vector on free dofs (length <code>size_reduced</code>).</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.lift(u_full)","title":"<code>u_full</code>","text":"(<code>Array</code>)           \u2013            <p>Base full vector to modify; typically previous solution.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.lift_from_zeros","title":"lift_from_zeros","text":"<pre><code>lift_from_zeros(u_reduced: Array) -&gt; Array\n</code></pre> <p>Lift reduced vector to a full vector starting from zeros.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.reduce","title":"reduce","text":"<pre><code>reduce(u_full: Array) -&gt; Array\n</code></pre> <p>Extract the reduced vector by selecting free dofs from <code>u_full</code>.</p>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.tree_flatten","title":"tree_flatten","text":"<pre><code>tree_flatten() -&gt; tuple[tuple[Any, ...], tuple[Any, ...]]\n</code></pre>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.tree_unflatten","title":"tree_unflatten  <code>classmethod</code>","text":"<pre><code>tree_unflatten(aux_data: tuple[Any, ...], children: tuple[Any, ...]) -&gt; Self\n</code></pre>"},{"location":"api/tatva.lifter/#tatva.lifter.Lifter.with_values","title":"with_values","text":"<pre><code>with_values(updates: dict) -&gt; Self\n</code></pre> <p>Update the internal runtime values mapping with the given updates.</p>"},{"location":"api/tatva.mesh/","title":"Mesh","text":""},{"location":"api/tatva.mesh/#tatva.mesh.Mesh","title":"tatva.mesh.Mesh","text":"<p>A class used to represent a Mesh for finite element method (FEM) simulations.</p> <p>Attributes:</p> <ul> <li> <code>nodes</code>           \u2013            <p>The coordinates of the mesh nodes.</p> </li> <li> <code>elements</code>           \u2013            <p>The connectivity of the mesh elements.</p> </li> </ul> Used by: <ul> <li> API reference <ul> <li> Operator <code></code>\u00a0Operator </li> <li> Sparse <code></code>\u00a0sparse <ul> <li> <code></code>\u00a0create_sparsity_pattern </li> <li> <code></code>\u00a0create_sparsity_pattern_master_slave </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>unit_square</code>             \u2013              <p>Generate a unit square mesh with n_x and n_y nodes in the x and y directions.</p> </li> <li> <code>rectangle</code>             \u2013              <p>Generate a rectangular mesh with specified x and y ranges and number of nodes.</p> </li> </ul>"},{"location":"api/tatva.mesh/#tatva.mesh.Mesh.coords","title":"coords  <code>class-attribute</code>","text":"<pre><code>coords = _tuplegetter(0, 'Alias for field number 0')\n</code></pre> <p>Alias for field number 0</p>"},{"location":"api/tatva.mesh/#tatva.mesh.Mesh.elements","title":"elements  <code>class-attribute</code>","text":"<pre><code>elements = _tuplegetter(1, 'Alias for field number 1')\n</code></pre> <p>Alias for field number 1</p>"},{"location":"api/tatva.mesh/#tatva.mesh.Mesh.unit_square","title":"unit_square  <code>classmethod</code>","text":"<pre><code>unit_square(n_x: int, n_y: int, *, type: ElementType | Literal['triangle', 'quad'] = &lt;ElementType.TRIANGLE: 'triangle'&gt;, dim: Literal[2, 3] = 2) -&gt; Mesh\n</code></pre> <p>Generate a unit square mesh with n_x and n_y nodes in the x and y directions.</p>"},{"location":"api/tatva.mesh/#tatva.mesh.Mesh.rectangle","title":"rectangle  <code>classmethod</code>","text":"<pre><code>rectangle(x: tuple[float, float], y: tuple[float, float], n_x: int, n_y: int, *, type: ElementType | Literal['triangle', 'quad'] = &lt;ElementType.TRIANGLE: 'triangle'&gt;, dim: Literal[2, 3] = 2) -&gt; Mesh\n</code></pre> <p>Generate a rectangular mesh with specified x and y ranges and number of nodes.</p>"},{"location":"api/tatva.operator/","title":"Operator","text":""},{"location":"api/tatva.operator/#tatva.operator.Operator","title":"tatva.operator.Operator","text":"<pre><code>Operator(mesh: Mesh, element: ElementT, batch_size: int | None = None)\n</code></pre> <p>A class that provides an Operator for finite element method (FEM) assembly.</p> <p>Parameters:</p> <p>Provides several operators for evaluating and integrating functions over the mesh, such as <code>integrate</code>, <code>eval</code>, and <code>grad</code>. These operators can be used to compute integrals, evaluate functions at quadrature points, and compute gradients of functions at quadrature points.</p> Example <p>from tatva import Mesh, Tri3, Operator mesh = Mesh.unit_square(10, 10)  # Create a mesh element = Tri3()  # Define an element type operator = Operator(mesh, element) nodal_values = jnp.array(...)  # Nodal values at the mesh nodes energy = operator.integrate(energy_density)(nodal_values)</p> <p>Methods:</p> <ul> <li> <code>map</code>             \u2013              <p>Maps a function over the elements and quad points of the mesh.</p> </li> <li> <code>map_over_elements</code>             \u2013              <p>Maps a function over the elements of the mesh.</p> </li> <li> <code>integrate</code>             \u2013              <p>Integrate a nodal_array, quad_array, or numeric value over the mesh.</p> </li> <li> <code>integrate_per_element</code>             \u2013              <p>Integrate a nodal_array, quad_array, or numeric value over the mesh. Returning the</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluates the nodal values at the quadrature points.</p> </li> <li> <code>grad</code>             \u2013              <p>Computes the gradient of the nodal values at the quad points.</p> </li> <li> <code>interpolate</code>             \u2013              <p>Interpolates nodal values to a set of points in the physical space.</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator(mesh)","title":"<code>mesh</code>","text":"(<code>Mesh</code>)           \u2013            <p>The mesh containing the elements and nodes.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator(element)","title":"<code>element</code>","text":"(<code>ElementT</code>)           \u2013            <p>The element type used for the finite element method.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map","title":"map","text":"<pre><code>map(func: MappableOverElementsAndQuads[P, RT], *, element_quantity: Sequence[int] = ()) -&gt; MappedCallable[P, RT]\n</code></pre> <p>Maps a function over the elements and quad points of the mesh.</p> <p>Returns a function that takes values at nodal points (globally) and returns the vmapped result over the elements and quad points.</p> <p>Parameters:</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map(func)","title":"<code>func</code>","text":"(<code>MappableOverElementsAndQuads[P, RT]</code>)           \u2013            <p>The function to map over the elements and quadrature points.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map(element_quantity)","title":"<code>element_quantity</code>","text":"(<code>Sequence[int]</code>, default:                   <code>()</code> )           \u2013            <p>Indices of the arguments of <code>func</code> that are quantities defined per element. The rest of the arguments are assumed to be defined at nodal points.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map_over_elements","title":"map_over_elements","text":"<pre><code>map_over_elements(func: Callable[P, RT], *, element_quantity: Sequence[int] = ()) -&gt; MappedCallable[P, RT]\n</code></pre> <p>Maps a function over the elements of the mesh.</p> <p>Returns a function that takes values at nodal points (globally) and returns the vmapped result over the elements.</p> <p>Parameters:</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map_over_elements(func)","title":"<code>func</code>","text":"(<code>Callable[P, RT]</code>)           \u2013            <p>The function to map over the elements.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.map_over_elements(element_quantity)","title":"<code>element_quantity</code>","text":"(<code>Sequence[int]</code>, default:                   <code>()</code> )           \u2013            <p>Indices of the arguments of <code>func</code> that are quantities defined per element. The rest of the arguments are assumed to be defined at nodal points.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.integrate","title":"integrate","text":"<pre><code>integrate(arg: Array | Numeric) -&gt; jax.Array\n</code></pre> <p>Integrate a nodal_array, quad_array, or numeric value over the mesh.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>The integral of the nodal values or quadrature values over the mesh.</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator.integrate(arg)","title":"<code>arg</code>","text":"(<code>Array | Numeric</code>)           \u2013            <p>An array of nodal values (shape: (n_nodes, n_values)), an array of quadrature values (shape: (n_elements, n_quad_points, n_values)), or a numeric value (float or int).</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.integrate_per_element","title":"integrate_per_element","text":"<pre><code>integrate_per_element(arg: Array | Numeric) -&gt; jax.Array\n</code></pre> <p>Integrate a nodal_array, quad_array, or numeric value over the mesh. Returning the integral per element.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A <code>jax.Array</code> where each element contains the integral of the values in the</p> </li> <li> <code>Array</code>           \u2013            <p>element (shape: (n_elements, n_values)).</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator.integrate_per_element(arg)","title":"<code>arg</code>","text":"(<code>Array | Numeric</code>)           \u2013            <p>An array of nodal values (shape: (n_nodes, n_values)), an array of quadrature values (shape: (n_elements, n_quad_points, n_values)), or a numeric value (float or int).</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.eval","title":"eval","text":"<pre><code>eval(nodal_values: Array) -&gt; jax.Array\n</code></pre> <p>Evaluates the nodal values at the quadrature points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A <code>jax.Array</code> with the values of the nodal values at each quadrature point of</p> </li> <li> <code>Array</code>           \u2013            <p>each element (shape: (n_elements, n_quad_points, n_values)).</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator.eval(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>The nodal values at the element's nodes (shape: (n_nodes, n_values))</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.grad","title":"grad","text":"<pre><code>grad(nodal_values: Array) -&gt; jax.Array\n</code></pre> <p>Computes the gradient of the nodal values at the quad points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A <code>jax.Array</code> with the gradient of the nodal values at each quadrature point</p> </li> <li> <code>Array</code>           \u2013            <p>of each element (shape: (n_elements, n_quad_points, n_values, n_dim)).</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator.grad(nodal_values)","title":"<code>nodal_values</code>","text":"(<code>Array</code>)           \u2013            <p>The nodal values at the element's nodes (shape: (n_nodes, n_values))</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.interpolate","title":"interpolate","text":"<pre><code>interpolate(arg: Array, points: Array) -&gt; jax.Array\n</code></pre> <p>Interpolates nodal values to a set of points in the physical space.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A <code>jax.Array</code> with the interpolated values at the given points.</p> </li> </ul>"},{"location":"api/tatva.operator/#tatva.operator.Operator.interpolate(arg)","title":"<code>arg</code>","text":"(<code>Array</code>)           \u2013            <p>The nodal values to interpolate.</p>"},{"location":"api/tatva.operator/#tatva.operator.Operator.interpolate(points)","title":"<code>points</code>","text":"(<code>Array</code>)           \u2013            <p>The points to interpolate the function or nodal values to.</p>"},{"location":"api/tatva.plotting/","title":"tatva.plotting package","text":""},{"location":"api/tatva.plotting/#module-contents","title":"Module contents","text":"<p>.. automodule:: tatva.plotting    :members:    :show-inheritance:    :undoc-members:</p>"},{"location":"api/tatva.sparse/","title":"Sparse","text":""},{"location":"api/tatva.sparse/#tatva.sparse","title":"tatva.sparse","text":"<p>Functions:</p> <ul> <li> <code>create_sparsity_pattern</code>             \u2013              <p>Create a sparsity pattern for a given set of elements and constraints.</p> </li> <li> <code>create_sparsity_pattern_KKT</code>             \u2013              <p>Create a sparsity pattern for the KKT system.</p> </li> <li> <code>reduce_sparsity_pattern</code>             \u2013              <p>Reduce a sparse matrix pattern to only the free dofs (for K_ff).</p> </li> <li> <code>create_sparsity_pattern_master_slave</code>             \u2013              <p>Create a sparsity pattern for a system with master\u2013slave DOF mapping, e.g.,</p> </li> <li> <code>get_bc_indices</code>             \u2013              <p>Get the indices of the fixed degrees of freedom.</p> </li> <li> <code>distance2_colors</code>             \u2013              <p>Compute distance-2 coloring based on greedy algorithm.</p> </li> <li> <code>largest_degree_first_distance2_colors</code>             \u2013              <p>Compute distance-2 coloring based on Largest Degree First (LDF) heuristic.</p> </li> <li> <code>smallest_last_distance2_colors</code>             \u2013              <p>Compute distance-2 coloring based on Smallest-Last (SL) ordering.</p> </li> <li> <code>jacfwd</code>             \u2013              <p>Compute the sparse Jacobian using forward-mode automatic differentiation and graph coloring and provided seeds.</p> </li> </ul>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern","title":"create_sparsity_pattern","text":"<pre><code>create_sparsity_pattern(mesh: Mesh, n_dofs_per_node: int, K_shape: Optional[Tuple[int, int]] = None, constraint_elements: Optional[Array] = None)\n</code></pre> <p>Create a sparsity pattern for a given set of elements and constraints.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>sparsity_pattern</code>          \u2013            <p>jax.experimental.sparse.BCOO</p> </li> </ul>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern(mesh)","title":"<code>mesh</code>","text":"(<code>Mesh</code>)           \u2013            <p>Mesh object</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern(n_dofs_per_node)","title":"<code>n_dofs_per_node</code>","text":"(<code>int</code>)           \u2013            <p>Number of degrees of freedom per node</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern(constraint_elements)","title":"<code>constraint_elements</code>","text":"(<code>Optional[Array]</code>, default:                   <code>None</code> )           \u2013            <p>Optional array of constraint elements. If provided, the sparsity pattern will be created for the constraint elements.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern_KKT","title":"create_sparsity_pattern_KKT","text":"<pre><code>create_sparsity_pattern_KKT(mesh: Mesh, n_dofs_per_node: int, B: Array)\n</code></pre> <p>Create a sparsity pattern for the KKT system. Args:     mesh: Mesh object     n_dofs_per_node: Number of degrees of freedom per node     B: Constraint matrix (nb_cons, n_dofs) Returns:     sparsity_pattern_KKT: jax.experimental.sparse.BCOO</p>"},{"location":"api/tatva.sparse/#tatva.sparse.reduce_sparsity_pattern","title":"reduce_sparsity_pattern","text":"<pre><code>reduce_sparsity_pattern(pattern: BCOO, free_dofs: Array) -&gt; BCOO\n</code></pre> <p>Reduce a sparse matrix pattern to only the free dofs (for K_ff).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BCOO</code> (              <code>BCOO</code> )          \u2013            <p>Reduced sparse matrix pattern with rows and columns remapped to the reduced indexing of free dofs.</p> </li> </ul>"},{"location":"api/tatva.sparse/#tatva.sparse.reduce_sparsity_pattern(pattern)","title":"<code>pattern</code>","text":"(<code>BCOO</code>)           \u2013            <p>Sparse matrix pattern in BCOO format on the full set of dofs.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.reduce_sparsity_pattern(free_dofs)","title":"<code>free_dofs</code>","text":"(<code>Array</code>)           \u2013            <p>Array of free dofs as integer indices.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern_master_slave","title":"create_sparsity_pattern_master_slave","text":"<pre><code>create_sparsity_pattern_master_slave(mesh: Mesh, n_dofs_per_node: int, master_slave_map: Union[Array, Mapping[int, int]])\n</code></pre> <p>Create a sparsity pattern for a system with master\u2013slave DOF mapping, e.g., periodic BCs.</p> <p>The returned sparsity corresponds to the reduced system defined on master DOFs only.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li>           \u2013            <p>jax.experimental.sparse.BCOO: Sparsity pattern of the reduced (master-only)</p> </li> <li>           \u2013            <p>system.</p> </li> </ul>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern_master_slave(mesh)","title":"<code>mesh</code>","text":"(<code>Mesh</code>)           \u2013            <p>Mesh object.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern_master_slave(n_dofs_per_node)","title":"<code>n_dofs_per_node</code>","text":"(<code>int</code>)           \u2013            <p>Number of degrees of freedom per node.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.create_sparsity_pattern_master_slave(master_slave_map)","title":"<code>master_slave_map</code>","text":"(<code>Union[Array, Mapping[int, int]]</code>)           \u2013            <p>Either - Array of shape (n_full_dofs,) where each entry maps a full DOF index to its   master DOF index (masters map to themselves). Optionally, an array of shape   (n_nodes,) mapping nodes to master nodes; this will be expanded to DOF-level   by preserving the per-node DOF offset. Entries can be set -1 to indicate   Dirichlet BCs (removal from system). - Mapping (dict-like) from slave DOF index to master DOF index. Indices can be   at DOF-level or node-level; node-level mappings will be expanded to DOFs.</p>"},{"location":"api/tatva.sparse/#tatva.sparse.get_bc_indices","title":"get_bc_indices","text":"<pre><code>get_bc_indices(sparsity_pattern: BCOO, fixed_dofs: Array)\n</code></pre> <p>Get the indices of the fixed degrees of freedom. Args:     sparsity_pattern: jax.experimental.sparse.BCOO     fixed_dofs: (num_fixed_dofs,) Returns:     zero_indices: (num_zero_indices,)     one_indices: (num_one_indices,)</p>"},{"location":"api/tatva.sparse/#tatva.sparse.distance2_colors","title":"distance2_colors","text":"<pre><code>distance2_colors(row_ptr: Array, col_idx: Array, n_dofs: int)\n</code></pre> <p>Compute distance-2 coloring based on greedy algorithm.</p> <p>Parameters:</p> <p>Returns:     colors: Array of colors assigned to each DOF</p>"},{"location":"api/tatva.sparse/#tatva.sparse.distance2_colors(row_ptr)","title":"<code>row_ptr</code>","text":"(<code>Array</code>)           \u2013            <p>CSR row pointer array</p>"},{"location":"api/tatva.sparse/#tatva.sparse.distance2_colors(col_idx)","title":"<code>col_idx</code>","text":"(<code>Array</code>)           \u2013            <p>CSR column indices array</p>"},{"location":"api/tatva.sparse/#tatva.sparse.distance2_colors(n_dofs)","title":"<code>n_dofs</code>","text":"(<code>int</code>)           \u2013            <p>Number of degrees of freedom (size of the matrix)</p>"},{"location":"api/tatva.sparse/#tatva.sparse.largest_degree_first_distance2_colors","title":"largest_degree_first_distance2_colors","text":"<pre><code>largest_degree_first_distance2_colors(row_ptr: Array, col_idx: Array, n_dofs: int) -&gt; Array\n</code></pre> <p>Compute distance-2 coloring based on Largest Degree First (LDF) heuristic. Args:     row_ptr: CSR row pointer array     col_idx: CSR column indices array     n_dofs: Number of degrees of freedom (size of the matrix) Returns:     colors: Array of colors assigned to each DOF</p>"},{"location":"api/tatva.sparse/#tatva.sparse.smallest_last_distance2_colors","title":"smallest_last_distance2_colors","text":"<pre><code>smallest_last_distance2_colors(row_ptr: Array, col_idx: Array, n_dofs: int) -&gt; Array\n</code></pre> <p>Compute distance-2 coloring based on Smallest-Last (SL) ordering. Args:     row_ptr: CSR row pointer array     col_idx: CSR column indices array     n_dofs: Number of degrees of freedom (size of the matrix) Returns:     colors: Array of colors assigned to each DOF</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd","title":"jacfwd","text":"<pre><code>jacfwd(gradient: Callable, row_ptr: Array, col_indices: Array, colors: Array, color_batch_size: int = 10) -&gt; Callable\n</code></pre> <p>Compute the sparse Jacobian using forward-mode automatic differentiation and graph coloring and provided seeds. Uses jax.lax.map to iterate over colors without materializing the entire compressed Jacobian in memory at once.</p> <p>Parameters:</p> <p>Returns:     A function that computes the sparse Jacobian in BCOO format</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd(gradient)","title":"<code>gradient</code>","text":"(<code>Callable</code>)           \u2013            <p>Function whose Jacobian is to be computed</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd(row_ptr, col_indices)","title":"<code>row_ptr, col_indices</code>","text":"\u2013            <p>The sparsity pattern of the matrix</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd(seeds)","title":"<code>seeds</code>","text":"\u2013            <p>List of seed vectors for each color</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd(colors)","title":"<code>colors</code>","text":"(<code>Array</code>)           \u2013            <p>The array of colors used for compression</p>"},{"location":"api/tatva.sparse/#tatva.sparse.jacfwd(color_batch_size)","title":"<code>color_batch_size</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of colors to process in each batch (1 for minimal memory usage, &gt;1 for faster computation but higher memory)</p>"},{"location":"compound/","title":"Compound","text":""},{"location":"compound/#compound","title":"Compound","text":""},{"location":"compound/#problem","title":"Problem","text":"<p>In <code>tatva</code> we intend to define a total energy functional that takes a flat array \\(\\mathbf{z}\\) with all unknown DOFs and returns a scalar. However, the actual unknowns in \\(\\mathbf{z}\\) are most often nodal fields with a specific shape, \\(e.g\\) a displacement field <code>(n_nodes, 2)</code>. Furthermore, the DOF array may include multiple fields. For example, a different nodal field like temperature <code>(n_nodes, 1)</code>, or a set of Lagrange-Multipliers <code>(n_constraints, n)</code>.</p> <p>Why pass a flat array \\(\\mathbf{z}\\) instead of the shaped fields to the energy function?</p> <p>Passing a single flat array instead of the shaped fields has the advantage that the derivatives obtained through AD have convenient shapes.</p> <pre><code>residual_fn = jax.jacrev(energy)  # returns a vector of shape (n_dofs,)\njacobian_fn = jax.jacfwd(residual_fn)  # returns a rank 2 tensor of shape (n_dofs, n_dofs)\n</code></pre> <p>Without a helper abstraction, we usually end up writing repetitive pack/unpack code:</p> <pre><code># unpack\nu = z[: 2 * n_nodes].reshape(n_nodes, 2)\np = z[2 * n_nodes : 3 * n_nodes].reshape(n_nodes, 1)\n\n# pack\nz = jnp.hstack([u.flatten(), p.flatten()])\n</code></pre> <p>Furthermore, when we need to read (or update) values at specific locations in \\(\\mathbf{z}\\), we have to manually construct the correct indices:</p> <pre><code># set u_y = 0 for a set of nodes defined by right_nodes\nz = z.at[right_nodes * 2 + 1].set(0.0)\n</code></pre> <p>This quickly becomes hard to maintain when the number of fields grows.</p>"},{"location":"compound/#solution","title":"Solution","text":"<p>Declare a <code>Compound</code> subclass for your specific problem. Here, we define <code>Solution</code> for two fields, a displacement field with \\(u_x\\) and \\(u_y\\), and a pressure field \\(p\\).</p> <pre><code>import jax\nimport jax.numpy as jnp\nfrom jax import Array\nfrom tatva.compound import Compound, field\n\nn_nodes = 4\n\n\nclass Solution(Compound):\n    u = field((n_nodes, 2))\n    p = field((n_nodes, 1), default_factory=lambda: jnp.ones((n_nodes, 1)))\n</code></pre>"},{"location":"compound/#current-state","title":"Current state","text":"<p>Now, <code>Solution</code> strictly defines our problem and we use it to get a structured view of the flat array of unknowns.</p> <pre><code>state0 = Solution()  # default initial state\nz0 = state0.arr  # arr -&gt; flat array of all fields = z\nprint(z0)\n</code></pre> <pre><code>[0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 1. 1.]\n</code></pre> <p>Given a current \\(\\mathbf{z}\\), simply give it to the constructor of <code>Solution</code>. Each descriptor (the fields) returns a shaped JAX array:</p> <pre><code># random example input\nz = jnp.concatenate([jnp.arange(n_nodes * 2), jnp.ones(n_nodes)])\n\nstate = Solution(z)\nstate.u\n</code></pre> <pre><code>Array([[0., 1.],\n       [2., 3.],\n       [4., 5.],\n       [6., 7.]], dtype=float32)\n</code></pre> <p>Iterator unpacking</p> <p>Compound classes support iterator unpacking. We can directly unpack the state into its fields like this:</p> <pre><code>u, p = Solution(z)\n</code></pre> <p>This is the preferred way to work with <code>Solution</code> in an energy functional: <pre><code>def total_energy(z: Array) -&gt; Array:\n    (u, p) = Solution(z)\n    # compute energy from u and p\n    E = ...\n    return E\n</code></pre></p> <p>Assignments update the correct slice in <code>state.arr</code>.</p> <pre><code>state.u = jnp.linspace(0, 1, 8).reshape(4, 2)\nstate.p = 2.0\n\nprint(\"flat array:\", state.arr)\n</code></pre> <pre><code>flat array: [0.         0.14285715 0.2857143  0.42857146 0.5714286  0.71428573\n 0.8571429  1.         2.         2.         2.         2.        ]\n</code></pre>"},{"location":"compound/#class-level-dof-indexing","title":"Class-level DOF indexing","text":"<p><code>Compound</code> classes and its <code>fields</code> also support indexing to obtain global DOF indices.</p> <ul> <li><code>Solution[i]</code> gives all DOFs at node <code>i</code></li> <li><code>Solution.u[i]</code> gives all DOFs of <code>u</code> at node <code>i</code></li> <li><code>Solution.u[:, 0]</code> gives all DOFs of <code>u_x</code></li> <li><code>Solution.p[:]</code> gives all DOFs for <code>p</code></li> </ul> <pre><code>print(\"all dofs at node 1:\", Solution[1])\nprint(\"x components of u\", Solution.u[:, 0])\n</code></pre> <pre><code>all dofs at node 1: [2 3 9]\nx components of u [0 2 4 6]\n</code></pre> <p>Tip</p> <p>This is particularly useful to declare constrained DOFs:</p> <pre><code>constrained_dofs = jnp.concatenate([Solution.u[top_edge, 1], Solution.u[0, 0]])\n</code></pre> <p>which returns the global indices for \\(u_y\\) at <code>top_edge</code> and \\(u_x\\) for node 0.</p>"},{"location":"compound/#stack-compatible-fields","title":"Stack compatible fields","text":"<p>Note</p> <p>By default, fields are packed in declaration order. You can inspect the mapping from fields to slices directly on the class. In our example, the components for \\(u\\) have indices \\([0, 8]\\), and the components of \\(p\\) are at \\([8, 12]\\).</p> <p>For better memory locality or convenience, fields can be stacked into one combined block at class definition.</p> <p>Warning</p> <p>All stacked fields must share the same base shape on all non-stacked axes.</p> <pre><code>class StackedSolution(\n    Compound,\n    stack_fields=(\"u\", \"p\"),\n    stack_axis=-1,\n):\n    u = field(shape=(n_nodes, 2))\n    p = field(shape=(n_nodes, 1))\n    alpha = field(shape=(n_nodes, 1))\n\n\nStackedSolution.u[:], StackedSolution.p[:], StackedSolution.alpha[:]\n</code></pre> <pre><code>(Array([ 0,  1,  3,  4,  6,  7,  9, 10], dtype=int32),\n Array([ 2,  5,  8, 11], dtype=int32),\n Array([12, 13, 14, 15], dtype=int32))\n</code></pre> <p>As you can see, the flat array is reordered such that \\(u\\) and \\(p\\) components for each node are sequential, \\(i.e.\\) \\(z = [u_{x,1}, u_{y,1}, p_{1}, u_{x,2}, u_{y,2}, p_2, ...]\\).</p>"},{"location":"compound/#jax-compatibility","title":"JAX compatibility","text":"<p><code>Compound</code> is registered as a JAX pytree. This means it works with <code>jit</code>, <code>grad</code>, <code>vmap</code>, and friends.</p> <pre><code>def energy_fn(s: Solution) -&gt; jax.Array:\n    return jnp.sum(s.u**2) + 0.1 * jnp.sum(s.p**2)\n\n\nenergy_jit = jax.jit(energy_fn)\n\nvalue = energy_jit(state)\nprint(\"energy:\", value)\n</code></pre> <pre><code>energy: 4.457143\n</code></pre>"},{"location":"compound/#summary","title":"Summary","text":"<p>Use <code>Compound</code> when your solver expects a flat vector but your model is naturally expressed in multiple shaped fields.</p> <ul> <li>write energy/residual code with readable field names</li> <li>keep a single source of truth for global DOF layout</li> <li>stay fully compatible with JAX transformations</li> </ul>"},{"location":"lifter/","title":"Lifter","text":""},{"location":"lifter/#lifter","title":"Lifter","text":""},{"location":"lifter/#problem","title":"Problem","text":"<p>In constrained problems, we often solve only for free DOFs and reconstruct the full vector afterwards. Typical constraints include:</p> <ul> <li>Dirichlet conditions (fixed values)</li> <li>Periodic constraints (slave DOFs copied from master DOFs)</li> </ul> <p>Without a helper, we manually manage index sets and repeat lifting logic across the codebase.</p> <p>A manual implementation usually looks like this:</p> <pre><code>u_full = u_full.at[free_dofs].set(u_reduced)\nu_full = u_full.at[dirichlet_dofs].set(dirichlet_values)\nu_full = u_full.at[periodic_dofs].set(u_full[periodic_master_dofs])\n</code></pre> <p>This is easy to get wrong, especially when constraint sets evolve.</p>"},{"location":"lifter/#solution","title":"Solution","text":"<p>Use <code>Lifter</code> to define constraints once and map consistently between:</p> <ul> <li>reduced vectors (free DOFs only)</li> <li>full vectors (all DOFs)</li> </ul> <pre><code>import jax\nimport jax.numpy as jnp\nfrom tatva.lifter import DirichletBC, Lifter, PeriodicMap\n\nn_dofs = 8\n</code></pre>"},{"location":"lifter/#define-constraints","title":"Define constraints","text":"<p>Here we fix two boundary DOFs and tie two periodic slave DOFs to masters.</p> <pre><code>dirichlet = DirichletBC(\n    dofs=jnp.array([0, 7]),\n    values=jnp.array([0.0, 0.0]),  # default is zeros, so this line is optional\n)\nperiodic = PeriodicMap(\n    dofs=jnp.array([4, 6]),\n    master_dofs=jnp.array([1, 3]),\n)\n\nlifter = Lifter(n_dofs, dirichlet, periodic)\n</code></pre> <p><code>Lifter</code> computes constrained/free sets and the reduced system size.</p> <pre><code>print(\"constrained dofs:\", lifter.constrained_dofs)\nprint(\"free dofs:\", lifter.free_dofs)\nprint(\"size:\", lifter.size)\nprint(\"size_reduced:\", lifter.size_reduced)\n</code></pre> <pre><code>constrained dofs: [0 4 6 7]\nfree dofs: [1 2 3 5]\nsize: 8\nsize_reduced: 4\n</code></pre>"},{"location":"lifter/#lifting-free-full","title":"Lifting (free -&gt; full)","text":"<p>Use <code>lift_from_zeros</code> when you want the full vector reconstructed from a zero base state.</p> <pre><code>u_reduced = jnp.array([10.0, 20.0, 30.0, 40.0])\nu_full = lifter.lift_from_zeros(u_reduced)\n\nprint(\"u_reduced:\", u_reduced)\nprint(\"u_full:\", u_full)\n</code></pre> <pre><code>u_reduced: [10. 20. 30. 40.]\nu_full: [ 0. 10. 20. 30. 10. 40. 30.  0.]\n</code></pre> <p>Use <code>lift</code> when you want to start from a previous iterate and only overwrite free DOFs before applying constraints.</p> <pre><code>u_prev = jnp.linspace(-1.0, 1.0, n_dofs)\nu_full_from_prev = lifter.lift(u_reduced, u_prev)\n\nprint(\"previous full state:\", u_prev)\nprint(\"lifted full state:\", u_full_from_prev)\n</code></pre> <pre><code>previous full state: [-1.         -0.71428573 -0.42857143 -0.14285709  0.1428572   0.42857146\n  0.71428585  1.        ]\nlifted full state: [ 0. 10. 20. 30. 10. 40. 30.  0.]\n</code></pre> <p>Usage in total energy function</p> <pre><code>def total_energy(z_full: Array) -&gt; Array:\n    (u,) = Solution(z_full)  # See the guide for 'Compound'\n    E = ...  # compute energy from u\n    return E\n\ndef total_energy_free(z_free: Array) -&gt; Array:\n    z_full = lifter.lift_from_zeros(z_free)\n    return total_energy(z_full)\n\nresidual_fn = jax.jacrev(total_energy_free)\n</code></pre> <p>or do it inline: <pre><code>residual_fn = jax.jacrev(lambda z_free: total_energy(lifter.lift_from_zeros(z_free)))\n</code></pre></p>"},{"location":"lifter/#reducing-full-free","title":"Reducing (full -&gt; free)","text":"<p><code>reduce</code> extracts the reduced vector from any full vector.</p> <pre><code>u_reduced_back = lifter.reduce(u_full)\nprint(\"reduced from full:\", u_reduced_back)\n</code></pre> <pre><code>reduced from full: [10. 20. 30. 40.]\n</code></pre> <p>Note</p> <p>The round-trip <code>reduce(lift_from_zeros(u_reduced))</code> returns <code>u_reduced</code>.</p>"},{"location":"lifter/#build-constraints-incrementally","title":"Build constraints incrementally","text":"<p>You can append constraints with <code>add</code>, which returns a new <code>Lifter</code>.</p> <pre><code>base_lifter = Lifter(n_dofs)\nconstrained_lifter = base_lifter.add(dirichlet).add(periodic)\n\nprint(\"base size_reduced:\", base_lifter.size_reduced)\nprint(\"constrained size_reduced:\", constrained_lifter.size_reduced)\n</code></pre>"},{"location":"lifter/#jax-compatibility","title":"JAX compatibility","text":"<p><code>Lifter</code> can be used inside JAX-transformed functions.</p> <pre><code>def reduced_energy(u_r: jax.Array) -&gt; jax.Array:\n    u_f = lifter.lift_from_zeros(u_r)\n    return jnp.sum(u_f**2)\n\n\nenergy_jit = jax.jit(reduced_energy)\nenergy_grad = jax.grad(reduced_energy)\n\nprint(\"energy:\", energy_jit(u_reduced))\nprint(\"gradient:\", energy_grad(u_reduced))\n</code></pre>"},{"location":"lifter/#summary","title":"Summary","text":"<p>Use <code>Lifter</code> when solving constrained systems in reduced coordinates.</p> <ul> <li>centralizes DOF bookkeeping for constraints</li> <li>provides explicit <code>lift</code> / <code>reduce</code> operations</li> <li>keeps reduced-space code clean and JAX-friendly</li> </ul>"},{"location":"operator/","title":"Operator","text":""},{"location":"operator/#operator","title":"Operator","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\n</code></pre>"},{"location":"operator/#how-to-create-an-energy-functional","title":"How to create an energy functional?","text":"<p>In <code>tatva</code>, we define any physical problem as an energy functional \\(\\Psi\\) and then use <code>JAX</code> based differentiation to construct residual operator or tangent stiffness operator. </p> <p><code>Operator</code> module is the core of <code>tatva</code>. This is the functionality you would use always to build a energy functional. <code>Operator</code> module takes a mesh (or sub-mesh) with an element type such as <code>tatva.element.Tri3</code> or <code>tatva.element.Quad4</code> and allows one to</p> <ul> <li>Interpolate nodal values at quadrature points using <code>op.eval</code></li> <li>Take gradient of nodal values at quadrature points using <code>op.grad</code></li> <li>Integrate quadrature values over the domain using <code>op.integrate</code></li> </ul> <p>Tip</p> <p>To build any problem or more specifically any energy functional, all we need are these three functions and how to handle <code>jax.numpy</code> arrays. </p>"},{"location":"operator/#how-to-define-operator","title":"How to define <code>Operator</code>","text":"<p>To create an <code>Operator</code> we need three quantities, a mesh, an element type and batch size</p> <pre><code>op = Operator(mesh, element_type, batch_size)\n</code></pre> <p>The first two arguments are the mesh and the elemetn type.</p> <p>Mesh and Elements in <code>tatva</code></p> <p>In <code>tatva</code> the <code>Mesh</code> object is a utitlity that contains the coordinates of the node and the connectivity as <code>numpy</code> arrays or as <code>jax.numpy</code> arrays. Apart from this <code>Mesh</code> class has no extra functionalities. We do provide a few functions to quickly generate very simple meshes such <code>Mesh.unit_square</code> or <code>Mesh.Rectangle</code> for quick testing. We expect users to create their own meshes using standard softwares such as <code>GMSH</code> and then define the mesh object.</p> <pre><code>mesh = Mesh(coords, connectivity)\n</code></pre> <p>For <code>element</code> types, currently <code>tatva</code> provides H\\(^1\\) finite elements such as <code>Line2</code>, <code>Tri3</code>, <code>Quad4</code>, <code>Tetrahedron4</code> and <code>Hexahedron8</code>. But one easily define there own elements as shown in some of the examples.</p> <p>The last argument that <code>Operator</code> class take is the <code>batch_size</code>. This controls how many elements will be processed together simultaneously. </p> <p>Batch size for computational efficiency</p> <p>If the <code>batch_size</code> is equal to total number of elements than all the elements will be processed (for <code>op.grad</code>, <code>op.integrate</code> or <code>op.eval</code>) simulatenously using <code>jax.lax.map</code>. If the <code>batch_size</code> is 1 then it will process elements one after other. Fixing the <code>batch_size</code> allows you to control the computaitonal speed and the memory requirements. </p> <p>By default <code>Operator</code> has <code>batch_size</code> equal to total number of elements. But when the mesh is versy large then it always efficient to set a value for <code>batch_size</code>.</p>"},{"location":"operator/#getiing-started-with-operator","title":"Getiing started with <code>Operator</code>","text":"<p>For demonstration of the <code>Operator</code> class, we define a unit square domain with a triangular mesh. For ease, <code>tatva</code> provides a simple function <code>Mesh.unit_square</code> from <code>tatva.Mesh</code> module to generate square domain with a triangular mesh.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\nimport jax.numpy as jnp\nfrom tatva import Mesh\n\nmesh = Mesh.unit_square(n_x=1, n_y=1,  type=\"triangle\", dim=2)\nprint(\"Coordinates of the nodes in the mesh: \", mesh.coords)\nprint(\"Connectivity of the elements in the mesh: \", mesh.elements)\n</code></pre> <pre><code>Coordinates of the nodes in the mesh:  [[0. 0.]\n [0. 1.]\n [1. 0.]\n [1. 1.]]\nConnectivity of the elements in the mesh:  [[0 2 3]\n [0 3 1]]\n</code></pre> Visualize the mesh <pre><code>import matplotlib.pyplot as plt\n\nplt.figure(figsize=(3, 3), layout=\"constrained\")\nax = plt.axes()\nax.tripcolor(\n    *mesh.coords.T,\n    mesh.elements,\n    color=\"gray\",\n    lw=0.1,\n    facecolors=jnp.ones(mesh.elements.shape[0]),\n    cmap=\"managua_r\",\n)\nax.set_aspect(\"equal\")\nax.set_xlabel(\"$x$\")\nax.set_ylabel(\"$y$\")\nax.margins(0.0, 0.0)\nplt.show()\n</code></pre> <p></p> <p>Let us define the <code>Operator</code>. We use the default <code>batch_size</code>.</p> <pre><code>from tatva import Operator, element\n\ntri = element.Tri3()\nop = Operator(mesh, tri)\n</code></pre>"},{"location":"operator/#evaluation-at-quadrature-points","title":"Evaluation at quadrature points","text":"<p>Note</p> <p><code>op.eval</code>: Interpolate nodal values at quadrature points.</p> <p>We can use the <code>op</code> to evaluate nodal values at the quadrature points. The function <code>op.eval</code> takes the nodal values and return the values at the quadrature points. The shape of the input array to the <code>Operator.eval</code> method is <code>(n_nodes, n_dofs)</code>. And the shape of the output array is <code>(n_elements, n_quadrature_points, n_dofs)</code>.</p> <p>For example, below we evaluate the coordinate values of the mesh at the quadrature points. This basically means mapping the parameterized quadrature points (\\(\\in [-1, 1]^2\\)) to the physical space. </p> <pre><code>quad_points_in_physical_space = op.eval(mesh.coords)\n\nprint(quad_points_in_physical_space)\nprint(\"Shape of the quadrature points in physical space: \", quad_points_in_physical_space.shape)\n</code></pre> <pre><code>[[[0.66666667 0.33333333]]\n\n [[0.33333333 0.66666667]]]\nShape of the quadrature points in physical space:  (2, 1, 2)\n</code></pre> <p>In the above example, the shape of the output array is <code>(2, 1, 2)</code> because we have 2 elements in the mesh and 1 quadrature point in each element. And each element has 2 degrees of freedom (2 displacement components). To test whether the output is correct, we can plot the quadrature points in the physical space. Below, we plot the mesh and the quadrature points in the physical space.</p> Visualize the quadrature points in physical space <pre><code>quad_points_in_physical_space = quad_points_in_physical_space.squeeze()\n\nplt.figure(figsize=(3, 3), layout=\"constrained\")\nax = plt.axes()\nax.tripcolor(\n    *mesh.coords.T,\n    mesh.elements,\n    color=\"gray\",\n    lw=0.1,\n    facecolors=jnp.ones(mesh.elements.shape[0]),\n    cmap=\"managua_r\",\n)\nax.scatter(\n    quad_points_in_physical_space[:, 0],\n    quad_points_in_physical_space[:, 1],\n    c='tab:red',\n    s=20,\n    marker=\"x\",\n)\nax.set_aspect(\"equal\")\nax.set_xlabel(\"$x$\")\nax.set_ylabel(\"$y$\")\nax.margins(0.0, 0.0)\n</code></pre> <p></p>"},{"location":"operator/#gradients-of-nodal-values","title":"Gradients of nodal values","text":"<p>Note</p> <p><code>op.grad</code>: Evaluate the gradient of nodal values at quadrature points.</p> <p>For most physical problems,  we often need to evaluate the gradient of the nodal values at the quadrature points. For example, in the case of linear elasticity, we need to evaluate the gradient of the displacement field at the quadrature points to compute the strain tensor.  The strain tensor is given as </p> \\[ \\boldsymbol{\\epsilon}(x) = \\dfrac{1}{2} \\left( \\nabla \\boldsymbol{u}(x) + \\nabla \\boldsymbol{u}(x)^T \\right) \\] <p>The <code>Operator</code> class provides a method <code>grad</code> that can be used to evaluate the gradient of the nodal values at the quadrature points.</p> <p>Below, we will see how to use the <code>Operator.grad</code> method to evaluate the gradient of the nodal values at the quadrature points. To do this, we can simply pass our nodal values (in this case, the coordinate values) to the <code>Operator.grad</code> function and it will return the gradient of the nodal values at the quadrature points. </p> <p>Note</p> <p>Remember to pass the nodal values to the <code>Operator.grad</code> function, it must be arranged in the shape <code>(n_nodes, n_dofs)</code>.</p> <pre><code>op.grad(mesh.coords)\n</code></pre> <pre><code>Array([[[[1., 0.],\n         [0., 1.]]],\n\n\n       [[[1., 0.],\n         [0., 1.]]]], dtype=float64)\n</code></pre> <p>As a sanity check, we can see that the gradient is an identity matrix since the gradient \\(\\partial x / \\partial x = 1\\) and \\(\\partial y / \\partial y = 1\\) and all other gradients are zero.</p> <p>Info</p> <p>The shape of the vector returned by the <code>Operator.grad</code> function is <code>(n_elements, n_quadrature_points,  n_dofs, n_dofs)</code>. The first dimension is the number of elements, the second dimension is the number of quadrature points, the third dimension is the number of degrees of freedom, and the fourth dimension is the number of degrees of freedom.</p> <p>For a triangular element, the shape will be <code>(n_elements, 1, 2, 2)</code>. For a quadrilateral element with 4 quadrature points, the shape will be <code>(n_elements, 4, 2, 2)</code>.</p>"},{"location":"operator/#integrating-a-function-over-the-domain","title":"Integrating a function over the domain","text":"<p>Note</p> <p><code>op.integrate</code>: Integrate an array over the domain spanned by the operator's mesh.</p> <p>To create a energy functional we need to integrate quadrature values over the domain. For example, integrating the strain energy density over the domain to get the total strain energy.</p> \\[ \\Psi_\\text{e}(u) = \\int_{\\Omega} \\frac{1}{2} \\sigma : \\epsilon \\, dV \\] <p>where \\(\\sigma\\) is the stress tensor and \\(\\epsilon\\) is the strain tensor evaluated at the quadrature points. A finite element method way of integrating this over a discretized domain is to approximate the integral as a sum of integrals over the elements in the domain.</p> \\[ \\Psi_\\text{e}(u) \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{\\xi_1, \\xi_2 \\in \\mathcal{Q}} \\frac{1}{2} \\sigma(\\xi_1, \\xi_2) : \\epsilon(\\xi_1, \\xi_2) \\, \\text{det}\\mathbf{J} \\, w(\\xi_1, \\xi_2) \\] <p>where \\(\\mathcal{E}\\) is the set of all elements in the domain, \\(\\mathcal{Q}\\) is the set of all quadrature points in the domain, \\(J(\\xi)\\) is the Jacobian of the transformation from the reference element to the physical element, and \\(\\sigma(\\xi)\\) and \\(\\epsilon(\\xi)\\) are the stress and strain tensors evaluated at the quadrature point \\(\\xi\\).</p> <p>The <code>integrate</code> method of the <code>Operator</code> class takes values at quadrature points and returns the integral of the function over the domain.</p> <p>For example, we want to integrate a function \\(f(x, y)\\) over the square domain. We assume that the function is constant and equal to 1.0. </p> \\[ f(x, y) = 1. \\] <p>We will first define nodal values of the function. Since the function is constant, we can simply define the nodal values as an array of shape <code>n_nodes</code>.</p> <pre><code>f_nodal = jnp.full(mesh.coords.shape[0], fill_value=1.0)\n</code></pre> <p>We can then evaluate the function at the quadrature points using the <code>op.eval</code> method.</p> <pre><code>f_at_quad = op.eval(f_nodal)\n</code></pre> <p>And then can pass it to the <code>integrate</code> method.</p> <pre><code>op.integrate(f_at_quad)\n</code></pre> <pre><code>Array(1., dtype=float64)\n</code></pre> <p>If you will notice the above integral is equal to <code>1</code> which also happens to be the area of the domain. This is not a coincidence. The integral of a constant function = 1 over a domain is the area of the domain. So this is a sanity check.</p> <p>Tip</p> <p><code>op.integrate</code> can also take nodal values and even a scalar value. Below, we pass scalar value 1 to <code>op.integrate</code> and also the nodal_values.</p> <pre><code>op.integrate(1)\n</code></pre> <pre><code>Array(1., dtype=float64)\n</code></pre> <pre><code>op.integrate(f_nodal)\n</code></pre> <pre><code>Array(1., dtype=float64)\n</code></pre>"},{"location":"sparse/","title":"Building Stiffness Matrix","text":""},{"location":"sparse/#building-stiffness-matrix","title":"Building Stiffness Matrix","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\n</code></pre>"},{"location":"sparse/#problem","title":"Problem","text":"<p>In finite element analysis, the tangent stiffness matrix (Hessian) \\(\\mathbf{K}\\) is typically sparse. A node only interacts with its immediate neighbors, meaning most entries in \\(\\mathbf{K}\\) are zero. However, standard automatic differentiation (AD) in JAX (<code>jax.jacfwd</code> or <code>jax.jacrev</code>) is unaware of this sparsity. It attempts to recover the full dense matrix by evaluating the Jacobian-Vector Product (JVP) once for every degree of freedom.</p> <p>For a mesh with \\(N\\) degrees of freedom:</p> <ul> <li>Naive AD Cost: \\(N \\times t_{\\text{residual}}\\) (Prohibitive for large \\(N\\))</li> <li>Memory: \\(O(N^2)\\) (Explodes quickly)</li> </ul> <p>We need a way to compute only the non-zero entries of \\(\\mathbf{K}\\) efficiently, ideally in constant time with respect to the mesh size.</p>"},{"location":"sparse/#solution","title":"Solution","text":"<p><code>tatva</code> provides 2 ways to build a computationally efficient stiffness matrix using the energy functional.</p> <ul> <li>Matrix-free operator using Jacobian-vector product.</li> <li>Sparse stiffness matrix using sparse differentiation.</li> </ul> <p>Below we demonstrate the two approaches, we use a pseudo energy functional that is defined for a given mesh.</p> <pre><code>import jax\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\n\nimport jax.numpy as jnp\nimport scipy.sparse as sp\nfrom tatva import sparse, Mesh\n\nmesh = Mesh.unit_square(n_x=1, n_y=1,  type=\"triangle\", dim=2)\nn_dofs_per_node = 2\nn_dofs = mesh.coords.shape[0] * n_dofs_per_node\n\n\ndef energy_fn(u, delta):\n    # Placeholder for the actual energy function\n    return jnp.sum(u**2) + delta * jnp.sum(u)\n\ndelta_current = 1.0  # Example parameter\n</code></pre>"},{"location":"sparse/#matrix-free-operator","title":"Matrix-free Operator","text":"<p>Since we have the energy functional, we can compute the Jacobian-vector product (JVP) \\(\\mathbf{K}\\mathbf{v}\\) directly without ever forming \\(\\mathbf{K}\\). We can use <code>jax.jvp</code> to compute the Jacobian-vector product.</p> <pre><code>def jacobian_vector_product(u, v, delta):\n    \"\"\"\n    Computes (Hessian of Energy at u) * v. It is equivalent to: jvp( jacrev(energy)(u), v ).\n    Args:\n        u: Current solution (shape: [n_dofs])\n        v: Vector to multiply with the Hessian (shape: [n_dofs])\n        delta: Additional parameter for the energy function\n    Returns:\n        The product of the Hessian of the energy function at u with the vector v (shape: [n_dofs])\n    \"\"\"\n    return jax.jvp(jax.jacrev(energy_fn), (u, delta), (v, delta))[1]\n\n\ndelta_f = jacobian_vector_product(u=jnp.zeros(n_dofs), v=jnp.ones(n_dofs), delta=delta_current)\n\n# or can be passed directly to iterative solvers like jax.scipy.sparse.linalg.cg\n</code></pre> <p>Some of the examples that use Matrix-Free Operators are</p> <ul> <li>Linear elasticity</li> <li>Contact between deformable bodies</li> <li>Fracture using Cohesive Traction Law</li> <li>Multiphysical Fracture using Phasefield</li> </ul>"},{"location":"sparse/#sparse-differentiation","title":"Sparse Differentiation","text":"<p><code>tatva.sparse</code> provides a sparse differentiation engine that reduces the cost from \\(O(N)\\) to \\(O(c)\\), where \\(c\\) is the \"chromatic number\" of the mesh (typically small and constant, e.g., ~10-20 for 2D meshes).</p> <p>The process has three steps:</p> <ul> <li>Sparsity Pattern: Identify the non-zero structure.</li> <li>Coloring: Group non-interacting DOFs.</li> <li>Differentiation: Compute the matrix in batches.</li> </ul>"},{"location":"sparse/#sparsity-pattern","title":"Sparsity Pattern","text":"<p>First, we analyze the mesh connectivity to determine which DOFs interact. <code>create_sparsity_pattern</code> returns the indices of the non-zero entries.</p> <pre><code># Extract sparsity topology from the mesh\nsparsity_pattern = sparse.create_sparsity_pattern(\n    mesh,\n    n_dofs_per_node=n_dofs_per_node\n)\n\n# Convert to Scipy CSR format for efficient indexing and later use\nsparsity_pattern_csr = sp.csr_matrix(\n    (\n        sparsity_pattern.data,\n        (sparsity_pattern.indices[:, 0], sparsity_pattern.indices[:, 1]),\n    )\n)\n\nprint(f\"Sparsity: {sparsity_pattern_csr.nnz} non-zeros\")\n</code></pre> <pre><code>Sparsity: 56 non-zeros\n</code></pre> <p>Sparsity Pattern</p> <p>In <code>tatva</code> we provide a few functionalities to generate sparsity patetrn for some specific problem. </p> <ul> <li>for a single physical field problem, <code>sparse.create_sparsity_pattern</code></li> <li>for KKT problems, <code>sparse.create_sparsity_pattern_KKT</code></li> <li>for reduced system via condensation  <code>sparse.reduce_sparsity_pattern</code></li> <li>for periodic problem <code>sparse.create_sparsity_pattern_master_slave</code></li> </ul>"},{"location":"sparse/#graph-coloring","title":"Graph Coloring","text":"<p>We partition the degrees of freedom into independent sets (colors). Two DOFs share the same color only if they do not share an edge in the sparsity graph (Distance-1) and do not share a common neighbor (Distance-2). This ensures that when we perturb all DOFs of \"Color A\" simultaneously, their contributions to the Hessian do not overlap.</p> <p>Coloring Algorithm</p> <p>We use <code>tatva_coloring</code> library to generate colors from a sparsity pattern and take the first return value which is the colors. The implemented coloring algorithm is a naive greedy-algorithm. One can easily use other coloring libraries such as pysparsematrixcolorings to use advanced coloring algorithms which are efficient as they generate less number of colors.</p> <pre><code>from tatva_coloring import distance2_color_and_seeds\n\ncolors = distance2_color_and_seeds(\n    row_ptr=sparsity_pattern_csr.indptr,\n    col_idx=sparsity_pattern_csr.indices,\n    n_dofs=n_dofs,\n)[0]\n\nprint(f\"Number of colors required: {jnp.max(colors) + 1}\")\n</code></pre> <pre><code>Number of colors required: 8\n</code></pre>"},{"location":"sparse/#sparse-differentiation_1","title":"Sparse Differentiation","text":"<p>Finally, we use <code>sparse.jacfwd</code>. This function automatically: -  Perturbs the input \\(\\boldsymbol{u}\\) using the color groups. -  Evaluates the gradient efficiently (Batched JVPs). -  Reconstructs the values into the correct sparse matrix locations.</p> <p>Info</p> <p>We use our own implementation of sparse differentiation to make it scalable for large problems. But one can use libraries such as sparsejac which has been an source of inspiration for our own implementation.</p> <pre><code>gradient_fn = jax.jacrev(energy_fn, argnums=0)  # Gradient with respect to u\n\n# differentiate the residual using the sparsity information\nK_sparse_fn = sparse.jacfwd(\n    gradient=gradient_fn,\n    row_ptr=jnp.array(sparsity_pattern_csr.indptr),\n    col_indices=jnp.array(sparsity_pattern_csr.indices),\n    colors=jnp.array(colors),\n    color_batch_size=10, # Batch size for evaluating the element routine\n)\n\nu_current = jnp.zeros(n_dofs)  # Example input\nK_sparse = K_sparse_fn(u_current, delta_current)\n</code></pre> <p>Info</p> <p>The above function <code>K_sparse_fn</code> needs to be created only once given the sparsity pattern is not changing. Once created one can use te generated function within the simulation loop.  If the energy function takes additional arguments for example history parameters then the generated <code>K_sparse_fn</code> also takes the same arguments. </p>"},{"location":"sparse/#computing-k-at-fixed-additional-parameters","title":"Computing K at fixed additional parameters","text":"<p>Sometimes we need to evalues \\(\\mathbf{K}\\) at fixed values for additinal arguments but updated values of \\(\\boldsymbol{u}\\). For example, in Newton-Raphson or Staggered solvers. Use <code>partial</code> from <code>functools</code> to freeze some argument values. For example</p> <pre><code>from functools import partial\n\nK_sparse_partial = jax.jit(partial(K_sparse_fn, delta=delta_current))\n\n# newton iteration\nfor i in range(iter):\n    ...\n    # call K_sparse_partial with just u\n    K_sparse = K_sparse_partial(u_new)\n    ...\n</code></pre> <p>Some of the examples that use sparse differentiation are:</p> <ul> <li>Periodic Boundary Conditions using Lagrange Multiplier</li> <li>Neural Constitutive Law</li> <li>Neural Operator Element method</li> </ul> <p>Tip</p> <p>For extremely large problems, even storing the sparse matrix indices might be too memory-intensive. Then one should use Matrix-free approach. Also, for the problems where finding the sparsity pattern is difficult.</p>"},{"location":"examples/advection_diffusion_surface/","title":"Non-Variational Formulations","text":""},{"location":"examples/advection_diffusion_surface/#non-variational-formulations","title":"Non-Variational Formulations","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"\n\n    import pyvista as pv\n\n    pv.global_theme.jupyter_backend = 'static'\n    pv.global_theme.notebook = True\n    pv.start_xvfb()\n\n    print(\"Installation complete!\")\nelse:\n    import pyvista as pv\n    pv.global_theme.jupyter_backend = 'client'\n</code></pre> <p>In this notebook, we will solve the surface advection-diffusion equation using the finite element method (FEM) implemented in <code>tatva</code>. We will focus on  2D spherical surface embedded in 3D space.</p> <p>The strong form of the surface advection-diffusion equation is given by:</p> \\[  \\frac{\\partial c}{\\partial t} + \\nabla_s \\cdot (\\boldsymbol{u} c) - D \\Delta_s c = f \\quad \\text{on } \\Gamma  \\] <p>where \\(c\\) is the concentration of the substance on the surface \\(\\Gamma\\), \\(\\boldsymbol{u}\\) is the velocity field tangential to the surface, \\(D\\) is the diffusion coefficient. In this equation, \\(\\Delta_s\\) is the Laplace-Beltrami operator on the surface, and \\(f\\) is a source term. Also, \\(\\nabla_S\\) denotes the surface gradient which is given by projecting the standard gradient onto the tangent plane of the surface.</p> \\[ \\nabla_S = \\mathbf{J}(\\mathbf{J}^T\\mathbf{J})^{-1} \\nabla_\\xi  \\] <p>where \\(\\mathbf{J}\\) is the Jacobian of the mapping from the reference element to the surface element. Expanding the advection term using the product rule, we have:</p> \\[ \\nabla_s \\cdot (\\mathbf{u} c) = \\boldsymbol{u} \\cdot \\nabla_s c + c \\nabla_s \\cdot \\mathbf{u}  \\] <p>We assume that the velocity field \\(\\boldsymbol{u}\\) is divergence-free on the surface, i.e., \\(\\nabla_s \\cdot \\boldsymbol{u} = 0\\). This simplifies the advection term to:</p> \\[ \\nabla_s \\cdot (\\boldsymbol{u} c) = \\boldsymbol{u} \\cdot \\nabla_s c  \\] <p>To derive the weak form, we multiply the equation by a test function \\(v\\) and integrate over the surface \\(\\Gamma\\). Using integration by parts for the diffusion term, we obtain the weak form:</p> \\[  \\mathcal{W}(c, v) =\\underbrace{\\int_{\\Gamma} \\frac{\\partial c}{\\partial t} v ~ d\\Gamma}_{\\text{Inertia}} - \\underbrace{\\int_{\\Gamma} c  \\boldsymbol{u} \\cdot \\nabla_s v ~ d\\Gamma}_{\\text{Advection (Conservative)}} + \\underbrace{\\int_{\\Gamma} D \\nabla_s c \\cdot \\nabla_s v ~ d\\Gamma}_{\\text{Diffusion}} - \\underbrace{\\int_{\\Gamma} f v ~ d\\Gamma}_{\\text{Source}}  \\] <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  \n\nfrom functools import partial\n\nimport equinox as eqx\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element\n</code></pre> <p>We start with creating the mesh for the spherical surface of radius 1.0 using <code>gmsh</code>.</p> View mesh generation functions <pre><code>def create_sphere_mesh(r=1.0, lc=0.5):\n    import gmsh\n    gmsh.initialize()\n    gmsh.model.add(\"Sphere\")\n    gmsh.model.occ.addSphere(0, 0, 0, r)\n    gmsh.model.occ.synchronize()\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", lc)\n    gmsh.model.mesh.generate(2) # Surface mesh only\n\n    _, coords, _ = gmsh.model.mesh.getNodes()\n    nodes = jnp.array(coords.reshape(-1, 3))\n\n    _, _, node_indices = gmsh.model.mesh.getElements(2)\n    elements = jnp.array(node_indices[0].reshape(-1, 3) - 1)\n\n    gmsh.finalize()\n    return Mesh(coords=nodes, elements=elements)\n</code></pre> <pre><code>mesh = create_sphere_mesh(r=radius, lc=0.05)\nn_dofs = mesh.coords.shape[0]\n</code></pre> <pre><code>\n</code></pre> <p>In order to the surface PDE, we  define a triangular element (topology in 2D) embedded in 3D space. We then define the surface gradient operator using the Jacobian of the mapping from the reference element to the surface element. Finally, we assemble the mass and stiffness matrices using the surface gradient operator.</p> <pre><code>def safe_sqrt(x):\n    return jnp.where(x &lt; 0, 0.0, jnp.sqrt(x))\n\n\nclass Tri3Manifold(element.Tri3):\n    \"\"\"A 3-node linear triangular element on a 2D manifold embedded in 3D space.\"\"\"\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -&gt; tuple[Array, Array]:\n        dNdr = self.shape_function_derivative(xi)\n        J = dNdr @ nodal_coords  # shape (2, 2) or (2, 3)\n        G = J @ J.T  # shape (2, 2)\n        detJ = safe_sqrt(jnp.linalg.det(G))\n        return J, detJ\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array:\n        dNdr = self.shape_function_derivative(xi)  # shape (2, 3)\n        J, _ = self.get_jacobian(xi, nodal_coords)  # shape (2, 3)\n\n        G_inv = jnp.linalg.inv(J @ J.T)  # shape (2, 2)\n        J_plus = J.T @ G_inv  # shape (3, 2)\n\n        dudxi = dNdr @ nodal_values  # shape (2, n_values)\n        return J_plus @ dudxi  # shape (3, n_values)\n</code></pre> <p>We can now use the custom-defined element <code>Tri3Manifold</code> and define an <code>Operator</code>.</p> <pre><code>tri3 = Tri3Manifold()\nop = Operator(mesh, tri3)\n</code></pre> <p>To check if the  implementation is correct, we compute the total surface area by integrating the constant function 1 over the surface. The total area should match the known analytical value for the given surface.</p> <pre><code>print(f\"Calculated surface area {op.integrate(1.0)}\")  # Warm-up\nprint(f\"Actual surface area {4 * jnp.pi * radius ** 2}\")\n</code></pre> <p>We also check if the normals are computed correctly by plotting them on the surface mesh.</p> <pre><code>@autovmap(J=2)\ndef get_normals(J: Array) -&gt; Array:\n    \"\"\" Computes the normal vector to the surface given the Jacobian J. \"\"\"\n    n = jnp.cross(J[0, :], J[1, :])\n    n = n / jnp.linalg.norm(n)\n    return n\n\nJ, _ = op.map(tri3.get_jacobian)(mesh.coords)\nnormals = get_normals(J)\n</code></pre>"},{"location":"examples/advection_diffusion_surface/#simulating-the-advection-diffusion-equation","title":"Simulating the Advection-Diffusion equation","text":"<p>Now, we can start with defining the problem parameters and initial conditions. We will discretize the time domain and use the implicit Euler method for time integration.</p> <pre><code>from typing import NamedTuple\n\n\nclass TransportPhysics(NamedTuple):\n    epsilon: float = 0.05  # Diffusivity\n    dt: float = 0.01\n\ntransport_params = TransportPhysics()\n\n@autovmap(coords=1)\ndef get_shear_velocity(coords):\n    x, y, z = coords\n    omega = 10.0 * jnp.sin(3.0 * jnp.pi * z) \n\n    u = jnp.array([-y * omega, x * omega, 0.0])\n    return u\n\n\n@autovmap(coords=1)\ndef get_deformational_velocity(coords):\n    \"\"\"\n    Computes a divergence-free deformational flow.\n    Stream function psi = x * y * z\n    u = curl(psi * x_vec) = grad(psi) x x_vec\n    \"\"\"\n    x, y, z = coords\n    magnitude = 20.0 # Adjust speed\n\n    u_x = x * (z**2 - y**2)\n    u_y = y * (x**2 - z**2)\n    u_z = z * (y**2 - x**2)\n\n    return magnitude * jnp.array([u_x, u_y, u_z])\n\nnodal_velocity = get_deformational_velocity(mesh.coords)\n\n# Precompute velocity at quadrature points\nu_quad = op.eval(nodal_velocity)\n</code></pre> Visualize the velocity field on the surface <pre><code>faces = np.column_stack([\n    np.full(len(mesh.elements), 3, dtype=np.int64), \n    mesh.elements.astype(np.int64)\n]).flatten()\n\n\nsurf = pv.PolyData(np.array(mesh.coords), faces)\nsurf.point_data[\"v\"] = nodal_velocity\nsurf.set_active_vectors(\"v\")\n\npl = pv.Plotter()\npl.add_mesh(surf, color=\"lightgray\")\npl.add_arrows(mesh.coords, nodal_velocity, mag=0.015, color=\"darkred\")\npl.view_isometric()\n</code></pre> <p></p> <p>Now we define functions to compute the total virtual work and total kinetic energy.</p> <pre><code>@autovmap(c=0, grad_c=1, v=0, grad_v=1, u_quad=1, epsilon=0)\ndef compute_advection_diffusion_density(c, grad_c, v, grad_v, u_quad, epsilon):\n    \"\"\"\n    Computes the virtual work density for Advection-Diffusion.\n\n    Args:\n        c, v: Scalar values of trial and test functions\n        grad_c, grad_v: Surface gradients\n        u_quad: Velocity vector at quad point\n        epsilon: Diffusivity\n    \"\"\"\n    term_diffusion = epsilon * jnp.vdot(grad_c, grad_v)\n\n    advection_flux = jnp.vdot(u_quad, grad_c)\n    term_advection = advection_flux * v\n\n    return term_diffusion + term_advection\n\n@jax.jit\ndef total_virtual_work(c_flat : Array, v_flat: Array) -&gt; Array:\n    \"\"\"\n    Computes the spatial part of the weak form: Integral(Advection + Diffusion)\n    Args:\n        c_flat: Flattened nodal values of trial function\n        v_flat: Flattened nodal values of test function\n    \"\"\"\n\n    c_quad = op.eval(c_flat)\n    v_quad = op.eval(v_flat)\n\n    grad_c = op.grad(c_flat)\n    grad_v = op.grad(v_flat)\n\n    # compute density    \n    density = compute_advection_diffusion_density(\n        c_quad, grad_c, \n        v_quad, grad_v, \n        u_quad, \n        transport_params.epsilon\n    )\n\n    # integrate over the surface\n    return op.integrate(density)\n\n\n@autovmap(c=0, v=0)\ndef compute_kinetic_energy_density(c: Array, v: Array) -&gt; Array:\n    \"\"\" Computes the kinetic energy density: 0.5 * c * v \n    Args:\n        c, v: Scalar values of trial and test functions\n    \"\"\"\n\n    return jnp.dot(c, v)\n\n@jax.jit\ndef total_kinetic_energy(c_flat: Array, v_flat: Array) -&gt; Array:\n    \"\"\"\n    Computes the total kinetic energy: Integral(0.5 * c * v)\n    Args:\n        c_flat: Flattened nodal values of trial function\n        v_flat: Flattened nodal values of test function\n    \"\"\"\n    c_quad = op.eval(c_flat)\n    v_quad = op.eval(v_flat)\n\n    kinetic_energy_density = compute_kinetic_energy_density(c_quad, v_quad)\n    kinetic_energy = op.integrate(kinetic_energy_density)\n    return kinetic_energy\n</code></pre> <p>We use <code>jax.jacrev</code> to compute the derivative of the virtual work with respect to the trial function, which gives us the internal force vector. Similarly, we compute the kinetic vector by differentiating the inertia term with respect to the trial function and dividing by the time step.</p> <pre><code>compute_internal_force = jax.jacrev(total_virtual_work, argnums=1)\ncompute_kinetic_force = jax.jacrev(total_kinetic_energy, argnums=1)\n\n\n@jax.jit\ndef _compute_residual(c_new, c_old, dt, v_trial):\n    \"\"\"\n    Computes the global residual vector for the time step.\n    Res = M*(c_new - c_old)/dt + SpatialForce(c_new)\n    Target: Res = 0\n    \"\"\"\n\n    force_spatial = compute_internal_force(c_new, v_trial)\n\n    force_mass = compute_kinetic_force(c_new - c_old, v_trial) / dt\n\n    return force_mass + force_spatial\n\ncompute_residual = jax.jit(partial(_compute_residual, v_trial=jnp.zeros(n_dofs)))\n\n@jax.jit\ndef compute_tangent(x, c_new, c_old, dt):\n    \"\"\"\n    Computes J(c_new) * v using Forward Mode AD (jvp).\n    This is the Linear Operator 'A' for the linear solver.\n    \"\"\"\n\n    _, jvp_val = jax.jvp(\n        lambda c: compute_residual(c, c_old, dt), \n        (c_new,), \n        (x,)\n    )\n    return jvp_val\n</code></pre> BiCGSTAB Linear Solver Implementation <pre><code>@eqx.filter_jit\ndef bicgstab(A, b, atol=1e-8, max_iter=100):\n    x = jnp.zeros_like(b)\n    r = b - A(x)\n    r_hat = r  \n    rho = 1.0\n    alpha = 1.0\n    omega = 1.0\n    v = jnp.zeros_like(b)\n    p = jnp.zeros_like(b)\n\n    initial_state = (x, r, r_hat, rho, alpha, omega, v, p, 0)\n\n    def cond_fun(state):\n        x, r, r_hat, rho, alpha, omega, v, p, iiter = state\n        # Terminate if residual is small enough or max iterations reached\n        res_norm = jnp.linalg.norm(r)\n        return jnp.logical_and(res_norm &gt; atol, iiter &lt; max_iter)\n\n    def body_fun(state):\n        x, r, r_hat, rho_prev, alpha, omega, v, p, iiter = state\n\n        rho = jnp.vdot(r_hat, r)\n        beta = (rho / rho_prev) * (alpha / omega)\n        p = r + beta * (p - omega * v)\n\n        v = A(p)\n        alpha = rho / jnp.vdot(r_hat, v)\n        s = r - alpha * v\n\n        # Check norm of s for early exit if needed, \n        # but for while_loop simplicity we proceed to t\n        t = A(s)\n        omega = jnp.vdot(t, s) / jnp.vdot(t, t)\n\n        x = x + alpha * p + omega * s\n        r = s - omega * t\n\n        return (x, r, r_hat, rho, alpha, omega, v, p, iiter + 1)\n\n    final_state = jax.lax.while_loop(cond_fun, body_fun, initial_state)\n    x_final, iiter_final = final_state[0], final_state[-1]\n\n    return x_final, iiter_final\n</code></pre> <p>Initially, we set the concentration field to be a Gaussian distribution centered at a specific point on the surface. We also define a tangential velocity field that will advect the concentration over time. Finally, we run the time-stepping loop to solve the advection-diffusion equation on the surface. We visualize the concentration field at each time step to observe how it evolves over time.</p> <pre><code># Initial Condition: Gaussian Blob\ndef get_gaussian_initial_condition(mesh_coords, pole=jnp.array([0., 0., 1.]), sigma=0.2):\n    dists_sq = jnp.sum((mesh_coords - pole)**2, axis=1)\n\n    # Gaussian distribution\n    u_0 = jnp.exp(-dists_sq / (2 * sigma**2))\n    return u_0\n\ndef compute_total_concentration(c_flat):\n    c_quad = op.eval(c_flat)\n    return op.integrate(c_quad)\n</code></pre> <pre><code>c_history = [c_curr]\ntotal_conc_per_time = [compute_total_concentration(c_curr)]\n\nn_steps_transport = 100\ndt_transport = 0.05\n\nfor step in range(n_steps_transport):\n\n    rhs = -compute_residual(c_curr, c_curr, dt_transport)\n\n    A = eqx.Partial(compute_tangent, c_new=c_curr, c_old=c_curr, dt=dt_transport)\n\n    delta_c, info = bicgstab(A, rhs, atol=1e-6, max_iter=100)\n\n    c_curr = c_curr + delta_c\n    c_history.append(c_curr)\n\n    total_conc = compute_total_concentration(c_curr)\n    total_conc_per_time.append(total_conc)\n\n    if step % 10 == 0:\n        print(f\"Step {step}: Max c = {jnp.max(c_curr):.4f}\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/advection_diffusion_surface/#visualization","title":"Visualization","text":"Visualize concentration on the surface at a specific time step <pre><code>sargs = dict(\n    title=r\"Concentration\" + \"\\n\",\n    height=0.08,       # Reduces the length (25% of window height)\n    width=0.2,        # Adjusts thickness\n    vertical=False,     # Orientation\n    position_x=0.4,   # Distance from left edge (5%)\n    position_y=0.08,   # Distance from bottom edge (5%)\n    title_font_size=20,\n    label_font_size=16,\n    color=\"black\",      # Useful for white/transparent backgrounds\n    font_family=\"arial\",\n)\nsurf = pv.PolyData(np.array(mesh.coords), faces)\nsurf.point_data[\"c\"] = c_history[10].flatten()\nsurf.point_data[\"v\"] = nodal_velocity\nsurf.set_active_scalars(\"c\")\n\ncontours = surf.contour(isosurfaces=10)\n\npl = pv.Plotter()\npl.add_mesh(surf, scalars=\"c\", cmap=\"pink_r\", scalar_bar_args=sargs)\npl.add_mesh(contours, cmap=\"pink_r\", line_width=0.5, show_scalar_bar=False)\npl.show()\n</code></pre>"},{"location":"examples/contact_3d/","title":"Contact Mechanics","text":""},{"location":"examples/contact_3d/#contact-mechanics","title":"Contact mechanics","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif \"google.colab\" in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n\n    import pyvista as pv\n\n    pv.global_theme.jupyter_backend = \"static\"\n    pv.global_theme.notebook = True\n    pv.start_xvfb()\n\n    print(\"Installation complete!\")\n</code></pre> <p>In this notebook, we model the circular punch of a sphere on a deformable plane.</p> <p>We impose the contact constraint via a penalty approach by extending the total energy functional with a contact contribution \\(\\Psi_c\\), defined by the penalty density</p> \\[ \\psi_c =\\frac{1}{2} \\kappa~ g(\\boldsymbol{u}_1, \\boldsymbol{u}_2)^2~, \\] <p>where \\(g\\) represents the normal gap function and \\(\\kappa\\) denotes the penalty parameter. The resulting total energy functional reads</p> \\[\\begin{equation} \\Psi(\\boldsymbol{u}_1, \\boldsymbol{u}_2) = \\int_{\\Omega_{\\mathrm{sphere}}}\\psi_\\varepsilon(\\boldsymbol{u}_1)~\\mathrm{d\\Omega} + \\int_{\\Omega_{\\mathrm{cube}}}\\psi_\\varepsilon(\\boldsymbol{u}_2)~\\mathrm{d\\Omega} +\\int_{\\mathrm{S}_c}\\psi_c(\\boldsymbol{u}_1, \\boldsymbol{u}_2) ~\\mathrm{dS} ~ . \\end{equation}\\] <pre><code>import gmsh\nimport jax\nimport jax.numpy as jnp\nimport pyvista as pv\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator\n\njax.config.update(\"jax_enable_x64\", True)\npv.global_theme.jupyter_backend = \"static\"\n</code></pre>"},{"location":"examples/contact_3d/#meshing","title":"Meshing","text":"<p>We generate two separate meshes with <code>gmsh</code>; one for the cube, another one for the sphere.</p> Code for generating the mesh <pre><code>import math\nimport os\n\nimport gmsh\nimport numpy as np\n\n\ndef extract_mesh() -&gt; tuple[Mesh, dict[str, np.ndarray]]:\n    node_tags, coords, _ = gmsh.model.mesh.getNodes()\n    nodes_arr = np.array(coords).reshape(-1, 3)\n\n    # Gmsh tags are 1-based and potentially non-contiguous.\n    # We map them to 0-based indices for JAX.\n    tag_map = {tag: i for i, tag in enumerate(node_tags)}\n\n    # 5. Extract Tetrahedral Elements\n    # Element Type 4 is 4-node Tetrahedron\n    # getElementsByType returns: (element_tags, node_tags)\n    try:\n        _, elem_node_tags = gmsh.model.mesh.getElementsByType(4)\n        elem_node_tags = np.array(elem_node_tags).reshape(-1, 4)\n    except ValueError:\n        gmsh.finalize()\n        raise\n\n    # Remap tags to 0-based indices\n    # Vectorized map using a lookup array if tags are contiguous,\n    # but loop is safer for general Gmsh output.\n    elements_array = np.array(\n        [[tag_map[tag] for tag in elem] for elem in elem_node_tags]\n    )\n\n    # --- physical surfaces: collect 2D triangle faces (Tri3 = type 2) per physical group ---\n    # Returns: dict[name:str] -&gt; np.ndarray[int] of shape (ntri, 3) with 0-based node indices\n    physical_surfaces: dict[str, np.ndarray] = {}\n\n    for dim, pg_tag in gmsh.model.getPhysicalGroups(dim=2):\n        name = gmsh.model.getPhysicalName(dim, pg_tag)\n\n        # Entities (surface tags) that belong to this physical group\n        entities = gmsh.model.getEntitiesForPhysicalGroup(dim, pg_tag)\n\n        tris = []\n        for ent in entities:\n            # Get all mesh elements on this surface entity\n            types, _, node_tags_by_type = gmsh.model.mesh.getElements(dim, ent)\n\n            for etype, ntags in zip(types, node_tags_by_type):\n                if etype != 2:  # Tri3 only\n                    continue\n                tri_nodes = np.array(ntags, dtype=np.int64).reshape(-1, 3)\n                tris.append(tri_nodes)\n\n        if not tris:\n            physical_surfaces[name] = np.zeros((0, 3), dtype=np.int32)\n            continue\n\n        tri_nodes = np.vstack(tris)\n        tri_nodes_0 = np.array(\n            [[tag_map[t] for t in tri] for tri in tri_nodes], dtype=np.int32\n        )\n        physical_surfaces[name] = tri_nodes_0\n\n    return Mesh(\n        coords=np.array(nodes_arr),\n        elements=np.array(elements_array),\n    ), physical_surfaces\n\n\ndef get_mesh_cube(\n    h_min: float, h_max: float, h_corner: float\n) -&gt; tuple[Mesh, dict[str, np.ndarray]]:\n    ox, oy, oz = (0.0, 0.0, 0.0)\n    lx, ly, lz = (1.0, 1.0, -1.0)\n\n    gmsh.initialize()\n    gmsh.model.add(\"cube\")\n\n    gmsh.option.setNumber(\"General.Terminal\", 1)\n    gmsh.option.setNumber(\"Mesh.MshFileVersion\", 4.1)\n    gmsh.option.setNumber(\"Mesh.ElementOrder\", 1)\n    gmsh.option.setNumber(\"Mesh.Algorithm3D\", 4)\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", min(h_min, h_corner))\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", h_max)\n\n    # ---- 1) points (we keep the tags we care about) ----\n    p000 = gmsh.model.occ.addPoint(ox, oy, oz)  # corner of interest for refinement\n    p100 = gmsh.model.occ.addPoint(ox + lx, oy, oz)\n    p110 = gmsh.model.occ.addPoint(ox + lx, oy + ly, oz)\n    p010 = gmsh.model.occ.addPoint(ox, oy + ly, oz)\n\n    # ---- 2) curves + base surface (z = oz) ----\n    l01 = gmsh.model.occ.addLine(p000, p100)\n    l12 = gmsh.model.occ.addLine(p100, p110)\n    l23 = gmsh.model.occ.addLine(p110, p010)\n    l30 = gmsh.model.occ.addLine(p010, p000)\n\n    cloop = gmsh.model.occ.addCurveLoop([l01, l12, l23, l30])\n    s_base = gmsh.model.occ.addPlaneSurface([cloop])\n\n    # ---- 3) volume via extrusion; capture returned entity tags (no searching) ----\n    # extrude returns a list of (dim, tag). For a surface extrusion, you get:\n    #   - one top surface (dim=2),\n    #   - one volume (dim=3),\n    #   - lateral surfaces (dim=2) ...\n    out = gmsh.model.occ.extrude([(2, s_base)], 0.0, 0.0, lz)\n\n    vol_tag = next(tag for (dim, tag) in out if dim == 3)\n\n    gmsh.model.occ.synchronize()\n\n    # ---- refinement field around p000 (no point lookup loop) ----\n    dist = gmsh.model.mesh.field.add(\"Distance\")\n    gmsh.model.mesh.field.setNumbers(dist, \"PointsList\", [p000])\n\n    thr = gmsh.model.mesh.field.add(\"Threshold\")\n    gmsh.model.mesh.field.setNumber(thr, \"IField\", dist)\n    gmsh.model.mesh.field.setNumber(thr, \"LcMin\", h_corner)\n    gmsh.model.mesh.field.setNumber(thr, \"LcMax\", h_max)\n    gmsh.model.mesh.field.setNumber(thr, \"DistMin\", h_corner * 10)\n    gmsh.model.mesh.field.setNumber(thr, \"DistMax\", 0.5)\n    gmsh.model.mesh.field.setAsBackgroundMesh(thr)\n\n    # ---- physical groups (using known tags) ----\n    vol_pg = gmsh.model.addPhysicalGroup(3, [vol_tag], tag=1)\n    gmsh.model.setPhysicalName(3, vol_pg, \"cube_volume\")\n\n    top_pg = gmsh.model.addPhysicalGroup(2, [s_base], tag=2)\n    gmsh.model.setPhysicalName(2, top_pg, \"cube_top\")\n\n    gmsh.model.mesh.generate(3)\n\n    mesh = extract_mesh()\n    gmsh.finalize()\n    return mesh\n\n\ndef mesh_bottom_eighth_sphere(\n    radius: float, h_min: float, h_max: float, h_corner: float\n) -&gt; tuple[Mesh, dict[str, np.ndarray]]:\n    r_ref = 0.6 * radius\n\n    gmsh.initialize()\n    gmsh.model.add(\"bottom_eighth_sphere\")\n\n    gmsh.option.setNumber(\"General.Terminal\", 1)\n    gmsh.option.setNumber(\"Mesh.MshFileVersion\", 4.1)\n    gmsh.option.setNumber(\"Mesh.ElementOrder\", 1)\n    gmsh.option.setNumber(\"Mesh.Algorithm3D\", 4)\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", min(h_min, h_corner))\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", h_max)\n\n    sphere_tag = gmsh.model.occ.addSphere(0.0, 0.0, radius, radius)\n    box_tag = gmsh.model.occ.addBox(0.0, 0.0, 0.0, radius, radius, radius)\n\n    out = gmsh.model.occ.intersect(\n        [(3, sphere_tag)], [(3, box_tag)], removeObject=True, removeTool=True\n    )\n    gmsh.model.occ.synchronize()\n\n    vol_tag = out[0][0][1]\n\n    # ---- refinement field at corner (0,0,0) ----\n    # use Distance field with an explicit point; no need to find an existing CAD vertex\n    p_corner = gmsh.model.occ.addPoint(0.0, 0.0, 0.0)\n    gmsh.model.occ.synchronize()\n\n    dist = gmsh.model.mesh.field.add(\"Distance\")\n    gmsh.model.mesh.field.setNumbers(dist, \"PointsList\", [p_corner])\n\n    thr = gmsh.model.mesh.field.add(\"Threshold\")\n    gmsh.model.mesh.field.setNumber(thr, \"IField\", dist)\n    gmsh.model.mesh.field.setNumber(thr, \"LcMin\", h_corner)\n    gmsh.model.mesh.field.setNumber(thr, \"LcMax\", h_max)\n    gmsh.model.mesh.field.setNumber(thr, \"DistMin\", h_corner * 10)\n    gmsh.model.mesh.field.setNumber(thr, \"DistMax\", r_ref)\n    gmsh.model.mesh.field.setAsBackgroundMesh(thr)\n\n    # --- identify spherical boundary surface by OCC type ---\n    boundary = gmsh.model.getBoundary([(3, vol_tag)], oriented=False)\n\n    tol = 1e-6  # &lt;&lt; much looser than 1e-10\n\n    boundary = gmsh.model.getBoundary([(3, vol_tag)], oriented=False)\n\n    sphere_candidates = []\n    for dim, tag in boundary:\n        if dim != 2:\n            continue\n        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(2, tag)\n\n        is_x0 = abs(xmin - 0.0) &lt; tol and abs(xmax - 0.0) &lt; tol\n        is_y0 = abs(ymin - 0.0) &lt; tol and abs(ymax - 0.0) &lt; tol\n        is_zr = abs(zmin - radius) &lt; tol and abs(zmax - radius) &lt; tol\n\n        if not (is_x0 or is_y0 or is_zr):\n            sphere_candidates.append(tag)\n\n    if len(sphere_candidates) != 1:\n        raise RuntimeError(\n            f\"Expected 1 spherical face, got {len(sphere_candidates)}: {sphere_candidates}\"\n        )\n\n    curved_surface = sphere_candidates[0]\n\n    vol_pg = gmsh.model.addPhysicalGroup(3, [vol_tag], tag=1)\n    gmsh.model.setPhysicalName(3, vol_pg, \"sphere_bottom_eighth\")\n\n    surf_pg = gmsh.model.addPhysicalGroup(2, [curved_surface], tag=2)\n    gmsh.model.setPhysicalName(2, surf_pg, \"sphere_outer\")\n\n    gmsh.model.mesh.generate(3)\n\n    mesh = extract_mesh()\n    gmsh.finalize()\n    return mesh\n</code></pre> Code for visualizing the mesh with PyVista <pre><code>pv.set_jupyter_backend(\"client\")\n\n\ndef get_pyvista_grid(mesh, cell_type=\"quad\"):\n    if mesh.coords.shape[1] == 2:\n        pv_points = np.hstack((mesh.coords, np.zeros(shape=(mesh.coords.shape[0], 1))))\n    else:\n        pv_points = np.array(mesh.coords)\n\n    cell_type_dict = {\n        \"quad\": 4,\n        \"triangle\": 3,\n        \"tetra\": 4,\n        \"hexahedron\": 8,\n    }\n\n    pv_cells = np.hstack(\n        (\n            np.full(\n                fill_value=cell_type_dict[cell_type], shape=(mesh.elements.shape[0], 1)\n            ),\n            mesh.elements,\n        )\n    )\n\n    pv_cell_type_dict = {\n        \"quad\": pv.CellType.QUAD,\n        \"triangle\": pv.CellType.TRIANGLE,\n        \"tetra\": pv.CellType.TETRA,\n        \"hexahedron\": pv.CellType.HEXAHEDRON,\n    }\n    cell_types = np.full(\n        fill_value=pv_cell_type_dict[cell_type], shape=(mesh.elements.shape[0],)\n    )\n\n    grid = pv.UnstructuredGrid(pv_cells.flatten(), cell_types, pv_points)\n\n    return grid\n</code></pre> <pre><code>h_min = 0.01\nh_max = 0.3\nh_corner = 0.002\n\nmesh_cube, pg_cube = get_mesh_cube(h_min, h_max, h_corner)\n</code></pre> Output <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Line)\nInfo    : [ 10%] Meshing curve 2 (Line)\nInfo    : [ 20%] Meshing curve 3 (Line)\nInfo    : [ 30%] Meshing curve 4 (Line)\nInfo    : [ 40%] Meshing curve 5 (Line)\nInfo    : [ 50%] Meshing curve 6 (Line)\nInfo    : [ 60%] Meshing curve 7 (Line)\nInfo    : [ 60%] Meshing curve 8 (Line)\nInfo    : [ 70%] Meshing curve 9 (Line)\nInfo    : [ 80%] Meshing curve 10 (Line)\nInfo    : [ 90%] Meshing curve 11 (Line)\nInfo    : [100%] Meshing curve 12 (Line)\nInfo    : Done meshing 1D (Wall 0.00662568s, CPU 0.00702s)\nInfo    : Meshing 2D...\nInfo    : [  0%] Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 2 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 3 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 4 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 5 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 6 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0299664s, CPU 0.030777s)\nInfo    : Meshing 3D...\nInfo    : Meshing volume 1 (Frontal)\nInfo    : Region 1 Face 2, 1 intersect\nInfo    : Region 1 Face 3, 1 intersect\nInfo    : Region 1 Face 4, 1 intersect\nInfo    : Region 1 Face 5, 1 intersect\nInfo    : Region 1 Face 1, 1 intersect\nInfo    : Region 1 Face 6, 0 intersect\nInfo    : CalcLocalH: 872 Points 0 Elements 1740 Surface Elements \nInfo    : Check subdomain 1 / 1 \nInfo    : 1740 open elements \nInfo    : Meshing subdomain 1 of 1 \nInfo    : 1740 open elements \nInfo    : Use internal rules \nInfo    : 1740 open elements \nInfo    : Delaunay meshing \nInfo    : number of points: 872 \nInfo    : blockfill local h \nInfo    : number of points: 1540 \nInfo    : Points: 1540 \nInfo    : Elements: 8619 \nInfo    : 0 open elements \nInfo    : Num open: 0 \nInfo    : free: 0, fixed: 8619 \nInfo    : SwapImprove  \nInfo    : 0 swaps performed \nInfo    : 0 open elements \nInfo    : Num open: 0 \nInfo    : free: 0, fixed: 8619 \nInfo    : SwapImprove  \nInfo    : 0 swaps performed \nInfo    : 0 degenerated elements removed \nInfo    : Remove intersecting \nInfo    : Remove outer \nInfo    : tables filled \nInfo    : outer removed \nInfo    : 1740 open elements \nInfo    : 1540 points, 6728 elements \nInfo    : 0 open elements \nInfo    : 0 open faces \nInfo    : start tetmeshing \nInfo    : Use internal rules \nInfo    : 0 open elements \nInfo    : Success ! \nInfo    : 1540 points, 6728 elements \nInfo    : Done meshing 3D (Wall 0.0881125s, CPU 0.08839s)\nInfo    : Optimizing mesh...\nInfo    : Optimizing volume 1\nInfo    : Optimization starts (volume = 1) with worst = 0.025172 / average = 0.681818:\nInfo    : 0.00 &lt; quality &lt; 0.10 :        21 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :        56 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :       173 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       284 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       301 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :       575 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      1641 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      2139 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      1132 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       403 elements\nInfo    : 191 edge swaps, 48 node relocations (volume = 1): worst = 0.233998 / average = 0.696372 (Wall 0.00368831s, CPU 0.003454s)\nInfo    : 209 edge swaps, 56 node relocations (volume = 1): worst = 0.239252 / average = 0.696901 (Wall 0.00458502s, CPU 0.004442s)\nInfo    : 210 edge swaps, 56 node relocations (volume = 1): worst = 0.239252 / average = 0.69702 (Wall 0.00514286s, CPU 0.004442s)\nInfo    : No ill-shaped tets in the mesh :-)\nInfo    : 0.00 &lt; quality &lt; 0.10 :         0 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         0 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :        11 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       301 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       346 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :       650 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      1593 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      2106 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      1160 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       420 elements\nInfo    : Done optimizing mesh (Wall 0.00831119s, CPU 0.007544s)\nInfo    : 1540 nodes 8469 elements\n</code></pre> <pre><code>pl = pv.Plotter(window_size=(800, 600))\npl.add_mesh(get_pyvista_grid(mesh_cube, cell_type=\"tetra\"), show_edges=True)\npl.camera.azimuth = -120\n_ = pl.show()\n</code></pre> <p></p> <pre><code>radius = 0.6\n\nmesh_sphere, pg_sphere = mesh_bottom_eighth_sphere(radius, h_min, h_max, h_corner)\ngrid_sphere = get_pyvista_grid(mesh_sphere, cell_type=\"tetra\")\n</code></pre> Output <pre><code>Info    : Cannot bind existing OpenCASCADE volume 1 to second tag 2                                                                              \nInfo    : Could not preserve tag of 3D object 2 (-&gt;1)\nInfo    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Circle)\nInfo    : [ 20%] Meshing curve 2 (Circle)\nInfo    : [ 50%] Meshing curve 4 (Circle)\nInfo    : [ 60%] Meshing curve 5 (Line)\nInfo    : [ 80%] Meshing curve 6 (Line)\nInfo    : [ 90%] Meshing curve 7 (Line)\nInfo    : Done meshing 1D (Wall 0.00492711s, CPU 0.004363s)\nInfo    : Meshing 2D...\nInfo    : [  0%] Meshing surface 1 (Sphere, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 2 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 3 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 4 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0239352s, CPU 0.024075s)\nInfo    : Meshing 3D...\nInfo    : Meshing volume 1 (Frontal)\nInfo    : Region 1 Face 1, 1 intersect\nInfo    : Region 1 Face 2, 1 intersect\nInfo    : Region 1 Face 3, 0 intersect\nInfo    : Region 1 Face 4, 0 intersect\nInfo    : CalcLocalH: 770 Points 0 Elements 1536 Surface Elements \nInfo    : Check subdomain 1 / 1 \nInfo    : 1536 open elements \nInfo    : Meshing subdomain 1 of 1 \nInfo    : 1536 open elements \nInfo    : Use internal rules \nInfo    : 1536 open elements \nInfo    : Delaunay meshing \nInfo    : number of points: 770 \nInfo    : blockfill local h \nInfo    : number of points: 1485 \nInfo    : Points: 1485 \nInfo    : Elements: 8398 \nInfo    : 8 open elements \nInfo    : Num open: 8 \nInfo    : free: 93, fixed: 8305 \nInfo    : SwapImprove  \nInfo    : 11 swaps performed \nInfo    : 0 open elements \nInfo    : Num open: 0 \nInfo    : free: 0, fixed: 8395 \nInfo    : SwapImprove  \nInfo    : 0 swaps performed \nInfo    : 0 degenerated elements removed \nInfo    : Remove intersecting \nInfo    : Remove outer \nInfo    : tables filled \nInfo    : outer removed \nInfo    : 1536 open elements \nInfo    : 1485 points, 6768 elements \nInfo    : 0 open elements \nInfo    : 0 open faces \nInfo    : start tetmeshing \nInfo    : Use internal rules \nInfo    : 0 open elements \nInfo    : Success ! \nInfo    : 1485 points, 6768 elements \nInfo    : Done meshing 3D (Wall 0.0863274s, CPU 0.084559s)\nInfo    : Optimizing mesh...\nInfo    : Optimizing volume 1\nInfo    : Optimization starts (volume = 0.112136) with worst = 0.0388189 / average = 0.670886:\nInfo    : 0.00 &lt; quality &lt; 0.10 :         8 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :        92 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :       225 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       384 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       321 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :       643 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      1447 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      2136 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      1166 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       346 elements\nInfo    : 232 edge swaps, 76 node relocations (volume = 0.112136): worst = 0.129743 / average = 0.688803 (Wall 0.00520292s, CPU 0.004763s)\nInfo    : 258 edge swaps, 91 node relocations (volume = 0.112136): worst = 0.233733 / average = 0.690749 (Wall 0.00665104s, CPU 0.006296s)\nInfo    : 261 edge swaps, 95 node relocations (volume = 0.112136): worst = 0.233733 / average = 0.691017 (Wall 0.00753035s, CPU 0.007228s)\nInfo    : No ill-shaped tets in the mesh :-)\nInfo    : 0.00 &lt; quality &lt; 0.10 :         0 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         0 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :        16 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       371 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       419 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :       715 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      1422 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      2112 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      1163 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       382 elements\nInfo    : Done optimizing mesh (Wall 0.0109751s, CPU 0.01085s)\nInfo    : 1486 nodes 8248 elements\n</code></pre> <pre><code>Warning : Intersection - BOPAlgo_AlertUnableToOrientTheShape BOPAlgo_AlertUnableToOrientTheShape\n</code></pre> <pre><code>pl = pv.Plotter(window_size=(800, 600))\npl.add_mesh(grid_sphere, show_edges=True)\npl.camera.azimuth = -120\n_ = pl.show()\n</code></pre> <p></p>"},{"location":"examples/contact_3d/#problem-setup","title":"Problem setup","text":""},{"location":"examples/contact_3d/#system-definition","title":"System definition","text":"<p>Our problem includes two fields; \\(u_\\text{cube}\\) and \\(u_\\text{sphere}\\).  To handle them, we use both <code>Compound</code> and <code>Lifter</code> utilities. We first declare the <code>Solution</code> as a subclass of <code>Compound</code>:</p> <pre><code>from tatva.compound import Compound, field\n\n\nclass Solution(Compound):\n    u_cube = field((mesh_cube.coords.shape[0], 3))\n    u_sphere = field((mesh_sphere.coords.shape[0], 3))\n</code></pre> <p>Then we find boundary nodes to apply BCs.  Exploiting the symmetry in the problem, we model only a quarter of the full geometric problem. This means, we need to constrain these respective displacements. Finally, we apply a top displacement <code>z_disp</code> on the top surface of the sphere octant. We construct the <code>lifter</code> for our problem:</p> <pre><code>from tatva.lifter import DirichletBC, Lifter\n\nz_disp = -0.001\n\ncube_sym_x = jnp.where(jnp.isclose(mesh_cube.coords[:, 0], 0.0))[0]\ncube_sym_y = jnp.where(jnp.isclose(mesh_cube.coords[:, 1], 0.0))[0]\ncube_bottom = jnp.where(jnp.isclose(mesh_cube.coords[:, 2], -1.0))[0]\nsphere_sym_x = jnp.where(jnp.isclose(mesh_sphere.coords[:, 0], 0.0))[0]\nsphere_sym_y = jnp.where(jnp.isclose(mesh_sphere.coords[:, 1], 0.0))[0]\nsphere_top = jnp.where(\n    jnp.isclose(mesh_sphere.coords[:, 2], mesh_sphere.coords[:, 2].max())\n)[0]\n\nlifter = Lifter(\n    Solution.size,\n    DirichletBC(Solution.u_cube[cube_sym_x, 0]),\n    DirichletBC(Solution.u_cube[cube_sym_y, 1]),\n    DirichletBC(Solution.u_cube[cube_bottom, 2]),\n    DirichletBC(Solution.u_sphere[sphere_sym_x, 0]),\n    DirichletBC(Solution.u_sphere[sphere_sym_y, 1]),\n    DirichletBC(Solution.u_sphere[sphere_top, 2], z_disp),\n)\n</code></pre> <p>Finally, we now define the two <code>Operators</code> from the meshes and the element type.  In this example, we use 4-node Tetrahedral elements <code>Tetrahedron4</code>.</p> <pre><code>from tatva.element import Tetrahedron4\n\nel = Tetrahedron4()\nop_cube = Operator(mesh_cube, el)\nop_sphere = Operator(mesh_sphere, el)\n</code></pre>"},{"location":"examples/contact_3d/#contact-energy-definition","title":"Contact energy definition","text":"<p>Contact potential energy contribution based on gap function between two deformable meshes. The contact contribution to the total energy is evaluated using a two-pass node-to-surface contact detection scheme. The total contact energy is defined as the arithmetic mean of the two surface contributions. This symmetric formulation avoids master\u2013slave bias and improves robustness, particularly for comparable mesh resolutions and material stiffnesses.</p> <p>First pass (sphere \u2192 cube):</p> <ul> <li>Each surface node of the sphere is orthogonally projected onto the cube surface.</li> <li>The normal gap is evaluated at the projection point.</li> <li>The corresponding penalty density is integrated over the sphere surface.</li> </ul> <p>Second pass (cube \u2192 sphere):</p> <ul> <li>Each surface node of the cube is orthogonally projected onto the sphere surface.</li> <li>The normal gap is computed analogously.</li> <li>The penalty contribution is integrated over the cube surface.</li> </ul> <p>To integrate across the 3d manifold, we need to define a <code>Tri3Manifold</code> element type, and we define two surface operators:</p> <pre><code>from tatva.element import Tri3\n\n\nclass Tri3Manifold(Tri3):\n    \"\"\"A 3-node linear triangular element on a 2D manifold embedded in 3D space.\"\"\"\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -&gt; tuple[Array, Array]:\n        dNdr = self.shape_function_derivative(xi)\n        J = dNdr @ nodal_coords  # shape (2, 2) or (2, 3)\n        G = J @ J.T  # shape (2, 2)\n        detJ = jnp.sqrt(jnp.linalg.det(G))\n        return J, detJ\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array:\n        dNdr = self.shape_function_derivative(xi)  # shape (2, 3)\n        J, _ = self.get_jacobian(xi, nodal_coords)  # shape (2, 3)\n\n        G_inv = jnp.linalg.inv(J @ J.T)  # shape (2, 2)\n        J_plus = J.T @ G_inv  # shape (3, 2)\n\n        dudxi = dNdr @ nodal_values  # shape (2, n_values)\n        return J_plus @ dudxi  # shape (3, n_values)\n\n\nsurf_op_cube = Operator(\n    mesh_cube._replace(elements=pg_cube[\"cube_top\"]), Tri3Manifold()\n)\n\nsurf_op_sphere = Operator(\n    mesh_sphere._replace(elements=pg_sphere[\"sphere_outer\"]), Tri3Manifold()\n)\n</code></pre> Code for computing the gap function <pre><code>@autovmap(x=1, el_coords=2, reference_point=1)\ndef _get_gap_and_inside_mask(\n    x: Array, el_coords: Array, reference_point: Array, *, eps: float = 1e-12\n) -&gt; tuple[Array, Array]:\n    x0, x1, x2 = el_coords\n    e0 = x1 - x0\n    e1 = x2 - x0\n\n    n0 = jnp.cross(e0, e1)\n    nn = jnp.vdot(n0, n0)\n\n    def _degenerate():\n        return jnp.array(False), jnp.array(0.0, dtype=x.dtype)\n\n    def _regular():\n        n = n0 / jnp.sqrt(nn)\n        # orient normal (only affects gap sign)\n        n = jnp.where(jnp.dot(n, x0 - reference_point) &gt; 0.0, n, -n)\n\n        gap = jnp.dot(x - x0, n)\n        xproj = x - gap * n\n\n        # inside test using edge half-spaces\n        c0 = jnp.dot(jnp.cross(x1 - x0, xproj - x0), n)\n        c1 = jnp.dot(jnp.cross(x2 - x1, xproj - x1), n)\n        c2 = jnp.dot(jnp.cross(x0 - x2, xproj - x2), n)\n\n        inside = (c0 &gt;= -eps) &amp; (c1 &gt;= -eps) &amp; (c2 &gt;= -eps)\n        return inside, gap\n\n    return jax.lax.cond(nn &lt; eps**2, _degenerate, _regular)\n\n\ndef get_gap(x: Array, el_coords: Array, reference_point: Array) -&gt; Array:\n    mask, gap = _get_gap_and_inside_mask(x, el_coords, reference_point)\n    return jnp.min(jnp.where(mask, gap, jnp.inf))\n</code></pre> <pre><code>@jax.jit\ndef contact_energy(x_cube: Array, x_sphere: Array, *, kappa: float = 1e4) -&gt; Array:\n    \"\"\"Contact energy with cube as master surface.\n\n    Args:\n        x_cube: (n_cube_nodes, 3) array of cube node coordinates\n        x_sphere: (n_sphere_nodes, 3) array of sphere node coordinates\n        kappa: penalty stiffness parameter\n    \"\"\"\n    # for each sphere surface quad point, compute gap to cube surface\n    gap = jax.vmap(\n        lambda x: get_gap(x, x_cube[pg_cube[\"cube_top\"]], jnp.array([0.1, 0.1, -1.0])),\n        in_axes=0,\n    )(surf_op_sphere.eval(x_sphere))\n\n    # for each cube surface quad point, compute gap to sphere surface\n    gap_inv = jax.vmap(\n        lambda x: get_gap(\n            x,\n            x_sphere[pg_sphere[\"sphere_outer\"]],\n            jnp.array([0.1, 0.1, radius + 0.1]),\n        ),\n        in_axes=0,\n    )(surf_op_cube.eval(x_cube))\n\n    # only negative gaps contribute to energy; add singleton dim for integration\n    gap = jnp.minimum(gap, 0.0)[..., None]\n    gap_inv = jnp.minimum(gap_inv, 0.0)[..., None]\n\n    # return arithmetic mean of sphere and cube contributions to energy\n    return 0.5 * (\n        0.5 * kappa * surf_op_sphere.integrate(gap**2)\n        + 0.5 * kappa * surf_op_cube.integrate(gap_inv**2)\n    )\n</code></pre>"},{"location":"examples/contact_3d/#elastic-energy-definition","title":"Elastic energy definition","text":"<p>Here, we employ a linear elastic material model. We define the material point functions for strain and stress:</p> <pre><code>@autovmap(grad_u=2)\ndef compute_strain(grad_u: Array) -&gt; Array:\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps: Array, mu: float, lmbda: float) -&gt; Array:\n    I = jnp.eye(3)\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * I\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy(grad_u: Array, mu: float, lmbda: float) -&gt; Array:\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n</code></pre> <p>Let's quickly add a material utility.</p> <pre><code>from typing import NamedTuple\n\n\nclass Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  # Diffusion coefficient\n    lmbda: float  # Diffusion coefficient\n\n    @classmethod\n    def from_youngs_poisson(cls, E: float, nu: float) -&gt; \"Material\":\n        mu = E / (3 - 6 * nu)\n        lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat_cube = Material.from_youngs_poisson(1, 0.3)\nmat_sphere = Material.from_youngs_poisson(1, 0.3)\n</code></pre> <p>Finally, we define the total energy functional:</p> <pre><code>@jax.jit(static_argnames=(\"kappa\",))\ndef total_energy_full(u_full: Array, kappa: float = 1e2) -&gt; Array:\n    (u1, u2) = Solution(u_full)\n    e1 = strain_energy(op_cube.grad(u1), mat_cube.mu, mat_cube.lmbda)\n    e2 = strain_energy(op_sphere.grad(u2), mat_sphere.mu, mat_sphere.lmbda)\n\n    # extract surface displacements, compute position, and contact energy\n    xcube_surf = mesh_cube.coords + u1  # current position of all cube nodes\n    xsphere_surf = mesh_sphere.coords + u2  # current position of all sphere nodes\n    e_contact = contact_energy(xcube_surf, xsphere_surf, kappa=kappa)\n\n    return op_cube.integrate(e1) + op_sphere.integrate(e2) + e_contact\n\n\n@jax.jit(static_argnames=(\"kappa\",))\ndef total_energy(u_free: Array, kappa: float = 1e2) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = lifter.lift_from_zeros(u_free)\n    return total_energy_full(u_full, kappa=kappa)\n\n\nresidual_fn = jax.jacrev(total_energy)\n</code></pre>"},{"location":"examples/contact_3d/#solve-system","title":"Solve system","text":"Newton-Krylov solver <pre><code>import time\nfrom functools import partial\n\n\n@partial(jax.jit, static_argnames=[\"gradient\", \"compute_tangent\"])\ndef newton_krylov_solver(\n    u,\n    gradient,\n    compute_tangent,\n):\n    residual = gradient(u)\n    norm_res = jnp.linalg.norm(residual)\n\n    init_val = (u, 0, norm_res)\n\n    def cond_fun(state):\n        u, iiter, norm_res = state\n        return jnp.logical_and(norm_res &gt; 1e-8, iiter &lt; 10)\n\n    def body_fun(state):\n        jax.debug.print(\n            \"Iteration {iter}, Residual norm: {res:.2e}\", iter=state[1], res=state[2]\n        )\n        u, iiter, norm_res = state\n        residual = gradient(u)\n        A = jax.jit(compute_tangent(u))\n\n        start_time = time.time()\n        du, _ = jax.scipy.sparse.linalg.cg(A, -residual, maxiter=1000)\n        end_time = time.time()\n        jax.block_until_ready(du)\n        jax.debug.print(\"  CG solve time: {time:.2f} s\", time=end_time - start_time)\n\n        u = u + du\n\n        residual = gradient(u)\n        norm_res = jnp.linalg.norm(residual)\n        jax.debug.print(\"  Residual norm: {res:.2e}\", res=norm_res)\n\n        return (u, iiter + 1, norm_res)\n\n    final_u, final_iiter, final_norm = jax.lax.while_loop(cond_fun, body_fun, init_val)\n    jax.debug.print(\"  Residual: {res:.2e}\", res=final_norm)\n\n    return final_u, final_norm\n</code></pre> <pre><code>fn = partial(residual_fn, kappa=2e3)\n\n\ndef _jvp(loc: Array) -&gt; Callable[[Array], Array]:\n    def _jvp_fn(v: Array) -&gt; Array:\n        return jax.jvp(fn, (loc,), (v,))[1]\n\n    return _jvp_fn\n\n\nz0 = jnp.zeros(lifter.size_reduced).at[Solution.u_sphere[:, 2]].set(z_disp)\nz_sol, norm_res = newton_krylov_solver(u=z0, gradient=fn, compute_tangent=_jvp)\n</code></pre> Output <pre><code>CG solve time: 0.03 s\nIteration 0, Residual norm: 4.11e-03\n  Residual norm: 1.54e-05\n  CG solve time: 0.03 s\nIteration 1, Residual norm: 1.54e-05\n  Residual norm: 1.21e-05\n  CG solve time: 0.03 s\nIteration 2, Residual norm: 1.21e-05\n  Residual norm: 4.33e-07\n  CG solve time: 0.03 s\nIteration 3, Residual norm: 4.33e-07\n  Residual norm: 9.20e-08\n  CG solve time: 0.03 s\nIteration 4, Residual norm: 9.20e-08\n  Residual norm: 5.61e-09\n  Residual: 5.61e-09\n</code></pre> <pre><code># Use Solution to unpack the full solution vector into displacements for cube and sphere\nu1, u2 = Solution(lifter.lift_from_zeros(z_sol))\n</code></pre>"},{"location":"examples/contact_3d/#results","title":"Results","text":"Function to visualize the results with PyVista <pre><code>def plot_contact_result(\n    mesh_sphere,\n    mesh_cube,\n    u_sphere,\n    u_cube,\n    stress_sphere,\n    stress_cube,\n    *,\n    factor: float = 1.0,\n    cmap: str = \"managua\",\n    clim=None,\n    backend: str = \"static\",\n):\n    import numpy as np\n    import pyvista as pv\n\n    def von_mises_stress(stress):\n        sxx = stress[..., 0, 0]\n        syy = stress[..., 1, 1]\n        szz = stress[..., 2, 2]\n        sxy = stress[..., 0, 1]\n        syz = stress[..., 1, 2]\n        szx = stress[..., 2, 0]\n        return np.sqrt(\n            0.5\n            * (\n                (sxx - syy) ** 2\n                + (syy - szz) ** 2\n                + (szz - sxx) ** 2\n                + 6 * (sxy**2 + syz**2 + szx**2)\n            )\n        )\n\n    # --- build grids ---\n    grid_s = get_pyvista_grid(mesh_sphere, cell_type=\"tetra\")\n    grid_s.point_data[\"u\"] = np.asarray(u_sphere)\n    grid_s.cell_data[\"sig_vm\"] = von_mises_stress(np.asarray(stress_sphere))\n    grid_s.cell_data[\"sig_zz\"] = np.asarray(stress_sphere[..., 2, 2])\n    grid_s.cell_data[\"sig_zx\"] = np.asarray(stress_sphere[..., 2, 0])\n    grid_s.warp_by_vector(\"u\", factor=factor, inplace=True)\n\n    grid_c = get_pyvista_grid(mesh_cube, cell_type=\"tetra\")\n    grid_c.point_data[\"u\"] = np.asarray(u_cube)\n    grid_c.cell_data[\"sig_vm\"] = von_mises_stress(np.asarray(stress_cube))\n    grid_c.cell_data[\"sig_zz\"] = np.asarray(stress_cube[..., 2, 2])\n    grid_c.cell_data[\"sig_zx\"] = np.asarray(stress_cube[..., 2, 0])\n    grid_c.warp_by_vector(\"u\", factor=factor, inplace=True)\n\n    pv.set_jupyter_backend(backend)\n    pl = pv.Plotter(window_size=(800, 1200))\n\n    for g in (grid_s, grid_c):\n        g.translate((-0.2, 0, 0), inplace=True)\n\n    # --- lighting ---\n    pl.remove_all_lights()\n    pl.add_light(\n        pv.Light(position=(-1, -10.0, 2), focal_point=(0, 0, 0), intensity=0.4)\n    )\n    pl.add_light(\n        pv.Light(position=(-8, -15.0, 3), focal_point=(0, 0, 0), intensity=1.0)\n    )\n\n    # --- sphere ---\n    surf_s = grid_s.cell_data_to_point_data()\n    pl.add_mesh(\n        surf_s,\n        scalars=\"sig_vm\",\n        show_edges=True,\n        edge_opacity=0.1,\n        cmap=cmap,\n        clim=clim,\n        opacity=1.0,\n    )\n    iso_s = surf_s.extract_surface(algorithm=\"dataset_surface\").contour(\n        isosurfaces=np.logspace(-3, 0, 20), scalars=\"sig_vm\"\n    )\n    pl.add_mesh(iso_s, line_width=3, cmap=cmap, clim=clim, opacity=0.6)\n\n    # --- cube ---\n    surf_c = grid_c.cell_data_to_point_data()\n    pl.add_mesh(\n        surf_c,\n        scalars=\"sig_vm\",\n        show_edges=True,\n        edge_opacity=0.1,\n        cmap=cmap,\n        clim=clim,\n        opacity=1.0,\n    )\n    iso_c = surf_c.extract_surface(algorithm=\"dataset_surface\").contour(\n        isosurfaces=np.logspace(-3, 0, 20), scalars=\"sig_vm\"\n    )\n    pl.add_mesh(iso_c, line_width=3, cmap=cmap, clim=clim, opacity=0.6)\n\n    pl.add_axes(interactive=False, line_width=3)\n    pl.scalar_bar.SetVisibility(False)\n\n    pl.view_isometric()\n    pl.camera.azimuth -= 160\n    pl.camera.elevation -= 20\n    pl.camera.position = (\n        pl.camera.position[0] - 1.4,\n        pl.camera.position[1] - 2,\n        pl.camera.position[2] + 1,\n    )\n    pl.camera.zoom(2)\n\n    return pl.show()\n</code></pre> <pre><code>eps_box = compute_strain(op_cube.grad(u1))\nstress_box = compute_stress(eps_box, mat_cube.mu, mat_cube.lmbda)\neps_sphere = compute_strain(op_sphere.grad(u2))\nstress_sphere = compute_stress(eps_sphere, mat_sphere.mu, mat_sphere.lmbda)\n\n\nplot_contact_result(mesh_sphere, mesh_cube, u2, u1, stress_sphere, stress_box)\n</code></pre> Code for computing the analytical solution for Hertzian contact <pre><code>def force_analytical(E: float, R: float, d: float) -&gt; float:\n    \"\"\"Analytical contact force for a sphere indenting a half-space.\n\n    Args:\n        E: Young's modulus of the half-space.\n        R: Radius of the sphere.\n        d: Indentation depth (positive).\n    \"\"\"\n    return 4 / 3 * E * R**0.5 * d**1.5\n\n\ndef get_a(R: float, d: float) -&gt; float:\n    \"\"\"Hertzian contact radius from indentation depth.\"\"\"\n    return np.sqrt(R * d)\n\n\ndef p_max(F, a):\n    return 3 / 2 * F / np.pi / a**2\n\n\ndef sig_z(z, a: float, p_max: float) -&gt; float:\n    return -p_max / (1 + (z / a) ** 2)\n\n\ndef get_analytical_stress(F, R, d):\n    E = 1.0\n    nu = 0.3\n    a = get_a(R, d)\n    pmax = p_max(F, a)\n    return lambda z: sig_z(z, a, pmax)\n</code></pre> Create plot for \\(\\sigma_{zz}\\) along the centerline and compare to analytical solution <pre><code>import matplotlib.pyplot as plt\nfrom scipy.interpolate import NearestNDInterpolator, LinearNDInterpolator\n\nnodal_coords = mesh_cube.coords\nquad_coords = op_cube.eval(mesh_cube.coords).squeeze()\n\ngrid = get_pyvista_grid(mesh_cube, cell_type=\"tetra\")\ngrid.cell_data[\"sig_zz\"] = stress_box[..., 2, 2]\nnodal_sig = np.array(grid.cell_data_to_point_data().point_data[\"sig_zz\"])\ninterp = LinearNDInterpolator(nodal_coords, nodal_sig)\n\n# z-extent of the cube\nzmin = mesh_cube.coords[:, 2].min()\nzmax = mesh_cube.coords[:, 2].max()\n\n# Compute analytical solution for Hertzian contact\nz_disp_abs = abs(z_disp)\nradius = 0.6\nE_star = 1.0 / (1 - 0.3**2)\nF = force_analytical(E_star, radius, z_disp_abs)\na = get_a(radius, z_disp_abs)\n\nfig = plt.figure(figsize=(3.4, 3.0))  # single-column width\nax = fig.add_subplot(111)\n\n\ndef plot_sig_zz(ax):\n    zi = np.linspace(zmin + (zmax - zmin) * 0.8, zmax + z_disp_abs / 2, 200)\n    p0 = p_max(F, a)\n    ax.plot(\n        get_analytical_stress(F, radius, z_disp_abs)(zi) / p0,\n        zi,\n        \":\",\n        label=\"Hertz solution\",\n        color=\"C1\",\n    )\n    ax.plot(\n        interp(np.c_[np.full_like(zi, 0.0), np.full_like(zi, 0.0), zi]) / p0,\n        zi,\n        \"-\",\n        label=\"tatva\",\n        c=\"C1\",\n    )\n\n    ax.set_xlabel(r\"$\\sigma_{zz} / p_0$\")\n    ax.set_ylabel(r\"$z$\")\n    ax.grid()\n    ax.set_xlim(right=0)\n    ax.set_ylim(top=0)\n    ax.legend()\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\nplot_sig_zz(ax)\n</code></pre> Create plot for traction distribution \\(p(r)\\) and compare to analytical solution <pre><code>fig = plt.figure(figsize=(3.4, 3.0))  # single-column width\nax = fig.add_subplot(111)\n\n\ndef plot_traction(ax):\n    xi = np.linspace(0.0, 1.4 * a, 200)\n    offset = 0.00\n\n    p0 = 3 * F / 2 / np.pi / a**2\n\n    def p_of_r(r: NDArray) -&gt; NDArray:\n        return np.where(r &lt; a, p0 * np.sqrt(1 - (r / a) ** 2), 0)\n\n    ax.plot(xi / a, p_of_r(xi) / p0, \":\", label=\"Hertz solution\", c=\"C0\")\n    ax.plot(\n        xi / a,\n        -interp(np.c_[np.full_like(xi, offset), xi, np.full_like(xi, 0)]) / p0,\n        \"-\",\n        label=\"tatva\",\n        c=\"C0\",\n    )\n    ax.grid()\n    ax.legend(loc=\"lower left\")\n    ax.set_xlim((0, 1.4))\n    ax.set(xlabel=r\"$r / a$\", ylabel=r\"$p(r) / p_0$\")\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\n\nplot_traction(ax)\n</code></pre> <pre><code>/tmp/ipykernel_122596/4210642787.py:13: RuntimeWarning: invalid value encountered in sqrt\n  return np.where(r &lt; a, p0 * np.sqrt(1 - (r / a) ** 2), 0)\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/","title":"Cohesive Fracture","text":""},{"location":"examples/fracture_quasistatic_3d/#cohesive-fracture","title":"Cohesive Fracture","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"\n\n    import pyvista as pv\n\n    pv.global_theme.jupyter_backend = 'static'\n    pv.global_theme.notebook = True\n    pv.start_xvfb()\n\n    print(\"Installation complete!\")\nelse:\n    import pyvista as pv\n    pv.global_theme.jupyter_backend = 'client'\n</code></pre> <p>In this notebook, we simulate quasi-static crack propagation along an interface in a 3D plate using Cohesive law. This is an example of mixed-dimensional coupling where the energies are computed in domains which are dimensionally separate. In bulk which is a 3D domain and along the interface which a 2D domain.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\n\nimport os\nfrom typing import NamedTuple\n\nimport equinox as eqx\nimport gmsh\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport meshio\nimport numpy as np\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element\n</code></pre> <p>The critical length for plain strain condition is given by:</p> \\[L_\\text{G} = 2\\mu \\Gamma/\\pi(1-\\nu)\\sigma_{\\infty}^2\\] <p>where \\(\\mu\\) is the shear modulus, \\(\\Gamma\\) is the fracture energy, \\(\\nu\\) is the Poisson's ratio, and \\(\\sigma_{\\infty}\\) is the stress at infinity. For plain strain condition, the effective Young's modulus is given by:</p> \\[E_\\text{eff} = \\frac{E}{1-\\nu^2}\\] <p>where \\(E\\) is the Young's modulus and \\(\\nu\\) is the Poisson's ratio. For a specimen stretched by a prestrain \\(\\epsilon\\), the applied stress at infinity is given by:</p> \\[\\sigma_{\\infty} = \\epsilon /E_\\text{eff}\\]"},{"location":"examples/fracture_quasistatic_3d/#sec-plate-mode-I","title":"Pre-crack plate under Mode I loading","text":"<p>We generate a plate with a pre-crack of length \\(L_G\\) and the cohesive interface lies at \\(x \\geq L_G\\) and \\(y=0\\).</p> View mesh generation functions <pre><code>def generate_unstructured_hex_fracture_3d(\n    length: float,\n    height: float,\n    thickness: float,\n    crack_tip_x: float,\n    mesh_size_tip: float,\n    mesh_size_far: float,\n    work_dir: str = \"../meshes\",\n):\n    \"\"\"\n    Generates a 3D fracture assembly with an Unstructured HEXAHEDRAL mesh.\n\n    Args:\n        length: Total length of the block (L)\n        height: Total height of the block (h)\n        thickness: Thickness of the block (t)\n        crack_tip_x: X-coordinate of the crack tip (a)\n        mesh_size_tip: Desired mesh size near the crack tip (refined)\n        mesh_size_far: Desired mesh size far from the crack tip (coarser)\n        work_dir: Directory to store temporary mesh files\n    Returns:\n        mesh: The full 3D mesh of the half-block (Mesh object)\n        interface_mesh: The mesh representing the crack interface (Mesh object)\n        top_interface_nodes: Node indices on the top face of the interface\n        bottom_interface_nodes: Node indices on the bottom face of the interface\n        active_quads_top: Quad element indices on the top face of the interface\n        active_quads_bottom: Quad element indices on the bottom face of the interface\n    \"\"\"\n\n    if not os.path.exists(work_dir):\n        os.makedirs(work_dir)\n\n    filename = os.path.join(work_dir, \"temp_half_block_hex.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"half_block_hex\")\n\n    h_half = height / 2.0\n\n    # Points: Bottom Face (y=0)\n    p1 = gmsh.model.geo.addPoint(0, 0, 0, mesh_size_far)\n    p4 = gmsh.model.geo.addPoint(0, 0, thickness, mesh_size_far)\n    # x=crack_tip (Refined)\n    pt1 = gmsh.model.geo.addPoint(crack_tip_x, 0, 0, mesh_size_tip)\n    pt2 = gmsh.model.geo.addPoint(crack_tip_x, 0, thickness, mesh_size_tip)\n    # x=L\n    p2 = gmsh.model.geo.addPoint(length, 0, 0, mesh_size_tip)\n    p3 = gmsh.model.geo.addPoint(length, 0, thickness, mesh_size_tip)\n\n    # Points: Top Face (y=h/2)\n    p5 = gmsh.model.geo.addPoint(0, h_half, 0, mesh_size_far)\n    p8 = gmsh.model.geo.addPoint(0, h_half, thickness, mesh_size_far)\n    # x=crack_tip (Refined)\n    pt3 = gmsh.model.geo.addPoint(crack_tip_x, h_half, 0, mesh_size_far)\n    pt4 = gmsh.model.geo.addPoint(crack_tip_x, h_half, thickness, mesh_size_far)\n    # x=L\n    p6 = gmsh.model.geo.addPoint(length, h_half, 0, mesh_size_far)\n    p7 = gmsh.model.geo.addPoint(length, h_half, thickness, mesh_size_far)\n\n    # Lines: Bottom\n    l1 = gmsh.model.geo.addLine(p1, pt1)\n    l2 = gmsh.model.geo.addLine(pt1, p2)\n    l_right_b = gmsh.model.geo.addLine(p2, p3)\n    l3 = gmsh.model.geo.addLine(p3, pt2)\n    l4 = gmsh.model.geo.addLine(pt2, p4)\n    l_left_b = gmsh.model.geo.addLine(p4, p1)\n    l_crack_b = gmsh.model.geo.addLine(pt1, pt2) # Crack front\n\n    # Lines: Top\n    l5 = gmsh.model.geo.addLine(p5, pt3)\n    l6 = gmsh.model.geo.addLine(pt3, p6)\n    l_right_t = gmsh.model.geo.addLine(p6, p7)\n    l7 = gmsh.model.geo.addLine(p7, pt4)\n    l8 = gmsh.model.geo.addLine(pt4, p8)\n    l_left_t = gmsh.model.geo.addLine(p8, p5)\n    l_crack_t = gmsh.model.geo.addLine(pt3, pt4)\n\n    # Lines: Vertical\n    v1 = gmsh.model.geo.addLine(p1, p5)\n    v_tip1 = gmsh.model.geo.addLine(pt1, pt3)\n    v2 = gmsh.model.geo.addLine(p2, p6)\n    v3 = gmsh.model.geo.addLine(p3, p7)\n    v_tip2 = gmsh.model.geo.addLine(pt2, pt4)\n    v4 = gmsh.model.geo.addLine(p4, p8)\n\n    # Surfaces (Pre/Post Crack Split)\n    loop_if_1 = gmsh.model.geo.addCurveLoop([l1, l_crack_b, l4, l_left_b])\n    s_if_1 = gmsh.model.geo.addPlaneSurface([loop_if_1])\n\n    loop_if_2 = gmsh.model.geo.addCurveLoop([l2, l_right_b, l3, -l_crack_b])\n    s_if_2 = gmsh.model.geo.addPlaneSurface([loop_if_2])\n\n    loop_top_1 = gmsh.model.geo.addCurveLoop([l5, l_crack_t, l8, l_left_t])\n    s_top_1 = gmsh.model.geo.addPlaneSurface([loop_top_1])\n\n    loop_top_2 = gmsh.model.geo.addCurveLoop([l6, l_right_t, l7, -l_crack_t])\n    s_top_2 = gmsh.model.geo.addPlaneSurface([loop_top_2])\n\n    # Sides\n    s_left = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l_left_b, v1, -l_left_t, -v4])])\n    s_right = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l_right_b, v3, -l_right_t, -v2])])\n    s_front_1 = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l1, v_tip1, -l5, -v1])])\n    s_front_2 = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l2, v2, -l6, -v_tip1])])\n    s_back_1 = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l4, v4, -l8, -v_tip2])])\n    s_back_2 = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l3, v_tip2, -l7, -v3])])\n    s_mid = gmsh.model.geo.addPlaneSurface([gmsh.model.geo.addCurveLoop([l_crack_b, v_tip2, -l_crack_t, -v_tip1])])\n\n    # Volumes\n    sl1 = gmsh.model.geo.addSurfaceLoop([s_if_1, s_top_1, s_left, s_front_1, s_back_1, s_mid])\n    vol1 = gmsh.model.geo.addVolume([sl1])\n    sl2 = gmsh.model.geo.addSurfaceLoop([s_if_2, s_top_2, s_right, s_front_2, s_back_2, s_mid])\n    vol2 = gmsh.model.geo.addVolume([sl2])\n\n    gmsh.model.geo.synchronize()\n\n    gmsh.model.addPhysicalGroup(2, [s_if_1, s_if_2], 1, name=\"interface_surface\")\n    gmsh.model.addPhysicalGroup(3, [vol1, vol2], 2, name=\"top_domain\")\n    gmsh.option.setNumber(\"Mesh.SubdivisionAlgorithm\", 2)\n\n    gmsh.model.mesh.generate(3)\n    gmsh.write(filename)\n    gmsh.finalize()\n\n    _m = meshio.read(filename)\n    if os.path.exists(filename):\n        os.remove(filename)\n\n    points_top = _m.points # (N, 3)\n\n    hex_top = _m.cells_dict[\"hexahedron\"]\n\n    interface_surf_idx = _m.cell_sets_dict[\"interface_surface\"][\"quad\"]\n    all_interface_quads_top = _m.cells_dict[\"quad\"][interface_surf_idx]\n\n    points_bottom = points_top.copy()\n    points_bottom[:, 1] *= -1 # Flip Y\n    points_bottom[:, 1] -= 1e-7\n\n    N_half = len(points_top)\n\n    hex_bottom = hex_top + N_half\n\n    hex_bottom[:, [1, 3]] = hex_bottom[:, [3, 1]]\n    hex_bottom[:, [5, 7]] = hex_bottom[:, [7, 5]]\n\n    coords = np.vstack([points_top, points_bottom])\n    elements = np.vstack([hex_top, hex_bottom])\n\n    quad_coords = points_top[all_interface_quads_top]\n    centroids_x = np.mean(quad_coords[:, :, 0], axis=1)\n\n    active_mask = centroids_x &gt;= (crack_tip_x - 1e-9)\n\n    active_quads_top = all_interface_quads_top[active_mask]\n    active_quads_bottom = active_quads_top + N_half\n\n    unique_nodes_bot, inverse_indices = jnp.unique(active_quads_bottom, return_inverse=True)\n\n    interface_coords = coords[unique_nodes_bot]\n    interface_connectivity = inverse_indices.reshape(active_quads_bottom.shape)\n\n    interface_mesh = Mesh(interface_coords, interface_connectivity)\n\n    bottom_interface_nodes = unique_nodes_bot\n    top_interface_nodes = bottom_interface_nodes - N_half\n    mesh = Mesh(coords, elements)\n\n    return mesh, interface_mesh, top_interface_nodes, bottom_interface_nodes, active_quads_top, active_quads_bottom\n</code></pre> <p>Now, we define the material parameters and geometic parameters.</p> <pre><code>prestrain = 0.1\nnu = 0.35\n\nE = 106e3  # N/m^2\nlmbda = nu * E / ((1 + nu) * (1 - 2 * nu))\nmu = E / (2 * (1 + nu))\n\nGamma = 15  # J/m^2\nsigma_c = 20e3  # N/m^2\n\nprint(f\"mu: {mu} N/m^2\")\nprint(f\"lmbda: {lmbda} N/m^2\")\n\nsigma_inf = prestrain * E\n\nL_G = 2 * mu * Gamma / (jnp.pi * (1 - nu) * sigma_inf**2)\nprint(f\"L_G: {L_G} m\")\n</code></pre> <pre><code>mu: 39259.259259259255 N/m^2\nlmbda: 91604.93827160491 N/m^2\nL_G: 0.0051332024864342955 m\n</code></pre> <pre><code>Lx = 10 * L_G\nLy = 2 * L_G\nLz = 1 * L_G\n\n(\n    mesh,\n    interface_mesh,\n    top_interface_nodes,\n    bottom_interface_nodes,\n    top_interface_elements,\n    bottom_interface_elements,\n) = generate_unstructured_hex_fracture_3d(\n    length=Lx,\n    height=Ly,\n    thickness=Lz,\n    crack_tip_x=crack_length,\n    mesh_size_tip=2e-3,\n    mesh_size_far=4e-3,\n)\n\n\nn_nodes = mesh.coords.shape[0]\nn_dofs_per_node = 3\nn_dofs = n_dofs_per_node * n_nodes\n</code></pre> Output <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Line)\nInfo    : [ 10%] Meshing curve 2 (Line)\nInfo    : [ 20%] Meshing curve 3 (Line)\nInfo    : [ 20%] Meshing curve 4 (Line)\nInfo    : [ 30%] Meshing curve 5 (Line)\nInfo    : [ 30%] Meshing curve 6 (Line)\nInfo    : [ 40%] Meshing curve 7 (Line)\nInfo    : [ 40%] Meshing curve 8 (Line)\nInfo    : [ 50%] Meshing curve 9 (Line)\nInfo    : [ 50%] Meshing curve 10 (Line)\nInfo    : [ 60%] Meshing curve 11 (Line)\nInfo    : [ 60%] Meshing curve 12 (Line)\nInfo    : [ 70%] Meshing curve 13 (Line)\nInfo    : [ 70%] Meshing curve 14 (Line)\nInfo    : [ 80%] Meshing curve 15 (Line)\nInfo    : [ 80%] Meshing curve 16 (Line)\nInfo    : [ 90%] Meshing curve 17 (Line)\nInfo    : [ 90%] Meshing curve 18 (Line)\nInfo    : [100%] Meshing curve 19 (Line)\nInfo    : [100%] Meshing curve 20 (Line)\nInfo    : Done meshing 1D (Wall 0.00359308s, CPU 0.004157s)\nInfo    : Meshing 2D...\nInfo    : [  0%] Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 2 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 3 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 4 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 5 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 6 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 7 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 8 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 9 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 10 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 11 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.00530414s, CPU 0.004784s)\nInfo    : Meshing 3D...\nInfo    : 3D Meshing 2 volumes with 1 connected component\nInfo    : Tetrahedrizing 249 nodes...\nInfo    : Done tetrahedrizing 257 nodes (Wall 0.00191356s, CPU 0.002098s)\nInfo    : Reconstructing mesh...\nInfo    :  - Creating surface mesh\nInfo    :  - Identifying boundary edges\nInfo    :  - Recovering boundary\nInfo    : Done reconstructing mesh (Wall 0.00425647s, CPU 0.00351s)\nInfo    : Found volume 1\nInfo    : Found volume 2\nInfo    : It. 0 - 0 nodes created - worst tet radius 1.19778 (nodes removed 0 0)\nInfo    : 3D refinement terminated (255 nodes total):\nInfo    :  - 0 Delaunay cavities modified for star shapeness\nInfo    :  - 0 nodes could not be inserted\nInfo    :  - 680 tetrahedra created in 0.000347617 sec. (1956175 tets/s)\nInfo    : 0 node relocations\nInfo    : Done meshing 3D (Wall 0.00848098s, CPU 0.007885s)\nInfo    : Optimizing mesh...\nInfo    : Optimizing volume 1\nInfo    : Optimization starts (volume = 2.43466e-07) with worst = 0.0504542 / average = 0.777641:\nInfo    : 0.00 &lt; quality &lt; 0.10 :         2 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         0 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :         2 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :         0 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :         3 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :         1 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :        29 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :        43 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :        52 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :        30 elements\nInfo    : 4 edge swaps, 0 node relocations (volume = 2.43466e-07): worst = 0.479486 / average = 0.794093 (Wall 6.8234e-05s, CPU 9.5e-05s)\nInfo    : No ill-shaped tets in the mesh :-)\nInfo    : 0.00 &lt; quality &lt; 0.10 :         0 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         0 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :         0 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :         0 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :         3 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :         1 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :        31 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :        41 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :        50 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :        32 elements\nInfo    : Optimizing volume 2\nInfo    : Optimization starts (volume = 1.10912e-06) with worst = 0.0625991 / average = 0.673012:\nInfo    : 0.00 &lt; quality &lt; 0.10 :        10 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         7 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :        12 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :        16 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :        45 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :        49 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :       148 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :        85 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :        76 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :        70 elements\nInfo    : 27 edge swaps, 0 node relocations (volume = 1.10912e-06): worst = 0.309952 / average = 0.698742 (Wall 0.000326186s, CPU 0.000311s)\nInfo    : No ill-shaped tets in the mesh :-)\nInfo    : 0.00 &lt; quality &lt; 0.10 :         0 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         0 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :         0 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :        23 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :        48 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :        50 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :       139 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :        90 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :        77 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :        70 elements\nInfo    : Done optimizing mesh (Wall 0.000840244s, CPU 0.000912s)\nInfo    : Refining mesh...\nInfo    : Meshing order 2 (curvilinear on)...\nInfo    : [  0%] Meshing curve 1 order 2\nInfo    : [ 10%] Meshing curve 2 order 2\nInfo    : [ 10%] Meshing curve 3 order 2\nInfo    : [ 10%] Meshing curve 4 order 2\nInfo    : [ 20%] Meshing curve 5 order 2\nInfo    : [ 20%] Meshing curve 6 order 2\nInfo    : [ 20%] Meshing curve 7 order 2\nInfo    : [ 30%] Meshing curve 8 order 2\nInfo    : [ 30%] Meshing curve 9 order 2\nInfo    : [ 30%] Meshing curve 10 order 2\nInfo    : [ 40%] Meshing curve 11 order 2\nInfo    : [ 40%] Meshing curve 12 order 2\nInfo    : [ 40%] Meshing curve 13 order 2\nInfo    : [ 40%] Meshing curve 14 order 2\nInfo    : [ 50%] Meshing curve 15 order 2\nInfo    : [ 50%] Meshing curve 16 order 2\nInfo    : [ 50%] Meshing curve 17 order 2\nInfo    : [ 60%] Meshing curve 18 order 2\nInfo    : [ 60%] Meshing curve 19 order 2\nInfo    : [ 60%] Meshing curve 20 order 2\nInfo    : [ 70%] Meshing surface 1 order 2\nInfo    : [ 70%] Meshing surface 2 order 2\nInfo    : [ 70%] Meshing surface 3 order 2\nInfo    : [ 70%] Meshing surface 4 order 2\nInfo    : [ 80%] Meshing surface 5 order 2\nInfo    : [ 80%] Meshing surface 6 order 2\nInfo    : [ 80%] Meshing surface 7 order 2\nInfo    : [ 90%] Meshing surface 8 order 2\nInfo    : [ 90%] Meshing surface 9 order 2\nInfo    : [ 90%] Meshing surface 10 order 2\nInfo    : [100%] Meshing surface 11 order 2\nInfo    : [100%] Meshing volume 1 order 2\nInfo    : [100%] Meshing volume 2 order 2\nInfo    : Surface mesh: worst distortion = 1 (0 elements in ]0, 0.2]); worst gamma = 0.702659\nInfo    : Volume mesh: worst distortion = 1 (0 elements in ]0, 0.2])\nInfo    : Done meshing order 2 (Wall 0.00286796s, CPU 0.0023s)\nInfo    : Done refining mesh (Wall 0.00733381s, CPU 0.006798s)\nInfo    : 3613 nodes 4347 elements\nInfo    : Writing '../meshes/temp_half_block_hex.msh'...\nInfo    : Done writing '../meshes/temp_half_block_hex.msh'\n</code></pre> <pre><code>grid = pv.UnstructuredGrid(\n    np.hstack((np.full((mesh.elements.shape[0], 1), 8), mesh.elements)).flatten(),\n    np.full(mesh.elements.shape[0], pv.CellType.HEXAHEDRON),\n    np.array(mesh.coords)\n)\n\ngrid_interface = pv.UnstructuredGrid(\n    np.hstack((np.full((interface_mesh.elements.shape[0], 1), 4), interface_mesh.elements)).flatten(),\n    np.full(interface_mesh.elements.shape[0], pv.CellType.QUAD),\n    np.array(interface_mesh.coords)\n)\n\npl = pv.Plotter(window_size=(800, 400))\npl.add_mesh(grid, show_edges=True, color=\"lightgray\",  smooth_shading=False, opacity=1)\npl.add_mesh(grid_interface, show_edges=True, color=\"red\",  smooth_shading=False)\npl.view_isometric()\npl.show()\n</code></pre> <p></p> <p>Click the image above to mesh in full screen.</p> <p>We can now create the mesh and <code>tatva.Operator</code> to integrate the energy. We define the Element 8-node <code>Hexahedron</code>. One can implement any new H\\(^1\\) finite-element.</p> Define the 8-node hexahedral element <pre><code>class Hexahedron8(element.Element):\n    \"\"\"A 8-node linear hexahedral element.\"\"\"\n\n    a = 1 / jnp.sqrt(3)\n\n    # 2x2x2 Gauss Quadrature Rule\n    quad_points = jnp.array(\n        [\n            [-a, -a, -a],\n            [a, -a, -a],\n            [a, a, -a],\n            [-a, a, -a],\n            [-a, -a, a],\n            [a, -a, a],\n            [a, a, a],\n            [-a, a, a],\n        ]\n    )\n\n    # Weights are all 1.0 for this rule (since interval is [-1, 1])\n    quad_weights = jnp.ones(8)\n\n    def shape_function(self, xi: Array) -&gt; Array:\n        \"\"\"Returns the shape functions evaluated at the local coordinates (xi, eta, zeta).\"\"\"\n        xi, eta, zeta = xi\n        return (1 / 8) * jnp.array(\n            [\n                (1 - xi) * (1 - eta) * (1 - zeta),\n                (1 + xi) * (1 - eta) * (1 - zeta),\n                (1 + xi) * (1 + eta) * (1 - zeta),\n                (1 - xi) * (1 + eta) * (1 - zeta),\n                (1 - xi) * (1 - eta) * (1 + zeta),\n                (1 + xi) * (1 - eta) * (1 + zeta),\n                (1 + xi) * (1 + eta) * (1 + zeta),\n                (1 - xi) * (1 + eta) * (1 + zeta),\n            ]\n        )\n\n    def shape_function_derivative(self, xi: Array) -&gt; Array:\n        \"\"\"Returns the derivative of the shape functions.\"\"\"\n        # shape (3, 8) -&gt; (dim, n_nodes)\n        xi, eta, zeta = xi\n        return (1 / 8) * jnp.array(\n            [\n                [\n                    -(1 - eta) * (1 - zeta),\n                    (1 - eta) * (1 - zeta),\n                    (1 + eta) * (1 - zeta),\n                    -(1 + eta) * (1 - zeta),\n                    -(1 - eta) * (1 + zeta),\n                    (1 - eta) * (1 + zeta),\n                    (1 + eta) * (1 + zeta),\n                    -(1 + eta) * (1 + zeta),\n                ],\n                [\n                    -(1 - xi) * (1 - zeta),\n                    -(1 + xi) * (1 - zeta),\n                    (1 + xi) * (1 - zeta),\n                    (1 - xi) * (1 - zeta),\n                    -(1 - xi) * (1 + zeta),\n                    -(1 + xi) * (1 + zeta),\n                    (1 + xi) * (1 + zeta),\n                    (1 - xi) * (1 + zeta),\n                ],\n                [\n                    -(1 - xi) * (1 - eta),\n                    -(1 + xi) * (1 - eta),\n                    -(1 + xi) * (1 + eta),\n                    -(1 - xi) * (1 + eta),\n                    (1 - xi) * (1 - eta),\n                    (1 + xi) * (1 - eta),\n                    (1 + xi) * (1 + eta),\n                    (1 - xi) * (1 + eta),\n                ],\n            ]\n        )\n</code></pre> <pre><code>hex = Hexahedron8()\nop = Operator(mesh, hex)\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/#defining-the-total-potential-energy","title":"Defining the total potential energy","text":""},{"location":"examples/fracture_quasistatic_3d/#defining-elastic-strain-energy","title":"Defining elastic strain energy","text":"<p>We define a function to compute the linear elastic energy density based on the displacement gradients \\(\\nabla u\\).</p> \\[ \\Psi(x) =  \\sigma(x) : \\epsilon(x) \\] <p>where \\(\\sigma\\) is the stress tensor and \\(\\epsilon\\) is the strain tensor.</p> \\[ \\sigma = \\lambda \\text{tr}(\\epsilon) I + 2\\mu \\epsilon \\] <p>and</p> \\[ \\epsilon = \\frac{1}{2} (\\nabla u + \\nabla u^T) \\] <p>The elastic strain energy density is then given by:</p> \\[ \\Psi_{elastic}(u) = \\int_{\\Omega} \\Psi(x) dV \\] <pre><code>@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    I = jnp.eye(3)\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * I\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n\n\n@jax.jit\ndef total_strain_energy(u_flat):\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_grad = op.grad(u)\n    energy_density = strain_energy(u_grad, mu, lmbda)\n    return op.integrate(energy_density)\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/#defining-total-fracture-energy","title":"Defining total fracture energy","text":"<p>The total potential energy \\(\\Psi\\) is the sum of the elastic strain energy \\(\\Psi_{elastic}\\) and the cohesive energy \\(\\Psi_{cohesive}\\).</p> \\[\\Psi(u)=\\Psi_{elastic}(u)+\\Psi_{cohesive}(u)\\] <p>The cohesive energy is defined as:</p> \\[\\Psi_{cohesive}(u)= \\int_{\\Gamma_\\text{coh}} \\psi(\\delta(\\boldsymbol{u})) dA\\] <p>where</p> <ul> <li>\\(\\Gamma_{coh}\\) is the cohesive interface.</li> <li>\\(\\boldsymbol{\\delta}(\\boldsymbol{u}) = \\boldsymbol{u}^+ - \\boldsymbol{u}^-\\) is the displacement jump across the interface.</li> <li>\\(\\phi(\\boldsymbol{\\delta})\\) is the cohesive potential, which defines the energy-separation relationship.</li> </ul>"},{"location":"examples/fracture_quasistatic_3d/#defining-the-effective-opening","title":"Defining the effective opening","text":"<p>Now, we proceed with defining the cohesive potential in terms of the jump displacement</p> \\[ [\\![ \\boldsymbol{u} ]\\!] = \\boldsymbol{u}_1 - \\boldsymbol{u}_2 \\] <p>where \\(\\boldsymbol{u}_1\\) and \\(\\boldsymbol{u}_2\\) are the displacements of the nodes of the upper and lower interface respectively. The effective opening is then given as:</p> \\[ \\delta = \\sqrt{[\\![ u ]\\!]_t^2 + [\\![ u_ ]\\!]_n^2} \\] <p>where \\([\\![ u ]\\!]_t\\) and \\([\\![ u ]\\!]_n\\) are the tangential and normal components of the jump displacement with respect to the fracture plane or the interface. Since the fracture plane or the interface is parallel to the \\(x\\) axis and we assume that it remains so throughout the simulation, we can then write:</p> \\[ [\\![ u ]\\!]_t = [\\![ \\boldsymbol{u} ]\\!]\\cdot{}\\boldsymbol{e}_x \\] <p>and</p> \\[ [\\![ u ]\\!]_n = [\\![ \\boldsymbol{u} ]\\!]\\cdot{}\\boldsymbol{e}_y \\] <p>where \\(\\boldsymbol{e}_x\\) and \\(\\boldsymbol{e}_y\\) are the unit vectors in the \\(x\\) and \\(y\\) directions respectively.</p>"},{"location":"examples/fracture_quasistatic_3d/#defining-the-traction-separation-law","title":"Defining the traction-separation law","text":"<p>For this example, we assume that the cohesive potential is given by the exponential cohesive potential.</p> \\[ \\phi = \\Gamma \\left(-\\frac{\\delta}{\\delta_c} \\exp\\left(-\\frac{\\delta}{\\delta_c}\\right)\\right) \\] <p>where \\(\\Gamma\\) is the fracture energy and \\(\\delta_c\\) is the critical opening. The critical opening for the exponential cohesive potential is given by:</p> \\[ \\delta_c = \\frac{\\Gamma \\exp(-1)}{\\sigma_c} \\] <p>It is the opening at which the cohesive traction is equal to the critical stress.</p> <pre><code>penalty = 1e2\nnormal_vector = jnp.array([0.0, 1.0, 0.0])  # Y-direction\nbeta = 0.0  # No tangential contribution\n\n@jax.jit\ndef safe_sqrt(x):\n    return jnp.sqrt(jnp.where(x &gt; 0.0, x, 0.0))\n\n\n\n@autovmap(jump=1)\ndef compute_opening(jump: Array) -&gt; float:\n    \"\"\"\n    Compute the opening of the cohesive element.\n    Args:\n        jump: The jump in the displacement field.\n    Returns:\n        The opening of the cohesive element.\n    \"\"\"\n    delta_n = jnp.dot(jump, normal_vector)\n    delta_t_vec = jump - delta_n * normal_vector\n    delta_t = safe_sqrt(jnp.dot(delta_t_vec, delta_t_vec))\n    opening = safe_sqrt(delta_n ** 2 + beta * delta_t ** 2)\n    return opening\n\n\n\ndef exponential_potential(delta, Gamma, delta_c):\n    return Gamma * (1 - (1 + (delta / delta_c)) * (jnp.exp(-delta / delta_c)))\n\n\nexponential_traction = jax.jacrev(exponential_potential)\n\n\n@autovmap(jump=1, delta_max=0)\ndef exponential_cohesive_energy(\n    jump: Array,\n    delta_max: float,\n    Gamma: float,\n    sigma_c: float,\n    penalty: float,\n    delta_threshold: float = 1e-8,\n) -&gt; float:\n    \"\"\"\n    Compute the cohesive energy for a given jump.\n    Args:\n        jump: The jump in the displacement field.\n        Gamma: Fracture energy of the material.\n        sigma_c: The critical strength of the material.\n        penalty: The penalty parameter for penalizing the interpenetration.\n        delta_threshold: The threshold for the delta parameter.\n    Returns:\n        The cohesive energy.\n    \"\"\"\n    delta = compute_opening(jump)\n    delta_c = (Gamma * jnp.exp(-1)) / sigma_c\n\n    def true_fun(delta):\n        def loading(delta):\n            return exponential_potential(delta, Gamma, delta_c)\n\n        def unloading(delta):\n            psi_max = exponential_potential(delta_max, Gamma, delta_c)\n            T_max = exponential_traction(delta_max, Gamma, delta_c)\n            T_current = T_max * (delta) / delta_max\n            psi_current = psi_max - 0.5 * (T_max + T_current) * (delta_max - delta)\n            return psi_current\n\n        return jax.lax.cond(delta &gt; delta_max, loading, unloading, delta)\n\n    def false_fun(delta):\n        return 0.5 * penalty * delta**2\n\n    return jax.lax.cond(delta &gt; delta_threshold, true_fun, false_fun, delta)\n</code></pre> <p>To ease the integration along the cohesive interface, we will define a new mesh that contains the Quadrilateral elements from one of the two interfaces. Since the two interfaces are discretized using the same number of elements, and occupy the same spatial domain, we can use any one of the two to perform the integration.</p> Define the 4-node quadrilateral element on the interface <pre><code>class Quad4Manifold(element.Quad4):\n    \"\"\"A 4-node linear quadrilateral element on a 2D manifold embedded in 3D space.\"\"\"\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -&gt; tuple[Array, Array]:\n        dNdr = self.shape_function_derivative(xi)\n        J = dNdr @ nodal_coords  # shape (2, 2) or (2, 3)\n        G = J @ J.T  # shape (2, 2)\n        detJ = safe_sqrt(jnp.linalg.det(G))\n        return J, detJ\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array:\n        dNdr = self.shape_function_derivative(xi)  # shape (2, 3)\n        J, _ = self.get_jacobian(xi, nodal_coords)  # shape (2, 3)\n\n        G_inv = jnp.linalg.inv(J @ J.T)  # shape (2, 2)\n        J_plus = J.T @ G_inv  # shape (3, 2)\n\n        dudxi = dNdr @ nodal_values  # shape (2, n_values)\n        return J_plus @ dudxi  # shape (3, n_values)\n</code></pre> <pre><code>quad4 = Quad4Manifold()\ninterface_op = Operator(interface_mesh, quad4)\n</code></pre> <p>Now we can use the <code>interface_op</code> to compute the total cohesive energy along the interface.</p> <pre><code>@jax.jit\ndef total_cohesive_energy(u_flat: Array, delta_max: Array) -&gt; float:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    jump = u.at[top_interface_nodes, :].get() - u.at[bottom_interface_nodes, :].get()\n    jump_quad = interface_op.eval(jump)\n    cohesive_energy_density = exponential_cohesive_energy(\n        jump_quad, delta_max, Gamma, sigma_c, penalty\n    )\n    return interface_op.integrate(cohesive_energy_density)\n</code></pre> <pre><code>@jax.jit\ndef total_energy(u_flat: Array, delta_max: Array) -&gt; float:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    elastic_strain_energy = total_strain_energy(u)\n    cohesive_energy = total_cohesive_energy(u, delta_max)\n    return elastic_strain_energy + cohesive_energy\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/#boundary-and-loading-condition","title":"Boundary and Loading condition","text":"<p>We now apply boundary and loading conditions</p> <pre><code>z_max = jnp.max(mesh.coords[:, 2])\nz_min = jnp.min(mesh.coords[:, 2])\ny_max = jnp.max(mesh.coords[:, 1])\ny_min = jnp.min(mesh.coords[:, 1])\nx_min = jnp.min(mesh.coords[:, 0])\nheight = y_max - y_min\n\n\nupper_nodes = jnp.where(jnp.isclose(mesh.coords[:, 1], y_max))[0]\nlower_nodes = jnp.where(jnp.isclose(mesh.coords[:, 1], y_min))[0]\nleft_nodes = jnp.where(jnp.isclose(mesh.coords[:, 0], x_min))[0]\nfront_nodes = jnp.where(jnp.isclose(mesh.coords[:, 2], z_min))[0]\nback_nodes = jnp.where(jnp.isclose(mesh.coords[:, 2], z_max))[0]\n\napplied_disp = 2.25 * prestrain * height\n\nfixed_dofs = jnp.concatenate(\n    [\n        n_dofs_per_node * upper_nodes,\n        n_dofs_per_node * upper_nodes + 1,\n        n_dofs_per_node * upper_nodes + 2,\n\n        n_dofs_per_node * lower_nodes,\n        n_dofs_per_node * lower_nodes + 1,\n        n_dofs_per_node * lower_nodes + 2,\n\n        n_dofs_per_node * left_nodes,\n        n_dofs_per_node * front_nodes + 2,\n        n_dofs_per_node * back_nodes + 2,\n    ]\n)\n\n\n\nprescribed_values = jnp.zeros(n_dofs).at[n_dofs_per_node * upper_nodes].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * upper_nodes + 1].set(applied_disp / 2.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * upper_nodes + 2].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * lower_nodes].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * lower_nodes + 1].set(-applied_disp / 2.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * lower_nodes + 2].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * left_nodes].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * front_nodes + 2].set(0.0)\nprescribed_values = prescribed_values.at[n_dofs_per_node * back_nodes + 2].set(0.0)\n\n\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/#using-matrix-free-solvers","title":"Using Matrix-free solvers","text":"<p>In this example, we use matrix-free solver. To enforce boundary conditions, we use Projected Conjugate Gradient </p> <pre><code># creating functions to compute the gradient and\ngradient = jax.jacrev(total_energy)\n\n\n# create a function to compute the JVP product\n@eqx.filter_jit\ndef compute_tangent(du, u_prev, gradient):\n    du_projected = du.at[fixed_dofs].set(0)\n    tangent = jax.jvp(gradient, (u_prev,), (du_projected,))[1]\n    tangent = tangent.at[fixed_dofs].set(0)\n    return tangent\n</code></pre> Define the Netwon-Krylov solvers (Newton and Conjugate Gradient) <pre><code>from functools import partial\n\n\n@eqx.filter_jit\ndef conjugate_gradient(A, b, atol=1e-8, max_iter=100):\n    iiter = 0\n\n    def body_fun(state):\n        b, p, r, rsold, x, iiter = state\n        Ap = A(p)\n        alpha = rsold / jnp.vdot(p, Ap)\n        x = x + jnp.dot(alpha, p)\n        r = r - jnp.dot(alpha, Ap)\n        rsnew = jnp.vdot(r, r)\n        p = r + (rsnew / rsold) * p\n        rsold = rsnew\n        iiter = iiter + 1\n        return (b, p, r, rsold, x, iiter)\n\n    def cond_fun(state):\n        b, p, r, rsold, x, iiter = state\n        return jnp.logical_and(jnp.sqrt(rsold) &gt; atol, iiter &lt; max_iter)\n\n    x = jnp.full_like(b, fill_value=0.0)\n    r = b - A(x)\n    p = r\n    rsold = jnp.vdot(r, p)\n\n    b, p, r, rsold, x, iiter = jax.lax.while_loop(\n        cond_fun, body_fun, (b, p, r, rsold, x, iiter)\n    )\n    return x, iiter\n\n\n\n@eqx.filter_jit\ndef newton_krylov_solver(\n    u_init,\n    fext,\n    gradient,\n    compute_tangent,\n    fixed_dofs,\n):\n    fint_init = gradient(u_init)\n    res_init = (fext - fint_init).at[fixed_dofs].set(0)\n    norm_res_init = jnp.linalg.norm(res_init)\n\n    init_val = (u_init, 0, norm_res_init, fint_init)\n\n    def cond_fun(state):\n        u, iiter, norm_res, _ = state\n        return (norm_res &gt; 1e-8) &amp; (iiter &lt; 200)\n\n    def body_fun(state):\n        u, iiter, norm_res, fint = state\n\n        residual = (fext - fint).at[fixed_dofs].set(0)        \n        A = eqx.Partial(compute_tangent, u_prev=u, gradient=gradient)\n\n        du, _ = conjugate_gradient(A=A, b=residual, atol=1e-8, max_iter=100)\n\n        u_next = u + du\n\n        fint_next = gradient(u_next)\n        residual_next = (fext - fint_next).at[fixed_dofs].set(0)\n        norm_res_next = jnp.linalg.norm(residual_next)\n\n        return (u_next, iiter + 1, norm_res_next, fint_next)\n\n    final_u, final_iiter, final_norm, _ = jax.lax.while_loop(cond_fun, body_fun, init_val)\n    jax.debug.print(\"  Residual: {res:.2e}\", res=final_norm)\n\n    return final_u, final_norm\n</code></pre> <p>We define the initial conditions.</p> <pre><code>u_prev = jnp.zeros(n_dofs)\nfext = jnp.zeros(n_dofs)\n\njump = (\n    u_prev.reshape(-1, n_dofs_per_node).at[top_interface_nodes, :].get()\n    - u_prev.reshape(-1, n_dofs_per_node).at[bottom_interface_nodes, :].get()\n)\njump_quad = interface_op.eval(jump)\ndelta_maxs_prev = compute_opening(jump_quad)\n</code></pre> <p>We divided the total loading into <code>300</code> steps. </p> <pre><code>force_on_top = []\ndisplacement_on_top = []\nu_per_step = []\n\nenergies = {}\nenergies[\"elastic\"] = []\nenergies[\"cohesive\"] = []\n\ndelta_maxs_per_step = []\n\nforce_on_top.append(0)\ndisplacement_on_top.append(0)\nu_per_step.append(u_prev.reshape(n_nodes, n_dofs_per_node))\nenergies[\"elastic\"].append(\n    total_strain_energy(u_prev.reshape(n_nodes, n_dofs_per_node))\n)\nenergies[\"cohesive\"].append(\n    total_cohesive_energy(u_prev.reshape(n_nodes, n_dofs_per_node), delta_maxs_prev)\n)\n\ndu_total = prescribed_values / n_steps  # displacement increment\n\nerror_per_step = []\n\nfor step in range(n_steps):\n    print(f\"Step {step + 1}/{n_steps}\")\n    if step &lt; n_steps:\n        u_prev = u_prev.at[fixed_dofs].add(du_total[fixed_dofs])\n\n    gradient_partial = eqx.Partial(gradient, delta_max=delta_maxs_prev)\n\n    u_new, rnorm = newton_krylov_solver(\n        u_prev,\n        fext,\n        gradient_partial,\n        compute_tangent,\n        fixed_dofs,\n    )\n\n    u_prev = u_new\n\n    force_on_top.append(jnp.sum(gradient(u_prev, delta_maxs_prev)[n_dofs_per_node * upper_nodes + 1]))\n    displacement_on_top.append(jnp.mean(u_prev[n_dofs_per_node * upper_nodes + 1]))\n    u_per_step.append(u_prev.reshape(n_nodes, n_dofs_per_node))\n    energies[\"elastic\"].append(\n        total_strain_energy(u_prev.reshape(n_nodes, n_dofs_per_node))\n    )\n    energies[\"cohesive\"].append(\n        total_cohesive_energy(u_prev.reshape(n_nodes, n_dofs_per_node), delta_maxs_prev)\n    )\n    error_per_step.append(rnorm)\n\n    jump = (\n            u_per_step[step].at[top_interface_nodes, :].get()\n            - u_per_step[step].at[bottom_interface_nodes, :].get()\n    )\n    jump_quad = interface_op.eval(jump).squeeze()\n    openings = compute_opening(jump_quad)\n    delta_maxs = jnp.maximum(delta_maxs_prev, openings)\n    delta_maxs_per_step.append(delta_maxs)\n\nu_solution = u_prev.reshape(n_nodes, n_dofs_per_node)\n</code></pre> Output <pre><code>Step 1/300\n  Residual: 9.78e-09\nStep 2/300\n  Residual: 9.59e-09\nStep 3/300\n  Residual: 9.91e-09\nStep 4/300\n  Residual: 9.74e-09\nStep 5/300\n  Residual: 9.75e-09\nStep 6/300\n  Residual: 9.91e-09\nStep 7/300\n  Residual: 9.90e-09\nStep 8/300\n  Residual: 9.91e-09\nStep 9/300\n  Residual: 9.81e-09\nStep 10/300\n  Residual: 9.56e-09\nStep 11/300\n  Residual: 9.94e-09\nStep 12/300\n  Residual: 9.29e-09\nStep 13/300\n  Residual: 9.83e-09\nStep 14/300\n  Residual: 9.66e-09\nStep 15/300\n  Residual: 9.11e-09\nStep 16/300\n  Residual: 9.65e-09\nStep 17/300\n  Residual: 9.57e-09\nStep 18/300\n  Residual: 9.71e-09\nStep 19/300\n  Residual: 9.98e-09\nStep 20/300\n  Residual: 9.70e-09\nStep 21/300\n  Residual: 9.34e-09\nStep 22/300\n  Residual: 9.60e-09\nStep 23/300\n  Residual: 9.83e-09\nStep 24/300\n  Residual: 9.82e-09\nStep 25/300\n  Residual: 9.53e-09\nStep 26/300\n  Residual: 9.92e-09\nStep 27/300\n  Residual: 9.90e-09\nStep 28/300\n  Residual: 9.95e-09\nStep 29/300\n  Residual: 9.34e-09\nStep 30/300\n  Residual: 9.46e-09\nStep 31/300\n  Residual: 9.24e-09\nStep 32/300\n  Residual: 9.67e-09\nStep 33/300\n  Residual: 9.53e-09\nStep 34/300\n  Residual: 9.81e-09\nStep 35/300\n  Residual: 9.61e-09\nStep 36/300\n  Residual: 9.48e-09\nStep 37/300\n  Residual: 9.97e-09\nStep 38/300\n  Residual: 9.09e-09\nStep 39/300\n  Residual: 9.64e-09\nStep 40/300\n  Residual: 9.93e-09\nStep 41/300\n  Residual: 9.84e-09\nStep 42/300\n  Residual: 9.81e-09\nStep 43/300\n  Residual: 9.43e-09\nStep 44/300\n  Residual: 9.78e-09\nStep 45/300\n  Residual: 9.64e-09\nStep 46/300\n  Residual: 9.82e-09\nStep 47/300\n  Residual: 9.87e-09\nStep 48/300\n  Residual: 9.77e-09\nStep 49/300\n  Residual: 9.76e-09\nStep 50/300\n  Residual: 9.72e-09\nStep 51/300\n  Residual: 9.03e-09\nStep 52/300\n  Residual: 9.70e-09\nStep 53/300\n  Residual: 9.58e-09\nStep 54/300\n  Residual: 9.44e-09\nStep 55/300\n  Residual: 9.97e-09\nStep 56/300\n  Residual: 9.84e-09\nStep 57/300\n  Residual: 9.99e-09\nStep 58/300\n  Residual: 9.74e-09\nStep 59/300\n  Residual: 9.60e-09\nStep 60/300\n  Residual: 9.77e-09\nStep 61/300\n  Residual: 9.49e-09\nStep 62/300\n  Residual: 9.81e-09\nStep 63/300\n  Residual: 9.99e-09\nStep 64/300\n  Residual: 9.35e-09\nStep 65/300\n  Residual: 9.92e-09\nStep 66/300\n  Residual: 9.97e-09\nStep 67/300\n  Residual: 9.40e-09\nStep 68/300\n  Residual: 9.61e-09\nStep 69/300\n  Residual: 9.78e-09\nStep 70/300\n  Residual: 9.64e-09\nStep 71/300\n  Residual: 9.55e-09\nStep 72/300\n  Residual: 9.92e-09\nStep 73/300\n  Residual: 9.93e-09\nStep 74/300\n  Residual: 9.90e-09\nStep 75/300\n  Residual: 9.58e-09\nStep 76/300\n  Residual: 9.97e-09\nStep 77/300\n  Residual: 9.97e-09\nStep 78/300\n  Residual: 9.83e-09\nStep 79/300\n  Residual: 9.30e-09\nStep 80/300\n  Residual: 9.97e-09\nStep 81/300\n  Residual: 9.12e-09\nStep 82/300\n  Residual: 9.76e-09\nStep 83/300\n  Residual: 9.66e-09\nStep 84/300\n  Residual: 9.86e-09\nStep 85/300\n  Residual: 9.82e-09\nStep 86/300\n  Residual: 9.81e-09\nStep 87/300\n  Residual: 9.88e-09\nStep 88/300\n  Residual: 9.37e-09\nStep 89/300\n  Residual: 9.83e-09\nStep 90/300\n  Residual: 9.86e-09\nStep 91/300\n  Residual: 9.60e-09\nStep 92/300\n  Residual: 9.80e-09\nStep 93/300\n  Residual: 9.71e-09\nStep 94/300\n  Residual: 9.93e-09\nStep 95/300\n  Residual: 9.83e-09\nStep 96/300\n  Residual: 9.87e-09\nStep 97/300\n  Residual: 9.99e-09\nStep 98/300\n  Residual: 9.61e-09\nStep 99/300\n  Residual: 9.85e-09\nStep 100/300\n  Residual: 9.65e-09\nStep 101/300\n  Residual: 9.71e-09\nStep 102/300\n  Residual: 9.75e-09\nStep 103/300\n  Residual: 9.89e-09\nStep 104/300\n  Residual: 9.63e-09\nStep 105/300\n  Residual: 9.96e-09\nStep 106/300\n  Residual: 9.97e-09\nStep 107/300\n  Residual: 9.71e-09\nStep 108/300\n  Residual: 9.83e-09\nStep 109/300\n  Residual: 9.92e-09\nStep 110/300\n  Residual: 9.27e-09\nStep 111/300\n  Residual: 9.27e-09\nStep 112/300\n  Residual: 9.13e-09\nStep 113/300\n  Residual: 9.53e-09\nStep 114/300\n  Residual: 9.78e-09\nStep 115/300\n  Residual: 9.77e-09\nStep 116/300\n  Residual: 9.67e-09\nStep 117/300\n  Residual: 9.33e-09\nStep 118/300\n  Residual: 9.61e-09\nStep 119/300\n  Residual: 9.69e-09\nStep 120/300\n  Residual: 9.35e-09\nStep 121/300\n  Residual: 9.39e-09\nStep 122/300\n  Residual: 9.30e-09\nStep 123/300\n  Residual: 9.34e-09\nStep 124/300\n  Residual: 9.21e-09\nStep 125/300\n  Residual: 9.68e-09\nStep 126/300\n  Residual: 9.69e-09\nStep 127/300\n  Residual: 9.55e-09\nStep 128/300\n  Residual: 9.60e-09\nStep 129/300\n  Residual: 9.93e-09\nStep 130/300\n  Residual: 9.42e-09\nStep 131/300\n  Residual: 9.41e-09\nStep 132/300\n  Residual: 9.79e-09\nStep 133/300\n  Residual: 9.89e-09\nStep 134/300\n  Residual: 9.95e-09\nStep 135/300\n  Residual: 9.44e-09\nStep 136/300\n  Residual: 9.66e-09\nStep 137/300\n  Residual: 9.49e-09\nStep 138/300\n  Residual: 9.83e-09\nStep 139/300\n  Residual: 9.96e-09\nStep 140/300\n  Residual: 9.49e-09\nStep 141/300\n  Residual: 9.43e-09\nStep 142/300\n  Residual: 9.94e-09\nStep 143/300\n  Residual: 9.49e-09\nStep 144/300\n  Residual: 9.86e-09\nStep 145/300\n  Residual: 9.11e-09\nStep 146/300\n  Residual: 9.81e-09\nStep 147/300\n  Residual: 9.91e-09\nStep 148/300\n  Residual: 9.87e-09\nStep 149/300\n  Residual: 9.63e-09\nStep 150/300\n  Residual: 9.98e-09\nStep 151/300\n  Residual: 9.25e-09\nStep 152/300\n  Residual: 9.93e-09\nStep 153/300\n  Residual: 9.92e-09\nStep 154/300\n  Residual: 9.58e-09\nStep 155/300\n  Residual: 9.92e-09\nStep 156/300\n  Residual: 9.97e-09\nStep 157/300\n  Residual: 9.99e-09\nStep 158/300\n  Residual: 9.24e-09\nStep 159/300\n  Residual: 9.88e-09\nStep 160/300\n  Residual: 9.14e-09\nStep 161/300\n  Residual: 9.76e-09\nStep 162/300\n  Residual: 9.90e-09\nStep 163/300\n  Residual: 9.99e-09\nStep 164/300\n  Residual: 9.72e-09\nStep 165/300\n  Residual: 9.63e-09\nStep 166/300\n  Residual: 9.90e-09\nStep 167/300\n  Residual: 9.56e-09\nStep 168/300\n  Residual: 1.00e-08\nStep 169/300\n  Residual: 9.41e-09\nStep 170/300\n  Residual: 8.96e-09\nStep 171/300\n  Residual: 9.56e-09\nStep 172/300\n  Residual: 9.13e-09\nStep 173/300\n  Residual: 9.93e-09\nStep 174/300\n  Residual: 9.13e-09\nStep 175/300\n  Residual: 9.54e-09\nStep 176/300\n  Residual: 9.11e-09\nStep 177/300\n  Residual: 9.68e-09\nStep 178/300\n  Residual: 8.50e-09\nStep 179/300\n  Residual: 9.01e-09\nStep 180/300\n  Residual: 9.96e-09\nStep 181/300\n  Residual: 9.86e-09\nStep 182/300\n  Residual: 9.98e-09\nStep 183/300\n  Residual: 9.94e-09\nStep 184/300\n  Residual: 9.72e-09\nStep 185/300\n  Residual: 9.36e-09\nStep 186/300\n  Residual: 9.96e-09\nStep 187/300\n  Residual: 9.93e-09\nStep 188/300\n  Residual: 9.59e-09\nStep 189/300\n  Residual: 9.70e-09\nStep 190/300\n  Residual: 9.69e-09\nStep 191/300\n  Residual: 9.75e-09\nStep 192/300\n  Residual: 9.03e-09\nStep 193/300\n  Residual: 9.77e-09\nStep 194/300\n  Residual: 9.83e-09\nStep 195/300\n  Residual: 9.95e-09\nStep 196/300\n  Residual: 9.74e-09\nStep 197/300\n  Residual: 9.18e-09\nStep 198/300\n  Residual: 9.31e-09\nStep 199/300\n  Residual: 9.64e-09\nStep 200/300\n  Residual: 9.54e-09\nStep 201/300\n  Residual: 9.47e-09\nStep 202/300\n  Residual: 9.50e-09\nStep 203/300\n  Residual: 9.76e-09\nStep 204/300\n  Residual: 9.87e-09\nStep 205/300\n  Residual: 9.43e-09\nStep 206/300\n  Residual: 9.36e-09\nStep 207/300\n  Residual: 9.55e-09\nStep 208/300\n  Residual: 9.97e-09\nStep 209/300\n  Residual: 9.79e-09\nStep 210/300\n  Residual: 9.21e-09\nStep 211/300\n  Residual: 9.74e-09\nStep 212/300\n  Residual: 9.65e-09\nStep 213/300\n  Residual: 9.19e-09\nStep 214/300\n  Residual: 9.85e-09\nStep 215/300\n  Residual: 9.85e-09\nStep 216/300\n  Residual: 9.95e-09\nStep 217/300\n  Residual: 9.86e-09\nStep 218/300\n  Residual: 9.82e-09\nStep 219/300\n  Residual: 9.80e-09\nStep 220/300\n  Residual: 9.73e-09\nStep 221/300\n  Residual: 9.86e-09\nStep 222/300\n  Residual: 9.53e-09\nStep 223/300\n  Residual: 9.85e-09\nStep 224/300\n  Residual: 9.64e-09\nStep 225/300\n  Residual: 1.00e-08\nStep 226/300\n  Residual: 9.91e-09\nStep 227/300\n  Residual: 9.93e-09\nStep 228/300\n  Residual: 9.90e-09\nStep 229/300\n  Residual: 9.90e-09\nStep 230/300\n  Residual: 9.76e-09\nStep 231/300\n  Residual: 9.55e-09\nStep 232/300\n  Residual: 9.41e-09\nStep 233/300\n  Residual: 9.78e-09\nStep 234/300\n  Residual: 9.64e-09\nStep 235/300\n  Residual: 9.90e-09\nStep 236/300\n  Residual: 9.86e-09\nStep 237/300\n  Residual: 9.94e-09\nStep 238/300\n  Residual: 9.93e-09\nStep 239/300\n  Residual: 9.89e-09\nStep 240/300\n  Residual: 9.96e-09\nStep 241/300\n  Residual: 9.90e-09\nStep 242/300\n  Residual: 9.84e-09\nStep 243/300\n  Residual: 9.98e-09\nStep 244/300\n  Residual: 9.87e-09\nStep 245/300\n  Residual: 9.99e-09\nStep 246/300\n  Residual: 9.53e-09\nStep 247/300\n  Residual: 9.52e-09\nStep 248/300\n  Residual: 9.84e-09\nStep 249/300\n  Residual: 9.81e-09\nStep 250/300\n  Residual: 9.37e-09\nStep 251/300\n  Residual: 9.19e-09\nStep 252/300\n  Residual: 9.15e-09\nStep 253/300\n  Residual: 8.69e-09\nStep 254/300\n  Residual: 8.68e-09\nStep 255/300\n  Residual: 8.46e-09\nStep 256/300\n  Residual: 9.97e-09\nStep 257/300\n  Residual: 9.93e-09\nStep 258/300\n  Residual: 9.93e-09\nStep 259/300\n  Residual: 9.85e-09\nStep 260/300\n  Residual: 9.59e-09\nStep 261/300\n  Residual: 9.73e-09\nStep 262/300\n  Residual: 9.70e-09\nStep 263/300\n  Residual: 9.49e-09\nStep 264/300\n  Residual: 9.96e-09\nStep 265/300\n  Residual: 9.88e-09\nStep 266/300\n  Residual: 9.91e-09\nStep 267/300\n  Residual: 9.86e-09\nStep 268/300\n  Residual: 9.28e-09\nStep 269/300\n  Residual: 9.66e-09\nStep 270/300\n  Residual: 9.92e-09\nStep 271/300\n  Residual: 9.55e-09\nStep 272/300\n  Residual: 9.66e-09\nStep 273/300\n  Residual: 9.98e-09\nStep 274/300\n  Residual: 9.76e-09\nStep 275/300\n  Residual: 9.46e-09\nStep 276/300\n  Residual: 9.41e-09\nStep 277/300\n  Residual: 9.90e-09\nStep 278/300\n  Residual: 9.59e-09\nStep 279/300\n  Residual: 9.92e-09\nStep 280/300\n  Residual: 9.40e-09\nStep 281/300\n  Residual: 9.37e-09\nStep 282/300\n  Residual: 9.02e-09\nStep 283/300\n  Residual: 9.66e-09\nStep 284/300\n  Residual: 9.66e-09\nStep 285/300\n  Residual: 9.32e-09\nStep 286/300\n  Residual: 9.81e-09\nStep 287/300\n  Residual: 9.43e-09\nStep 288/300\n  Residual: 9.12e-09\nStep 289/300\n  Residual: 8.93e-09\nStep 290/300\n  Residual: 1.00e-08\nStep 291/300\n  Residual: 9.63e-09\nStep 292/300\n  Residual: 9.24e-09\nStep 293/300\n  Residual: 9.35e-09\nStep 294/300\n  Residual: 9.46e-09\nStep 295/300\n  Residual: 9.27e-09\nStep 296/300\n  Residual: 9.79e-09\nStep 297/300\n  Residual: 9.89e-09\nStep 298/300\n  Residual: 9.87e-09\nStep 299/300\n  Residual: 9.67e-09\nStep 300/300\n  Residual: 9.73e-09\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/fracture_quasistatic_3d/#visualization","title":"Visualization","text":"<p>Now we use <code>pyvista</code> and <code>matplotlib</code> to visualize the results.</p> PyVista code for visualization of the results <pre><code>gradient_cohesive = jax.jacrev(total_cohesive_energy)\n\ncohesive_forces_per_step = []\nopening_per_step = []\nstresses_per_step = []\ndisp_per_step = []\n\nfor i in [100, 150, 160, 165, 170, 175, 180, 185, 190, 200]:\n    cohesive_forces_per_step.append(\n        gradient_cohesive(u_per_step[i].reshape(n_dofs), delta_maxs_per_step[i]).reshape(n_nodes, n_dofs_per_node)\n    )\n    jump = (\n        u_per_step[i].at[top_interface_nodes, :].get()\n        - u_per_step[i].at[bottom_interface_nodes, :].get()\n    )\n    jump_quad = interface_op.eval(jump).squeeze()\n    openings = compute_opening(jump_quad)\n    opening_per_step.append(openings)\n\n    grad_u = op.grad(u_per_step[i]).squeeze()\n    strains = compute_strain(grad_u)\n    stresses = compute_stress(strains, mu, lmbda)\n    stresses_per_step.append(stresses)\n    disp_per_step.append(u_per_step[i])\n\nsargs = dict(\n    title=r\"Stresses\",\n    height=0.08,  # Reduces the length (25% of window height)\n    width=0.4,  # Adjusts thickness\n    vertical=False,  # Orientation\n    position_x=0.6,  # Distance from left edge (5%)\n    position_y=0.2,  # Distance from bottom edge (5%)\n    title_font_size=20,\n    label_font_size=16,\n    color=\"black\",  # Useful for white/transparent backgrounds\n    font_family=\"arial\",\n)\n\n\nstep_number = 6\n\n\ngrid = pv.UnstructuredGrid(\n    np.hstack((np.full((mesh.elements.shape[0], 1), 8), mesh.elements)).flatten(),\n    np.full(mesh.elements.shape[0], pv.CellType.HEXAHEDRON),\n    np.array(mesh.coords),\n)\n\ngrid.cell_data[\"stresses\"] = (\n    np.mean(np.array(stresses_per_step[step_number]), axis=1) / E\n)\ngrid = grid.cell_data_to_point_data()\n\ngrid_interface = pv.UnstructuredGrid(\n    np.hstack(\n        (np.full((interface_mesh.elements.shape[0], 1), 4), interface_mesh.elements)\n    ).flatten(),\n    np.full(interface_mesh.elements.shape[0], pv.CellType.QUAD),\n    np.array(interface_mesh.coords),\n)\n\ngrid_top_interface = pv.UnstructuredGrid(\n    np.hstack(\n        (np.full((interface_mesh.elements.shape[0], 1), 4), interface_mesh.elements)\n    ).flatten(),\n    np.full(interface_mesh.elements.shape[0], pv.CellType.QUAD),\n    np.array(interface_mesh.coords),\n)\n\npl = pv.Plotter(window_size=(800, 400))\ngrid[\"u\"] = np.array(disp_per_step[step_number].reshape(-1, n_dofs_per_node))\ngrid_interface[\"u\"] = np.array(\n    disp_per_step[step_number][bottom_interface_nodes].reshape(-1, n_dofs_per_node)\n)\ngrid_interface.cell_data[\"opening\"] = np.array(opening_per_step[step_number])\ngrid_interface.set_active_scalars(\"opening\")\n\ngrid_top_interface[\"u\"] = np.array(\n    disp_per_step[step_number][top_interface_nodes].reshape(-1, n_dofs_per_node)\n)\ngrid_top_interface.cell_data[\"opening\"] = np.array(opening_per_step[step_number])\ngrid_top_interface.set_active_scalars(\"opening\")\n\n\nwarp_factor = 1.0\nwarped = grid.warp_by_vector(\"u\", factor=warp_factor)\n\nwarped_interface = grid_interface.warp_by_vector(\"u\", factor=warp_factor * 0.98)\nwarped_interface_top = grid_top_interface.warp_by_vector(\"u\", factor=warp_factor * 0.98)\n\n\npl.add_mesh(\n    warped_interface,\n    show_edges=False,\n    cmap=\"pink_r\",\n    scalars=\"opening\",\n    smooth_shading=False,\n    show_scalar_bar=False,\n)\npl.add_mesh(\n    warped,\n    show_edges=False,\n    scalars=\"stresses\",\n    cmap=\"managua_r\",\n    line_width=0.1,\n    scalar_bar_args=sargs,\n    opacity=1.0,\n)\npl.view_vector([-0.85, -0.5, 1.0])\npl.show()\n</code></pre> <p></p> <p>Click the image above to explore the 3D fracture in full screen.</p> Plotting the force-displacement curve and energy evolution <pre><code>Gamma_W = Gamma * (Lx - crack_length) * Lz\n\nfig, axs = plt.subplots(\n    1, 2, figsize=(7, 3.8), layout=\"constrained\", gridspec_kw={\"width_ratios\": [1, 1]}\n)\n\n\naxs[0].plot(\n    np.array(displacement_on_top) / height / 2,\n    (np.array(energies[\"elastic\"]) + np.array(energies[\"cohesive\"])) / Gamma_W,\n    markevery=5,\n    label=\"Total\",\n)\naxs[0].plot(\n    np.array(displacement_on_top) / height / 2,\n    np.array(energies[\"elastic\"]) / Gamma_W,\n    label=\"Elastic\",\n    markevery=5,\n)\naxs[0].plot(\n    np.array(displacement_on_top) / height / 2,\n    np.array(energies[\"cohesive\"]) / Gamma_W,\n    label=\"Cohesive\",\n    markevery=5,\n)\n\naxs[0].axhline(1, color=\"gray\", zorder=-1, linestyle=\"--\")\naxs[0].set_xlabel(r\"$\\varepsilon$\")\naxs[0].set_ylabel(r\"$\\Psi/\\Gamma\\cdot{}W$\")\naxs[0].grid(True)\naxs[0].set_xlim(0, np.array(displacement_on_top)[-80] / height / 2)\naxs[0].grid(True)\naxs[0].legend(frameon=False, numpoints=1, markerscale=1.25)\naxs[0].spines[\"top\"].set_visible(False)\naxs[0].spines[\"right\"].set_visible(False)\n\naxs[1].plot(\n    np.array(displacement_on_top) / height / 2,\n    np.array(force_on_top) / (sigma_c * Lz * (Lx - crack_length)),\n    color=\"#AC8D18\",\n)\naxs[1].set_xlabel(r\"$\\varepsilon$\")\naxs[1].set_ylabel(r\"$F/(\\sigma_c \\cdot t \\cdot W)$\")\naxs[1].grid(True)\naxs[1].set_xlim(0, np.array(displacement_on_top)[-80] / height / 2)\naxs[1].spines[\"top\"].set_visible(False)\naxs[1].spines[\"right\"].set_visible(False)\n\nplt.show()\n</code></pre> <p></p> Create an animation of the fracture process <pre><code>plotter = pv.Plotter(notebook=False, off_screen=True)\nplotter.window_size = (800, 400)\n\ngrid.point_data[\"u\"] = disp_per_step[0].reshape(-1, n_dofs_per_node)\ngrid.cell_data[\"c\"] = np.mean(np.array(stresses_per_step[0]), axis=1) / E\ngrid.set_active_scalars(\"c\")\n\nplotter.open_gif(\"../assets/images/cohesive_fracture.gif\", fps=2)\nplotter.add_mesh(\n    grid,\n    show_edges=False,\n    scalars=\"c\",\n    cmap=\"managua_r\",\n    line_width=0.1,\n    show_scalar_bar=False,\n)\nplotter.view_vector([-0.85, -0.5, 1.0])\n\n\n\nfor n in range(len(disp_per_step)):\n    u_current = disp_per_step[n].reshape(-1, n_dofs_per_node)\n    values_current = stresses_per_step[n]\n    grid.point_data[\"u\"] = u_current\n    grid.points = np.array(mesh.coords) + np.array(u_current)\n    grid.cell_data[\"c\"] = np.mean(np.array(values_current), axis=1) / E\n    grid = grid.cell_data_to_point_data()\n    grid.set_active_scalars(\"c\")\n\n    plotter.update_scalar_bar_range(\n        [np.min(grid.point_data[\"c\"]), np.max(grid.point_data[\"c\"])]\n    )\n    plotter.write_frame()\n\n\nplotter.close()\n</code></pre>"},{"location":"examples/homogenization_periodic/","title":"Periodic BCs (Lagrange Multipliers)","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif \"google.colab\" in str(get_ipython()):\n    print(\"Installing dependencies using uv...\")\n    # Install uv if not available\n    !pip install -q uv\n    # Install system dependencies\n    !apt-get install -qq gmsh\n    # Use uv to install Python dependencies\n    !uv pip install --system matplotlib meshio\n    !uv pip install --system \"git+https://github.com/smec-ethz/tatva-docs.git\"\n    print(\"Installation complete!\")\n</code></pre>"},{"location":"examples/homogenization_periodic/#periodic-boundary-conditions","title":"Periodic Boundary Conditions","text":"<p>We compute the effective (homogenized) stiffness of a periodic composite by solving a cell problem on one representative unit cell \\(\\mathcal{A}\\). The microscopic displacement is decomposed as</p> \\[ \\boldsymbol{u}(\\boldsymbol{y}) = \\boldsymbol{E}\\,\\boldsymbol{y} + \\boldsymbol{v}(\\boldsymbol{y}), \\] <p>where \\(\\boldsymbol{E}\\) is a prescribed macroscopic strain and \\(\\boldsymbol{v}\\) is a periodic fluctuation field.</p> <p>We solve this example with two approaches:</p> <ul> <li>We show the use of Lagrange multipliers to enforce periodicity. We will solve the saddle-point problem using sparse differentiation and a direct sparse solver. </li> <li>Alternatively, we enforce periodicity through a MPC and static condensation, and solve the problem using a matrix-free CG-solver.</li> </ul> <p>We follow Jeremy Bleyer's example: https://bleyerj.github.io/comet-fenicsx/tours/homogenization/periodic_elasticity/periodic_elasticity.html</p> \\[ \\begin{cases} \\nabla\\!\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0} &amp; \\text{in } \\mathcal{A},\\\\ \\boldsymbol{\\sigma}=\\mathbb{C}(\\boldsymbol{y}):\\boldsymbol{\\varepsilon} &amp; \\text{(heterogeneous material)},\\\\ \\boldsymbol{\\varepsilon}=\\boldsymbol{E}+\\nabla^s\\boldsymbol{v} &amp; \\text{in } \\mathcal{A},\\\\ \\boldsymbol{v}\\text{ is periodic},\\\\ \\boldsymbol{T}=\\boldsymbol{\\sigma}\\boldsymbol{n}\\text{ is anti-periodic.} \\end{cases} \\] <p>Because the framework is fully differentiable, we can obtain \\(\\mathbb{C}^{\\text{hom}}\\) directly by differentiating the map \\(\\boldsymbol{E} \\mapsto \\langle\\boldsymbol{\\sigma}(\\boldsymbol{E})\\rangle\\), rather than solving separate problems for multiple \\(\\boldsymbol{E}\\).</p> <pre><code>import gmsh\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom jax import Array\nfrom tatva import Mesh, Operator, compound, element\n\njax.config.update(\"jax_enable_x64\", True)\n</code></pre>"},{"location":"examples/homogenization_periodic/#meshing","title":"Meshing","text":"<p>We build a periodic unit square with circular inclusions using <code>gmsh</code>. Two physical regions are extracted:</p> <ul> <li>Matrix elements</li> <li>Inclusions elements</li> </ul> <p>Boundary edges are also tagged (<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>) so we can later pair nodes and impose periodicity.</p> Code for mesh generation and extraction <pre><code>from itertools import chain\nfrom typing import TypedDict\n\n\nclass PhysicalGroups(TypedDict):\n    Matrix: Array\n    Inclusions: Array\n    bottom: Array\n    right: Array\n    top: Array\n    left: Array\n\n\ndef plot_mesh(mesh: Mesh, pg: PhysicalGroups, ax: plt.Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.triplot(\n        mesh.coords[:, 0], mesh.coords[:, 1], mesh.elements, color=\"gray\", linewidth=0.5\n    )\n    # Plot physical groups with different colors\n    ax.tricontourf(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        jnp.zeros(mesh.coords.shape[0]).at[pg[\"Inclusions\"]].set(1.0),\n        levels=[-0.5, 0.5, 1.5],\n        colors=[\"C0\", \"C1\"],\n        alpha=0.3,\n    )  # ty: ignore\n    ax.set_aspect(\"equal\")\n\n\ndef extract_physical_groups(tag_map: dict) -&gt; PhysicalGroups:\n    print(\"Extracting physical groups from Gmsh model...\")\n    physical_surfaces: dict[str, Array] = {}\n\n    for dim, pg_tag in chain(\n        gmsh.model.getPhysicalGroups(dim=1), gmsh.model.getPhysicalGroups(dim=2)\n    ):\n        name = gmsh.model.getPhysicalName(dim, pg_tag)\n\n        # Entities (surface tags) that belong to this physical group\n        entities = gmsh.model.getEntitiesForPhysicalGroup(dim, pg_tag)\n\n        els = []\n        for ent in entities:\n            # Get all mesh elements on this surface entity\n            types, _, node_tags_by_type = gmsh.model.mesh.getElements(dim, ent)\n\n            for etype, ntags in zip(types, node_tags_by_type):\n                nodes = np.array(ntags, dtype=np.int64).reshape(-1, etype + 1)\n                els.append(nodes)\n\n        if not els:\n            physical_surfaces[name] = np.zeros((0, dim + 1), dtype=np.int32)\n            continue\n\n        group_els = np.vstack(els, dtype=np.int32)\n        group_els = np.array(\n            [[tag_map[t] for t in tri] for tri in group_els], dtype=np.int32\n        )\n        physical_surfaces[name] = group_els\n\n    return physical_surfaces\n\n\ndef extract_mesh_data() -&gt; tuple[Array, Array, PhysicalGroups]:\n    # Extract nodes and elements\n    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()\n    tag_map = {tag: i for i, tag in enumerate(node_tags)}\n    nodes = jnp.array(node_coords).reshape(-1, 3)[:, :2]\n\n    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)\n    elements = jnp.array(elem_node_tags[0]).reshape(-1, 3) - 1\n\n    pg = extract_physical_groups(tag_map)\n    return nodes, elements, pg\n\n\ndef generate_mesh(\n    Lx: float, Ly: float, c: float, R: float, h: float\n) -&gt; tuple[Mesh, PhysicalGroups, NDArray]:\n    corners = np.array([[0.0, 0.0], [Lx, 0.0], [Lx + c, Ly], [c, Ly]])\n    a1 = corners[1, :] - corners[0, :]  # first vector generating periodicity\n    a2 = corners[3, :] - corners[0, :]  # second vector generating periodicity\n\n    gdim = 2  # domain geometry dimension\n    fdim = 1  # facets dimension\n    gmsh.initialize()\n\n    occ = gmsh.model.occ\n    model_rank = 0\n    points = [occ.add_point(*corner, 0) for corner in corners]\n    lines = [occ.add_line(points[i], points[(i + 1) % 4]) for i in range(4)]\n    loop = occ.add_curve_loop(lines)\n    unit_cell = occ.add_plane_surface([loop])\n    inclusions = [occ.add_disk(*corner, 0, R, R) for corner in corners]\n    vol_dimTag = (gdim, unit_cell)\n    out = occ.intersect(\n        [vol_dimTag], [(gdim, incl) for incl in inclusions], removeObject=False\n    )\n    incl_dimTags = out[0]\n    occ.synchronize()\n    occ.cut([vol_dimTag], incl_dimTags, removeTool=False)\n    occ.synchronize()\n\n    # tag physical domains and facets\n    gmsh.model.addPhysicalGroup(gdim, [vol_dimTag[1]], 1, name=\"Matrix\")\n    gmsh.model.addPhysicalGroup(\n        gdim,\n        [tag for _, tag in incl_dimTags],\n        2,\n        name=\"Inclusions\",\n    )\n    gmsh.model.addPhysicalGroup(fdim, [7, 20, 10], 1, name=\"bottom\")\n    gmsh.model.addPhysicalGroup(fdim, [9, 19, 16], 2, name=\"right\")\n    gmsh.model.addPhysicalGroup(fdim, [15, 18, 12], 3, name=\"top\")\n    gmsh.model.addPhysicalGroup(fdim, [11, 17, 5], 4, name=\"left\")\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", h)\n    gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", h)\n\n    gmsh.model.mesh.generate(gdim)\n\n    nodes, elements, pg = extract_mesh_data()\n    mesh = Mesh(coords=nodes, elements=elements)\n    gmsh.finalize()\n    return mesh, pg, corners\n</code></pre> <pre><code>Ly = np.sqrt(3) / 2.0 * Lx\nc = 0.5 * Lx\nR = 0.2 * Lx\nh = 0.02 * Lx\n\nmesh, pg, corners = generate_mesh(Lx, Ly, c, R, h)\n</code></pre> Output <pre><code>Info    : Meshing 1D...ence                                                                                                                      \nInfo    : [  0%] Meshing curve 5 (Line)\nInfo    : [ 10%] Meshing curve 6 (Ellipse)\nInfo    : [ 20%] Meshing curve 7 (Line)\nInfo    : [ 20%] Meshing curve 8 (Ellipse)\nInfo    : [ 30%] Meshing curve 9 (Line)\nInfo    : [ 40%] Meshing curve 10 (Line)\nInfo    : [ 40%] Meshing curve 11 (Line)\nInfo    : [ 50%] Meshing curve 12 (Line)\nInfo    : [ 60%] Meshing curve 13 (Ellipse)\nInfo    : [ 60%] Meshing curve 14 (Ellipse)\nInfo    : [ 70%] Meshing curve 15 (Line)\nInfo    : [ 70%] Meshing curve 16 (Line)\nInfo    : [ 80%] Meshing curve 17 (Line)\nInfo    : [ 90%] Meshing curve 18 (Line)\nInfo    : [ 90%] Meshing curve 19 (Line)\nInfo    : [100%] Meshing curve 20 (Line)\nInfo    : Done meshing 1D (Wall 0.000598198s, CPU 0.00099s)\nInfo    : Meshing 2D...\nInfo    : [  0%] Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 2 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 3 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 4 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 5 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0501108s, CPU 0.048249s)\nInfo    : 2679 nodes 5432 elements\nExtracting physical groups from Gmsh model...\n</code></pre> <pre><code>plot_mesh(mesh, pg)\n</code></pre> <p></p>"},{"location":"examples/homogenization_periodic/#problem-setup","title":"Problem setup","text":""},{"location":"examples/homogenization_periodic/#material","title":"Material","text":"<p>We define isotropic linear elasticity for each phase through Lame parameters \\((\\mu,\\lambda)\\). The local constitutive law is</p> \\[ \\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon} + \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I}. \\] <p>For a given macroscopic strain \\(\\boldsymbol{E}=\\hat{\\boldsymbol{\\varepsilon}}\\), the cell energy density uses</p> \\[ \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\nabla^s\\boldsymbol{u} + \\hat{\\boldsymbol{\\varepsilon}}. \\] <p>This lets us solve the microscopic fluctuation while embedding the imposed macro-strain.</p> <pre><code>from typing import NamedTuple\n\nfrom jax_autovmap import autovmap\n\n\nclass Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  # Shear modulus\n    lmbda: float  # Lam\u00e9 parameter\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat_matrix = Material.from_youngs_poisson_2d(50e3, 0.2)\nmat_inclusion = Material.from_youngs_poisson_2d(210e3, 0.3)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n\n\n@autovmap(grad_u=2, eps_hat=2, mu=0, lmbda=0)\ndef strain_energy(grad_u, eps_hat, mu, lmbda):\n    \"\"\"Includes macroscopic strain eps_hat.\"\"\"\n    eps = compute_strain(grad_u) + eps_hat\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n</code></pre>"},{"location":"examples/homogenization_periodic/#periodic-mapping","title":"Periodic mapping","text":"<p>Periodic kinematics require matching opposite boundary nodes:</p> <ul> <li>left \\(\\leftrightarrow\\) right</li> <li>bottom \\(\\leftrightarrow\\) top</li> </ul> <p>The helper <code>edge_bijection</code> builds slave-to-master pairs by geometric matching. Corner nodes are handled separately to avoid duplicate constraints.</p> <pre><code>from numpy.typing import NDArray\n\nArrayLike = NDArray | Array\n\nmesh_matrix = mesh._replace(elements=pg[\"Matrix\"])\nmesh_inclusion = mesh._replace(elements=pg[\"Inclusions\"])\nop_matrix = Operator(mesh_matrix, element.Tri3())\nop_inclusion = Operator(mesh_inclusion, element.Tri3())\nop = Operator(mesh, element.Tri3())\n\n\ndef edge_bijection(\n    coords: ArrayLike,\n    m_group: ArrayLike,\n    s_group: ArrayLike,\n    *,\n    axis: int = 0,\n    offset: float = 0.0,\n) -&gt; Array:\n    \"\"\"Find a bijection between master and slave edge nodes. Returns an array of sorted\n    slave node indices such that s_nodes[i] -&gt; m_nodes[i]\n    \"\"\"\n    axis = axis ^ 1  # bitwise xor to get the other axis\n    m_nodes = jnp.unique(m_group)\n    s_nodes = jnp.unique(s_group)\n\n    # exclude corners from the matching (min and max in axis direction)\n    m_nodes = m_nodes[\n        (coords[m_nodes, axis] != jnp.min(coords[m_nodes, axis]))\n        &amp; (coords[m_nodes, axis] != jnp.max(coords[m_nodes, axis]))\n    ]\n    s_nodes = s_nodes[\n        (coords[s_nodes, axis] != jnp.min(coords[s_nodes, axis]))\n        &amp; (coords[s_nodes, axis] != jnp.max(coords[s_nodes, axis]))\n    ]\n\n    # for each m_node, find the closest s_node depending on the periodicity vector\n    def find_closest_slave(m_node: ArrayLike, inv_axis: int) -&gt; ArrayLike:\n        diffs = coords[s_nodes, inv_axis] - (coords[m_node, inv_axis] + offset)\n        return jnp.array([m_node, s_nodes[jnp.argmin(diffs**2)]])\n\n    return jax.vmap(find_closest_slave, in_axes=(0, None))(m_nodes, axis)\n\n\ncorner_nodes = [\n    jnp.argmin(jnp.linalg.norm(mesh.coords - corner, axis=1)) for corner in corners\n]\ncorner_m = jnp.repeat(corner_nodes[0], 3)\ncorner_s = jnp.array(corner_nodes[1:])\nleft_right = edge_bijection(mesh.coords, pg[\"left\"], pg[\"right\"], axis=0)\nbottom_top = edge_bijection(\n    mesh.coords, pg[\"bottom\"], pg[\"top\"], axis=1, offset=Lx * 1 / 2\n)\ncorner_map = jnp.vstack([corner_m, corner_s]).T\n</code></pre>"},{"location":"examples/homogenization_periodic/#pbcs-with-lagrange-multipliers","title":"PBCs with Lagrange Multipliers","text":"<p>We create a <code>Compound</code> subclass with two fields: - \\(\\mathbf{u}\\): the periodic displacement fluctuation field <code>(n_nodes, 2)</code> - \\(\\lambda\\): the lagrange multipliers <code>(n_slave_nodes, 2)</code></p> <pre><code>import jax.experimental.sparse as jsparse\nimport scipy.sparse as sp\nfrom tatva.lifter import DirichletBC, Lifter\nfrom tatva.sparse import create_sparsity_pattern, reduce_sparsity_pattern\n\n\nclass SolutionLM(compound.Compound):\n    u = compound.field(mesh.coords.shape)\n    lm = compound.field(\n        (left_right.shape[0] + bottom_top.shape[0] + corner_s.shape[0], 2)\n    )\n</code></pre> Code for augmenting sparsity pattern with dense constraint blocks (e.g., for Lagrange multipliers) <pre><code>def add_dense_matrix_to_sparsity(\n    base_sparsity: jsparse.BCOO, B: Array, C_full: bool = False\n) -&gt; jsparse.BCOO:\n    \"\"\"Augment a base sparsity pattern with dense constraint blocks.\n\n    Args:\n        base_sparsity: Base sparsity pattern for the primal block.\n        B: Dense constraint coupling block to be appended.\n        C_full: Whether to use a dense (True) or identity (False) constraint block.\n\n    Returns:\n        Combined sparsity pattern including the constraint blocks.\n    \"\"\"\n    nb_cons = B.shape[0]\n    B_sparsity_pattern = jsparse.BCOO.fromdense(B).astype(jnp.int32)\n    BT_sparsity_pattern = jsparse.BCOO.fromdense(B.T).astype(jnp.int32)\n    if C_full:\n        c_dense = jnp.ones((nb_cons, nb_cons))\n    else:\n        c_dense = jnp.eye(nb_cons, nb_cons)\n    C = jsparse.BCOO.fromdense(c_dense).astype(jnp.int32)\n\n    sp_left = jsparse.bcoo_concatenate([base_sparsity, B_sparsity_pattern], dimension=0)\n    sp_right = jsparse.bcoo_concatenate([BT_sparsity_pattern, C], dimension=0)\n    full_sparsity = jsparse.bcoo_concatenate([sp_left, sp_right], dimension=1)\n    return full_sparsity\n</code></pre> <pre><code>def constraints_func(u_flat: Array) -&gt; Array:\n    \"\"\"A function that returns the residual of the periodicity constraints, which should\n    be zero at the solution. The Lagrange multipliers will enforce these constraints.\n    \"\"\"\n    (u, _) = SolutionLM(u_flat)\n    u_diff_left_right = u[left_right[:, 0]] - u[left_right[:, 1]]\n    u_diff_bot_top = u[bottom_top[:, 0]] - u[bottom_top[:, 1]]\n    u_diff_corners = u[corner_m] - u[corner_s]\n    return jnp.concatenate(\n        [\n            u_diff_left_right.flatten(),\n            u_diff_bot_top.flatten(),\n            u_diff_corners.flatten(),\n        ]\n    )\n</code></pre>"},{"location":"examples/homogenization_periodic/#sparsity-and-graph-coloring","title":"Sparsity and graph coloring","text":"<pre><code>from tatva_coloring import distance2_color_and_seeds\n\n# generate base sparsity pattern for the primal block\nsparsity = create_sparsity_pattern(mesh, 2)\n# add dense blocks for the coupling constraints with Lagrange multipliers\nsparsity = add_dense_matrix_to_sparsity(\n    sparsity,\n    jax.jacfwd(constraints_func)(jnp.zeros(SolutionLM.size))[\n        :, : -(SolutionLM.lm.shape[0] * 2)\n    ],\n    C_full=False,  # only coupling constraints, no dense interactions between Lagrange multipliers themselves\n)\n\n# we use a lifter to restrict rigid body modes\nlifter = Lifter(\n    SolutionLM.size,\n    DirichletBC(SolutionLM.u[[corner_m[0]]]),\n)\n\nsparsity = reduce_sparsity_pattern(sparsity, lifter.free_dofs)\nsparsity_csr = sp.csr_matrix(\n    (sparsity.data, (sparsity.indices[:, 0], sparsity.indices[:, 1])),\n    shape=sparsity.shape,\n)\n\ncolors = distance2_color_and_seeds(\n    sparsity_csr.indptr, sparsity_csr.indices, sparsity.shape[0]\n)[0]\n\nprint(f\"Number of colors required: {jnp.max(colors) + 1}\")\n</code></pre> <pre><code>Number of colors required: 26\n</code></pre>"},{"location":"examples/homogenization_periodic/#energy-functional-and-sparse-jacobian","title":"Energy functional and sparse Jacobian","text":"<p>The total cell energy is the sum of matrix and inclusion contributions:</p> \\[ \\Pi(\\mathbf{u};\\hat{\\boldsymbol{\\varepsilon}})=\\int_{\\mathcal{A}_m}\\psi_m\\,dA+\\int_{\\mathcal{A}_i}\\psi_i\\,dA. \\] <p>We minimize in reduced variables by composing with the lifter, \\(\\Pi_r(\\mathbf{v}) = \\Pi(\\text{lift}(\\mathbf{v}))\\).</p> <p><code>jax.jacrev</code> gives the residual, and a colored sparse Jacobian is assembled for efficient linear solves.</p> <pre><code>from tatva import sparse\n\n\ndef total_energy(u: Array, eps_hat: Array) -&gt; Array:\n    # compute energy contributions from matrix and inclusion domains\n    e_inclusion = op_inclusion.integrate(\n        strain_energy(\n            op_inclusion.grad(u), eps_hat, mat_inclusion.mu, mat_inclusion.lmbda\n        )\n    )\n    e_matrix = op_matrix.integrate(\n        strain_energy(op_matrix.grad(u), eps_hat, mat_matrix.mu, mat_matrix.lmbda)\n    )\n    return e_inclusion + e_matrix\n\n\ndef lagrangian(u_flat: Array, eps_hat: Array) -&gt; Array:\n    (u, lm) = SolutionLM(u_flat)\n\n    # add contribution from Lagrange multipliers enforcing periodicity constraints\n    return total_energy(u, eps_hat) + jnp.dot(lm.flatten(), constraints_func(u_flat))\n\n\ndef lagrangian_free(u_free: Array, eps_hat: Array) -&gt; Array:\n    u_full = lifter.lift_from_zeros(u_free)\n    return lagrangian(u_full, eps_hat)\n\n\nresidual = jax.jacrev(lagrangian_free)\njacobian = sparse.jacfwd(\n    residual, sparsity_csr.indptr, sparsity_csr.indices, colors, has_aux_args=True\n)\n</code></pre>"},{"location":"examples/homogenization_periodic/#solve-for-unit-strains","title":"Solve for unit strains","text":"<p>We solve three independent 2D strain load cases (Voigt basis):</p> <ul> <li>\\(\\varepsilon_{xx}=1\\)</li> <li>\\(\\varepsilon_{yy}=1\\)</li> <li>\\(\\varepsilon_{xy}=1\\) (implemented with symmetric \\(0.5\\) off-diagonals)</li> </ul> <p>For each case, we solve the linearized equilibrium for fluctuation DOFs, then reconstruct</p> \\[ \\boldsymbol{u}(\\boldsymbol{y}) = \\hat{\\boldsymbol{\\varepsilon}}\\,\\boldsymbol{y} + \\tilde{\\boldsymbol{u}}(\\boldsymbol{y}). \\] Newton-Krylov solver with sparse direct solver for the linearized system. <pre><code>from functools import partial\n\n\n@partial(jax.jit, static_argnames=[\"gradient\", \"compute_tangent\"])\ndef newton_krylov_solver(\n    u,\n    gradient,\n    compute_tangent,\n):\n    residual = gradient(u)\n    norm_res = jnp.linalg.norm(residual)\n\n    init_val = (u, 0, norm_res)\n\n    def cond_fun(state):\n        u, iiter, norm_res = state\n        return jnp.logical_and(norm_res &gt; 1e-8, iiter &lt; 10)\n\n    def body_fun(state):\n        u, iiter, norm_res = state\n        residual = gradient(u)\n\n        A = jax.jit(partial(compute_tangent, u_prev=u))\n\n        du, _ = jax.scipy.sparse.linalg.cg(A=A, b=-residual)\n\n        u = u + du\n\n        residual = gradient(u)\n        norm_res = jnp.linalg.norm(residual)\n\n        return (u, iiter + 1, norm_res)\n\n    final_u, final_iiter, final_norm = jax.lax.while_loop(cond_fun, body_fun, init_val)\n    jax.debug.print(\"  Residual: {res:.2e}\", res=final_norm)\n\n    return final_u, final_norm\n</code></pre> <pre><code>from dataclasses import dataclass\n\n\ndef sparse_solve(A: jsparse.BCOO, b: Array) -&gt; Array:\n    return jsparse.linalg.spsolve(A.data, sparsity_csr.indices, sparsity_csr.indptr, b)\n\n\n@dataclass\nclass Result:\n    u: NDArray\n    eps_hat: NDArray\n\n\nv0 = jnp.zeros(lifter.size_reduced)\n\nscale = 0.3\neps_hat_list = scale * jnp.array(\n    [\n        [[1.0, 0.0], [0.0, 0.0]],\n        [[0.0, 0.0], [0.0, 1.0]],\n        [[0.0, 0.5], [0.5, 0.0]],\n    ]\n)  # unit strain tensors\n\nresults = []\n\nfor eps_hat in eps_hat_list[:]:\n    v = sparse_solve(jacobian(v0, eps_hat), -residual(v0, eps_hat))\n    u0 = (eps_hat @ mesh.coords.T).T\n    u = u0 + SolutionLM(lifter.lift_from_zeros(v)).u\n    results.append(Result(u=u, eps_hat=eps_hat))\n</code></pre>"},{"location":"examples/homogenization_periodic/#results","title":"Results","text":"Functions for post-processing and visualization of results <pre><code>from matplotlib.cm import ScalarMappable\nfrom matplotlib.tri import Triangulation\nfrom matplotlib.colors import ListedColormap, Normalize\nfrom matplotlib.collections import LineCollection\n\nimport numpy as np\n\n\ndef cell_to_point_data(\n    coords: np.ndarray,\n    elements: np.ndarray,\n    celldata: np.ndarray,\n    *,\n    method: str = \"area\",\n    eps: float = 1e-30,\n) -&gt; np.ndarray:\n    \"\"\"Interpolate (average) per-cell data to nodes for a 2D triangular mesh.\n\n    Args:\n        coords: float\n        elements: (node indices per triangle)\n        celldata: (nels, ...) float  (e.g. stress components per element)\n        method: \"uniform\" or \"area\"\n            - \"uniform\": each incident element contributes equally\n            - \"area\"   : each incident element weighted by triangle area\n        eps: small number to avoid divide-by-zero\n\n    Returns:\n        pointdata: (nnodes, ...) float\n    \"\"\"\n    coords = np.asarray(coords)\n    elements = np.asarray(elements, dtype=np.int64)\n    celldata = np.asarray(celldata)\n\n    nnodes = coords.shape[0]\n    nels = elements.shape[0]\n\n    # Flatten celldata trailing dims -&gt; (nels, ncomp)\n    trailing_shape = celldata.shape[1:]\n    cel_flat = celldata.reshape(nels, -1)\n    ncomp = cel_flat.shape[1]\n\n    # Optional weights per element\n    if method == \"uniform\":\n        w = np.ones(nels, dtype=cel_flat.dtype)\n    elif method == \"area\":\n        tri = coords[elements]  # (nels, 3, 2)\n        a = tri[:, 1] - tri[:, 0]\n        b = tri[:, 2] - tri[:, 0]\n        # signed area*2 = cross(a,b) in 2D\n        w = 0.5 * np.abs(a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0])\n        w = w.astype(cel_flat.dtype, copy=False)\n    else:\n        raise ValueError(\"method must be 'uniform' or 'area'\")\n\n    # Accumulate: for each element, add w*celldata to its 3 nodes\n    point_sum = np.zeros((nnodes, ncomp), dtype=cel_flat.dtype)\n    weight_sum = np.zeros(nnodes, dtype=cel_flat.dtype)\n\n    contrib = cel_flat * w[:, None]  # (nels, ncomp)\n    for j in range(3):\n        idx = elements[:, j]\n        np.add.at(point_sum, idx, contrib)\n        np.add.at(weight_sum, idx, w)\n\n    point_flat = point_sum / (weight_sum[:, None] + eps)\n    return point_flat.reshape((nnodes,) + trailing_shape)\n\n\ndef stress(u: Array) -&gt; Array:\n    \"\"\"Computes the stress respecting the two separate materials.\"\"\"\n    grad_u = op.grad(u).squeeze()\n    eps = compute_strain(grad_u)\n    sig_1 = compute_stress(eps, mat_matrix.mu, mat_matrix.lmbda)\n    sig_2 = compute_stress(eps, mat_inclusion.mu, mat_inclusion.lmbda)\n    mask = jnp.isin(op.mesh.elements, mesh_inclusion.elements).all(axis=1)  # (nels,)\n    sig = jnp.where(mask[:, None, None], sig_2, sig_1)\n    return sig\n\n\ndef von_mises_2d(sig: Array) -&gt; Array:\n    sxx = sig[..., 0, 0]\n    syy = sig[..., 1, 1]\n    sxy = sig[..., 0, 1]\n    return jnp.sqrt(sxx**2 - sxx * syy + syy**2 + 3 * sxy**2)\n</code></pre> Matplotlib settings for plotting <pre><code>plt.rcParams.update(\n    {\n        \"text.usetex\": True,\n        \"text.latex.preamble\": r\"\\usepackage{amsmath}\",\n        \"grid.color\": \"grey\",\n        \"grid.linestyle\": \"solid\",\n        \"grid.linewidth\": 0.25,\n        \"grid.alpha\": 0.2,\n        \"figure.dpi\": 200,\n    }\n)\n</code></pre> <pre><code>fig, axes = plt.subplots(1, 3, figsize=(7.1, 2.2), sharey=True)\n\nsig_vm_min = np.inf\nsig_vm_max = -np.inf\n\nfor res in results:\n    sig = stress(res.u)\n    sig_vm = von_mises_2d(sig)\n    sig_vm_min = min(sig_vm_min, jnp.min(sig_vm))\n    sig_vm_max = max(sig_vm_max, jnp.max(sig_vm))\n\nfor i, (ax, res) in enumerate(zip(axes, results)):\n    ax: plt.Axes\n    x = mesh.coords + res.u\n    tri = Triangulation(x[:, 0], x[:, 1], triangles=np.array(mesh.elements))\n    sig = stress(res.u)\n    sig_vm = von_mises_2d(sig)\n\n    m = ax.tripcolor(tri, facecolors=sig_vm, cmap=\"managua\", rasterized=True)\n    ax.set_aspect(\"equal\", adjustable=\"datalim\")\n    # keep axes size consistent\n    ax.set_ylim(-0.1 * Ly, Ly * 1.6)\n    ax.grid()\n    ax.set_xlabel(\"$x$ [mm]\")\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.annotate(\n        r\"$$\\langle\\varepsilon\\rangle = \\begin{bmatrix}\"\n        + f\"{res.eps_hat[0, 0]:.2f} &amp; {res.eps_hat[0, 1]:.2f} \\\\\\\\ \"\n        + f\"{res.eps_hat[1, 0]:.2f} &amp; {res.eps_hat[1, 1]:.2f} \"\n        + r\"\\end{bmatrix}$$\",\n        xy=(0.5, 0.89),\n        ha=\"center\",\n        va=\"bottom\",\n        xycoords=\"axes fraction\",\n    )\n\naxes[0].set(ylabel=\"$y$ [mm]\")\ncax = fig.add_axes((1.0, 0.3, 0.01, 0.4))\nsm = ScalarMappable(Normalize(vmin=0, vmax=1), cmap=\"managua\")\ncb = fig.colorbar(sm, cax=cax, orientation=\"vertical\", pad=0.1)\ncb.set_ticks([0, 1])\ncb.set_ticklabels((r\"$\\sigma_{{VM}}^{{min}}$\", r\"$\\sigma_{{VM}}^{{max}}$\"))\n\nplt.tight_layout()\n</code></pre> <pre><code>/tmp/ipykernel_98198/2498942156.py:45: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  plt.tight_layout()\n</code></pre>"},{"location":"examples/homogenization_periodic/#compute-homogenized-stiffness-tensor","title":"Compute homogenized stiffness tensor","text":"<p>From each solved microfield, we compute element stresses and average them over the cell:</p> \\[ \\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\mathcal{A}|}\\int_{\\mathcal{A}} \\boldsymbol{\\sigma}\\,dA. \\] <p>The homogenized tangent in Voigt form is obtained by automatic differentiation of \\(\\langle\\boldsymbol{\\sigma}\\rangle(\\hat{\\boldsymbol{\\varepsilon}})\\):</p> \\[ \\mathbf{C}^{\\text{hom}} = \\frac{\\partial\\langle\\boldsymbol{\\sigma}\\rangle}{\\partial\\hat{\\boldsymbol{\\varepsilon}}}. \\] <p>Note</p> <p>Unfortunately, the sparse solver of <code>jax</code> is not differentiable yet. Therefore, we use a dense direct solver for this part of the example.</p> <pre><code>jacobian_dense = jax.jacfwd(residual)\n\n\ndef func(eps_hat_voigt: Array) -&gt; Array:\n    \"\"\"Returns the average stress for a given macroscopic strain eps_hat (in Voigt notation).\"\"\"\n    eps_hat = jnp.array(\n        [[eps_hat_voigt[0], eps_hat_voigt[2]], [eps_hat_voigt[2], eps_hat_voigt[1]]]\n    )\n    v = jnp.linalg.solve(jacobian_dense(v0, eps_hat), -residual(v0, eps_hat))\n    u = (eps_hat @ mesh.coords.T).T + SolutionLM(lifter.lift_from_zeros(v)).u\n    sig = stress(u)\n    sig = jnp.mean(sig, axis=0)  # average stress\n    return jnp.array([sig[0, 0], sig[1, 1], sig[0, 1]])\n\n\nC_hom = jax.jacfwd(func)(jnp.ones(3))\n</code></pre> <pre><code>print(\"Homogenized stiffness tensor (Voigt notation):\")\nwith np.printoptions(precision=2):\n    print(C_hom)\n</code></pre> <pre><code>Homogenized stiffness tensor (Voigt notation):\n[[6.58e+04 1.75e+04 8.28e+01]\n [1.75e+04 6.57e+04 1.44e+02]\n [5.57e+01 8.66e+01 4.82e+04]]\n</code></pre>"},{"location":"examples/homogenization_periodic/#pbcs-through-condensation","title":"PBCs through condensation","text":"<p>We create a <code>Compound</code> subclass with one field: - \\(\\mathbf{u}\\): the periodic displacement fluctuation field <code>(n_nodes, 2)</code></p> <p><code>Lifter</code> enforces constraints in reduced coordinates. We define:</p> <ul> <li><code>PeriodicMap(slave, master)</code> for periodic DOF ties</li> <li>one <code>DirichletBC</code> at a corner to remove rigid-body translation</li> </ul> <p>Then the solver unknown is only the free DOF vector \\(\\mathbf{v}\\), while <code>lifter.lift_from_zeros(v)</code> reconstructs the full constrained field.</p> <pre><code>from tatva.sparse import reduce_sparsity_pattern\nfrom tatva.lifter import PeriodicMap, Lifter, DirichletBC\nfrom tatva.sparse._extraction import create_sparsity_pattern_master_slave\n\n\nclass Solution(compound.Compound):\n    u = compound.field(mesh.coords.shape)\n\n\nperiodic_map = jnp.concatenate(\n    [\n        jnp.array([Solution.u[nodes, :] for nodes in left_right.T]).T,\n        jnp.array([Solution.u[nodes, :] for nodes in bottom_top.T]).T,\n        jnp.array([Solution.u[nodes, :] for nodes in corner_map.T]).T,\n    ]\n)\n\nlifter = Lifter(\n    Solution.size,\n    DirichletBC(Solution.u[[corner_m[0]]]),\n    PeriodicMap(periodic_map[:, 1], periodic_map[:, 0]),\n)\n\nsparsity = create_sparsity_pattern_master_slave(\n    mesh,\n    2,\n    jnp.arange(Solution.size)\n    .at[Solution.u[[corner_m[0]]]]\n    .set(-1)\n    .at[periodic_map[:, 1]]\n    .set(periodic_map[:, 0]),\n)\n</code></pre>"},{"location":"examples/homogenization_periodic/#energy-functional","title":"Energy functional","text":"<p>The total cell energy is the sum of matrix and inclusion contributions:</p> \\[ \\Pi(\\mathbf{u};\\hat{\\boldsymbol{\\varepsilon}})=\\int_{\\mathcal{A}_m}\\psi_m\\,dA+\\int_{\\mathcal{A}_i}\\psi_i\\,dA. \\] <p>We minimize in reduced variables by composing with the lifter, \\(\\Pi_r(\\mathbf{v}) = \\Pi(\\text{lift}(\\mathbf{v}))\\).</p> <p><code>jax.jacrev</code> gives the residual, and <code>jax.jvp</code> defines the Jacobian-Vector-Product function.</p> <pre><code>from typing import Callable\nimport scipy.sparse as sp\nfrom tatva import sparse\n\n\ndef total_energy(u_flat: Array, eps_hat: Array) -&gt; Array:\n    (u,) = Solution(u_flat)\n    # Inclusion gets Material 2, Matrix gets Material 1\n    e_inclusion = op_inclusion.integrate(\n        strain_energy(\n            op_inclusion.grad(u), eps_hat, mat_inclusion.mu, mat_inclusion.lmbda\n        )\n    )\n    e_matrix = op_matrix.integrate(\n        strain_energy(op_matrix.grad(u), eps_hat, mat_matrix.mu, mat_matrix.lmbda)\n    )\n    return e_inclusion + e_matrix\n\n\ndef lagrangian(u_free: Array, eps_hat: Array) -&gt; Array:\n    u_full = lifter.lift_from_zeros(u_free)\n    return total_energy(u_full, eps_hat)\n\n\nresidual = jax.jacrev(lagrangian)\n\n\ndef jvp(loc: Array, eps_hat: Array) -&gt; Callable[[Array], Array]:\n    def _jvp_fn(v: Array) -&gt; Array:\n        return jax.jvp(residual, (loc, eps_hat), (v, jnp.zeros_like(eps_hat)))[1]\n\n    return _jvp_fn\n</code></pre>"},{"location":"examples/homogenization_periodic/#solve-for-unit-strains_1","title":"Solve for unit strains","text":"<p>We solve three independent 2D strain load cases (Voigt basis):</p> <ul> <li>\\(\\varepsilon_{xx}=1\\)</li> <li>\\(\\varepsilon_{yy}=1\\)</li> <li>\\(\\varepsilon_{xy}=1\\) (implemented with symmetric \\(0.5\\) off-diagonals)</li> </ul> <p>For each case, we solve the linearized equilibrium for fluctuation DOFs, then reconstruct</p> \\[ \\boldsymbol{u}(\\boldsymbol{y}) = \\hat{\\boldsymbol{\\varepsilon}}\\,\\boldsymbol{y} + \\tilde{\\boldsymbol{u}}(\\boldsymbol{y}). \\] <pre><code>from dataclasses import dataclass\n\nimport jax.experimental.sparse as jsparse\n\n\n@dataclass\nclass Result:\n    u: NDArray\n    eps_hat: NDArray\n\n\nv0 = jnp.zeros(lifter.size_reduced)\n\nscale = 0.3\neps_hat_list = scale * jnp.array(\n    [\n        [[1.0, 0.0], [0.0, 0.0]],\n        [[0.0, 0.0], [0.0, 1.0]],\n        [[0.0, 0.5], [0.5, 0.0]],\n    ]\n)  # unit strain tensors\n\nresults = []\n\nfor eps_hat in eps_hat_list:\n    v = jax.scipy.sparse.linalg.cg(jvp(v0, eps_hat), -residual(v0, eps_hat))[0]\n    u0 = (eps_hat @ mesh.coords.T).T\n    u = u0 + Solution(lifter.lift_from_zeros(v)).u\n    results.append(Result(u=u, eps_hat=eps_hat))\n</code></pre>"},{"location":"examples/homogenization_periodic/#results_1","title":"Results","text":"<pre><code>fig, axes = plt.subplots(1, 3, figsize=(7.1, 2.2), sharey=True)\n\nsig_vm_min = np.inf\nsig_vm_max = -np.inf\n\nfor res in results:\n    sig = stress(res.u)\n    sig_vm = von_mises_2d(sig)\n    sig_vm_min = min(sig_vm_min, jnp.min(sig_vm))\n    sig_vm_max = max(sig_vm_max, jnp.max(sig_vm))\n\nfor i, (ax, res) in enumerate(zip(axes, results)):\n    ax: plt.Axes\n    x = mesh.coords + res.u\n    tri = Triangulation(x[:, 0], x[:, 1], triangles=np.array(mesh.elements))\n    sig = stress(res.u)\n    sig_vm = von_mises_2d(sig)\n\n    m = ax.tripcolor(tri, facecolors=sig_vm, cmap=\"managua\", rasterized=True)\n    ax.set_aspect(\"equal\", adjustable=\"datalim\")\n    # keep axes size consistent\n    ax.set_ylim(-0.1 * Ly, Ly * 1.6)\n    ax.grid()\n    ax.set_xlabel(\"$x$ [mm]\")\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.annotate(\n        r\"$$\\langle\\varepsilon\\rangle = \\begin{bmatrix}\"\n        + f\"{res.eps_hat[0, 0]:.2f} &amp; {res.eps_hat[0, 1]:.2f} \\\\\\\\ \"\n        + f\"{res.eps_hat[1, 0]:.2f} &amp; {res.eps_hat[1, 1]:.2f} \"\n        + r\"\\end{bmatrix}$$\",\n        xy=(0.5, 0.89),\n        ha=\"center\",\n        va=\"bottom\",\n        xycoords=\"axes fraction\",\n    )\n\naxes[0].set(ylabel=\"$y$ [mm]\")\ncax = fig.add_axes((1.0, 0.3, 0.01, 0.4))\nsm = ScalarMappable(Normalize(vmin=0, vmax=1), cmap=\"managua\")\ncb = fig.colorbar(sm, cax=cax, orientation=\"vertical\", pad=0.1)\ncb.set_ticks([0, 1])\ncb.set_ticklabels((r\"$\\sigma_{{VM}}^{{min}}$\", r\"$\\sigma_{{VM}}^{{max}}$\"))\n\nplt.tight_layout()\n</code></pre> <pre><code>/tmp/ipykernel_98198/830935014.py:45: UserWarning: This figure includes Axes that are not compatible with tight_layout, so results might be incorrect.\n  plt.tight_layout()\n</code></pre>"},{"location":"examples/homogenization_periodic/#compute-homogenized-stiffness-tensor_1","title":"Compute homogenized stiffness tensor","text":"<p>From each solved microfield, we compute element stresses and average them over the cell:</p> \\[ \\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\mathcal{A}|}\\int_{\\mathcal{A}} \\boldsymbol{\\sigma}\\,dA. \\] <p>The homogenized tangent in Voigt form is obtained by automatic differentiation of \\(\\langle\\boldsymbol{\\sigma}\\rangle(\\hat{\\boldsymbol{\\varepsilon}})\\):</p> \\[ \\mathbf{C}^{\\text{hom}} = \\frac{\\partial\\langle\\boldsymbol{\\sigma}\\rangle}{\\partial\\hat{\\boldsymbol{\\varepsilon}}}. \\] <pre><code>def func(eps_hat_voigt: Array) -&gt; Array:\n    eps_hat = jnp.array(\n        [[eps_hat_voigt[0], eps_hat_voigt[2]], [eps_hat_voigt[2], eps_hat_voigt[1]]]\n    )\n    v = jax.scipy.sparse.linalg.cg(jvp(v0, eps_hat), -residual(v0, eps_hat))[0]\n    u = (eps_hat @ mesh.coords.T).T + Solution(lifter.lift_from_zeros(v)).u\n    sig = stress(u)\n    sig = jnp.mean(sig, axis=0)  # average stress\n    return jnp.array([sig[0, 0], sig[1, 1], sig[0, 1]])\n\n\nC_hom = jax.jacfwd(func)(jnp.ones(3))\n</code></pre> <pre><code>print(\"Homogenized stiffness tensor (Voigt notation):\")\nwith np.printoptions(precision=2):\n    print(C_hom)\n</code></pre> <pre><code>Homogenized stiffness tensor (Voigt notation):\n[[6.58e+04 1.75e+04 8.28e+01]\n [1.75e+04 6.57e+04 1.44e+02]\n [5.57e+01 8.66e+01 4.82e+04]]\n</code></pre>"},{"location":"examples/linear_elasticity/","title":"Elasticity","text":""},{"location":"examples/linear_elasticity/#elasticity","title":"Elasticity","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\n</code></pre> <pre><code>from typing import NamedTuple\n\nimport gmsh\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nimport jax.numpy as jnp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator\n</code></pre> <p>In this notebook, we solve a linear elastic problem where the boundary conditions are enforced via condensation. The example consists of a plate with a circular hole at its center being subjected to a uniaxial tension. Owing to symmetry, we model only one half of the domain, with symmetry boundary conditions imposed along the left edge. A prescribed traction is applied on the right boundary of the plate.</p> <p>The problem can be formulated as the minimization of the total potential energy subject to kinematic constraints,</p> \\[\\begin{gather}     \\Psi(\\boldsymbol{u})      = \\int_{\\Omega} \\psi_\\varepsilon\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\right)\\,\\mathrm{d}\\Omega     - \\int_{\\mathrm{S}_t} \\boldsymbol{t} \\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Gamma ~, \\\\     \\boldsymbol{u}_x = \\mathbf{0} \\quad \\text{on } \\mathrm{S}_{D} ~,  \\notag \\end{gather}\\] Code for generating a plate with a hole and plotting the mesh <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.axes import Axes\n\n\ndef extract_physical_groups(tag_map: dict) -&gt; dict[str, np.ndarray]:\n    print(\"Extracting physical groups from Gmsh model...\")\n    physical_surfaces: dict[str, np.ndarray] = {}\n\n    for dim, pg_tag in gmsh.model.getPhysicalGroups(dim=1):\n        name = gmsh.model.getPhysicalName(dim, pg_tag)\n\n        # Entities (surface tags) that belong to this physical group\n        entities = gmsh.model.getEntitiesForPhysicalGroup(dim, pg_tag)\n\n        els = []\n        for ent in entities:\n            # Get all mesh elements on this surface entity\n            types, _, node_tags_by_type = gmsh.model.mesh.getElements(dim, ent)\n\n            for etype, ntags in zip(types, node_tags_by_type):\n                nodes = np.array(ntags, dtype=np.int64).reshape(-1, etype + 1)\n                els.append(nodes)\n\n        if not els:\n            physical_surfaces[name] = np.zeros((0, 2), dtype=np.int32)\n            continue\n\n        group_els = np.vstack(els, dtype=np.int32)\n        group_els = np.array(\n            [[tag_map[t] for t in tri] for tri in group_els], dtype=np.int32\n        )\n        physical_surfaces[name] = group_els\n\n    return physical_surfaces\n\n\ndef plot_mesh(mesh: Mesh, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.tripcolor(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        facecolors=np.ones(len(mesh.elements)),\n        cmap=\"managua\",\n        edgecolors=\"k\",\n        linewidth=0.2,\n    )\n    ax.margins(0, 0)\n    ax.set_aspect(\"equal\")\n\n\ndef generate_plate(length: float, height: float, hole_radius: float) -&gt; Mesh:\n    y0, y1 = 0 - height / 2, height / 2\n    x0, x1 = 0.0, length\n    gmsh.initialize()\n    gmsh.model.add(\"plate_with_hole\")\n    occ = gmsh.model.occ\n\n    # Define the geometry\n    p1 = occ.addPoint(x0, y0, 0)\n    p2 = occ.addPoint(x1, y0, 0)\n    p3 = occ.addPoint(x1, y1, 0)\n    p4 = occ.addPoint(x0, y1, 0)\n\n    c1 = occ.addPoint(0, -hole_radius, 0)\n    c2 = occ.addPoint(0, hole_radius, 0)\n    cmid = occ.addPoint(0, 0, 0)\n    c_hole = occ.add_circle_arc(c2, cmid, c1)\n\n    l1 = occ.addLine(p1, p2)\n    l2 = occ.addLine(p2, p3)\n    l3 = occ.addLine(p3, p4)\n    l4 = occ.addLine(p4, c2)\n    l5 = c_hole\n    l6 = occ.addLine(c1, p1)\n\n    cl = occ.addCurveLoop([l1, l2, l3, l4, l5, l6])\n    surface = gmsh.model.occ.addPlaneSurface([cl])\n\n    gmsh.model.occ.synchronize()\n\n    # Refine along the hole boundary\n    base_size = min(length, height) / 50\n    fine_size = base_size / 3\n    base_size = base_size * 1\n    dist_field = gmsh.model.mesh.field.add(\"Distance\")\n    gmsh.model.mesh.field.setNumbers(dist_field, \"CurvesList\", [c_hole])\n    thresh_field = gmsh.model.mesh.field.add(\"Threshold\")\n    gmsh.model.mesh.field.setNumber(thresh_field, \"InField\", dist_field)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"SizeMin\", fine_size)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"SizeMax\", base_size)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"DistMin\", hole_radius * 0.25)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"DistMax\", hole_radius * 3)\n    gmsh.model.mesh.field.setAsBackgroundMesh(thresh_field)\n\n    # Mesh the geometry\n    gmsh.model.mesh.generate(2)\n\n    gmsh.model.addPhysicalGroup(2, [surface], 2, \"plate_surface\")\n    gmsh.model.addPhysicalGroup(1, [c_hole], 1, \"hole_boundary\")\n    gmsh.model.addPhysicalGroup(1, [l4, l6], 3, \"left_edge\")\n    gmsh.model.addPhysicalGroup(1, [l2], 4, \"right_edge\")\n    gmsh.model.addPhysicalGroup(1, [l1], 5, \"bottom_edge\")\n    gmsh.model.addPhysicalGroup(1, [l3], 6, \"top_edge\")\n\n    # Extract nodes and elements\n    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()\n    tag_map = {tag: i for i, tag in enumerate(node_tags)}\n    nodes = jnp.array(node_coords).reshape(-1, 3)[:, :2]\n\n    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)\n    elements = jnp.array(elem_node_tags[0]).reshape(-1, 3) - 1\n\n    pg = extract_physical_groups(tag_map)\n    gmsh.finalize()\n    return Mesh(nodes, elements=elements), pg\n</code></pre> <pre><code>lx = 1.0\nly = 2.0\nr = 0.05\nmesh, physical_groups = generate_plate(lx, ly, r)\nn_dofs_per_node = 2\nn_dofs = mesh.coords.shape[0] * n_dofs_per_node\n\nplot_mesh(mesh)\n</code></pre> <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Circle)\nInfo    : [ 20%] Meshing curve 2 (Line)\nInfo    : [ 40%] Meshing curve 3 (Line)\nInfo    : [ 60%] Meshing curve 4 (Line)\nInfo    : [ 70%] Meshing curve 5 (Line)\nInfo    : [ 90%] Meshing curve 6 (Line)\nInfo    : Done meshing 1D (Wall 0.00395923s, CPU 0.00437s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.267427s, CPU 0.263482s)\nInfo    : 7395 nodes 14793 elements\nExtracting physical groups from Gmsh model...\n</code></pre> <p></p>"},{"location":"examples/linear_elasticity/#problem-setup","title":"Problem setup","text":"<p>We now define the <code>Operator</code> object that makes the mesh and the associated element type. In this example, we use 3-node triangular element <code>Tri3</code>.</p> <pre><code>from tatva.element import Tri3\n\nop = Operator(mesh, Tri3())\n</code></pre>"},{"location":"examples/linear_elasticity/#defining-energy-functional","title":"Defining energy functional","text":"<p>We now define the functions to compute the total strain energy which is mathematically is given as </p> \\[ \\int_{\\Omega} \\psi_\\varepsilon\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{u})\\right)\\,\\mathrm{d}\\Omega \\] <p>where </p> \\[ \\psi = \\dfrac{1}{2}\\sigma:\\varepsilon \\] <p>and  stress and strain is taken for a linear elastic material as</p> \\[ \\sigma = 2\\mu\\varepsilon + \\mathrm{tr}(\\varepsilon)\\mathbb{I}, \\quad \\varepsilon=\\dfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla\\boldsymbol{u}^\\mathrm{T}) \\] <p>Note</p> <p>To make the looping over each quadrature point computationally efficient, we make use of decorator <code>@autovmap</code> from <code>jax_autovmap</code> which is basically <code>jax.vmap</code> but create the vectorized mapping based on the dimension of the quantity.</p> <p>The <code>autovmap</code> function works as a python decorator that wraps a function and vectorizes it. The <code>autovmap</code> function takes input as the dimension of the variables passed to the function. The different dimensions of an input variable are defined as follows:</p> <pre><code>- `0`: scalar (for example, material properties)\n- `1`: vector (for example, a displacement field or any vector with one index)\n- `2`: tensor (for example, a strain tensor, stress tensor or any matrix with two indices)\n</code></pre> <p>In this example, we want to compute stress from strain given as</p> \\[ \\sigma = 2\\mu \\epsilon + \\lambda \\text{tr}(\\epsilon) \\mathbb{I} \\] <p>where \\(\\sigma\\) is the stress tensor, \\(\\epsilon\\) is the strain tensor, \\(\\mu\\) is the shear modulus, \\(\\lambda\\) is the Lame parameter, and \\(\\mathbb{I}\\) is the identity tensor. The term \\(\\text{tr}(\\epsilon)\\) is the trace of the strain tensor. Then we can define our function as</p> <pre><code>@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n</code></pre> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  \n    lmbda: float\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat = Material.from_youngs_poisson_2d(1, 0.3)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy_density(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n\n@jax.jit\ndef total_energy_full(u_flat: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat.reshape(-1, 2)\n    u_grad = op.grad(u)\n    e_density = strain_energy_density(u_grad, mat.mu, mat.lmbda)\n    return op.integrate(e_density)\n</code></pre>"},{"location":"examples/linear_elasticity/#enforcing-boundary-condition-via-static-condensation","title":"Enforcing boundary condition via static condensation","text":"<p>The boundary conditions are enforced via static condensation.  Instead of modifying an assembled linear system, for example, via row/column operations or direct elimination of constrained DoFs, we define a reduced functional that depends only on the free degrees of freedom. The reduced displacement vector is lifted to the full field by inserting the prescribed values at constrained locations before evaluating the total energy.</p> <p>We first locate the DoFs associated to the left and right boundaries and store them as <code>fixed_dofs</code> and <code>free_dofs</code>. </p> <pre><code>boundary_left = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nboundary_right = jnp.where(jnp.isclose(mesh.coords[:, 0], lx))[0]\npoint_at_y_0 = jnp.where(\n    jnp.isclose(mesh.coords[:, 0], lx) &amp; jnp.isclose(mesh.coords[:, 1], 0.0)\n)[0][0]\nassert point_at_y_0\n\nfixed_dofs = jnp.concatenate(\n    [boundary_left * n_dofs_per_node, jnp.array([point_at_y_0 * n_dofs_per_node + 1])]\n)\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre> <pre><code>@jax.jit\ndef total_energy(u_free: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = jnp.zeros(n_dofs).at[free_dofs].set(u_free)\n    return total_energy_full(u_full)\n\n\nresidual_full = jax.jacrev(total_energy_full)\nresidual = jax.jacrev(total_energy)\n</code></pre>"},{"location":"examples/linear_elasticity/#defining-the-loading-traction-on-right-edge","title":"Defining the loading traction on right edge","text":"<p>We define a new <code>Operator</code> consisting of line elements along the right edge and then use this <code>op_line</code> to integrate the traction along the nodes.</p> <pre><code>from tatva.element.base import Line2\n\nsig_loading = 1e-2\n\nop_line = Operator(Mesh(mesh.coords, elements=physical_groups[\"right_edge\"]), Line2())\nnodal_area = jax.jacrev(op_line.integrate)(jnp.ones(mesh.coords.shape[0]))\nf_ext_0 = jnp.zeros(n_dofs)\n\nidx_right = n_dofs_per_node * boundary_right\n\nf_ext_0 = f_ext_0.at[idx_right].add(sig_loading * nodal_area[boundary_right])\nf_ext = f_ext_0.at[free_dofs].get()\n</code></pre> <p>Now let us define the function that we want to set to <code>0</code> i.e. $$ \\boldsymbol{f} = \\boldsymbol{f}\\text{ext} - \\boldsymbol{f}\\text{int} $$</p> <p>and using this function, we can define the Jacobian-vector product</p> \\[ \\Delta f = \\frac{\\partial f}{\\partial u}\\Delta u \\] <pre><code>@jax.jit\ndef fn(u_free: Array) -&gt; Array:\n    res = residual(u_free)\n    return f_ext - res\n\n@jax.jit\ndef compute_tangent(du, u_prev):\n    tangent = jax.jvp(fn, (u_prev,), (du,))[1]\n    return tangent\n</code></pre> Newton-Krylov solver <pre><code>import time\nfrom functools import partial\n\n\n@partial(jax.jit, static_argnames=[\"gradient\",\"compute_tangent\"])\ndef newton_krylov_solver(\n    u,\n    gradient,\n    compute_tangent,\n):\n    residual = gradient(u)\n    norm_res = jnp.linalg.norm(residual)\n\n    init_val = (u, 0, norm_res)\n\n    def cond_fun(state):\n        u, iiter, norm_res = state\n        return jnp.logical_and(norm_res &gt; 1e-8, iiter &lt; 10)\n\n    def body_fun(state):\n        u, iiter, norm_res = state\n        residual = gradient(u)\n\n        start_time = time.time()\n        A = jax.jit(partial(compute_tangent, u_prev=u))\n        end_time = time.time()\n        jax.debug.print(\"  Assembling tangent matrix time: {time:.2f} s\", time=end_time - start_time)\n\n        start_time = time.time()\n        du, _ = jax.scipy.sparse.linalg.cg(A=A, b=-residual)\n        end_time = time.time()\n        jax.debug.print(\"  CG solve time: {time:.2f} s\", time=end_time - start_time)\n\n        u = u + du\n\n        start_time = time.time()\n        residual = gradient(u)\n        end_time = time.time()\n        jax.debug.print(\"  Residual evaluation time: {time:.2f} s\", time=end_time - start_time)\n        norm_res = jnp.linalg.norm(residual)\n\n        return (u, iiter + 1, norm_res)\n\n    final_u, final_iiter, final_norm = jax.lax.while_loop(cond_fun, body_fun, init_val)\n    jax.debug.print(\"  Residual: {res:.2e}\", res=final_norm)\n\n    return final_u, final_norm\n</code></pre> <p>We now solve the system for the applied traction</p> <pre><code>u_sol, norm_res = newton_krylov_solver(\n    u=jnp.zeros_like(f_ext),\n    gradient=fn,\n    compute_tangent=compute_tangent,\n)\n</code></pre> <pre><code>Assembling tangent matrix time: 0.00 s\n  Residual evaluation time: 0.00 s\n  CG solve time: 0.05 s\n  Residual evaluation time: 0.00 s\n  Assembling tangent matrix time: 0.00 s\n  CG solve time: 0.05 s\n  Residual: 1.91e-13\n</code></pre>"},{"location":"examples/linear_elasticity/#visualization-and-analyzing-the-results","title":"Visualization and analyzing the results","text":"<pre><code>def stress_cartesian_to_polar(\n    sig: np.ndarray | Array, x: np.ndarray | Array\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Convert 2D Cartesian stress to polar components at points x.\n\n    sig: (..., 2, 2) stress tensor at each point.\n    x:   (..., 2) coordinates (origin at 0,0).\n    returns: (sig_rr, sig_tt, sig_rt) with shape (...,)\n    \"\"\"\n    x = np.asarray(x)\n    sig = np.asarray(sig)\n    theta = np.arctan2(x[..., 1], x[..., 0])\n    c = np.cos(theta)\n    s = np.sin(theta)\n    rot = np.stack([np.stack([c, s], axis=-1), np.stack([-s, c], axis=-1)], axis=-2)\n    sig_rt = np.einsum(\"...ik,...kl,...jl-&gt;...ij\", rot, sig, rot)\n    return sig_rt[..., 0, 0], sig_rt[..., 1, 1], sig_rt[..., 0, 1]\n</code></pre> Plot stress components along lines at different angles from the hole center <pre><code>from typing import Literal\n\nimport pyvista as pv\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.lines import Line2D\nfrom matplotlib.tri import Triangulation\n\nEPS = 1e-8\n\n\n\nu = jnp.zeros(n_dofs).at[free_dofs].set(u_sol)\nu = u.reshape(-1, 2)\n\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\nsig = compute_stress(compute_strain(op.grad(u)), mat.mu, mat.lmbda).squeeze()\nsig_rr, sig_tt, sig_rt = stress_cartesian_to_polar(sig, op.eval(x_final).squeeze())\n\ndef plot_field(ax: Axes):\n    cb = ax.tripcolor(tri, sig_rr, alpha=0.95, rasterized=True, cmap=\"managua\")\n    ax.set_aspect(\"equal\")\n\n    edge_elems = jnp.concatenate(\n        (\n            physical_groups[\"hole_boundary\"],\n            physical_groups[\"left_edge\"],\n            physical_groups[\"right_edge\"],\n            physical_groups[\"bottom_edge\"],\n            physical_groups[\"top_edge\"],\n        )\n    )\n    segments = mesh.coords[edge_elems][:, :, :2]\n    coll_boundary = LineCollection(\n        segments + u[edge_elems][:, :, :2], colors=\"k\", linewidths=0.5\n    )\n    ax.add_collection(coll_boundary)\n\n    ax.set(\n        xlabel=\"$x$\",\n        ylabel=\"$y$\",\n    )\n    return cb\n\n\n\ndef get_pv_grid(mesh: Mesh) -&gt; pv.UnstructuredGrid:\n    \"\"\"Convert Tatva mesh to PyVista UnstructuredGrid.\"\"\"\n    if mesh.coords.shape[1] == 2:\n        pv_points = np.hstack((mesh.coords, np.zeros(shape=(mesh.coords.shape[0], 1))))\n    else:\n        pv_points = np.array(mesh.coords)\n    cells = np.hstack(\n        [\n            np.full((mesh.elements.shape[0], 1), 3, dtype=np.int64),\n            np.array(mesh.elements, dtype=np.int64),\n        ]\n    )\n    grid = pv.UnstructuredGrid(\n        cells, np.full(mesh.elements.shape[0], pv.CellType.TRIANGLE), pv_points\n    )\n    return grid\n\n\ndef kirsch_sig(\n    component: Literal[\"rr\", \"tt\", \"rt\"],\n    load_sig: float,\n    r: float,\n    theta: float,\n    a: float,\n) -&gt; Array:\n    if component == \"rr\":\n        return (\n            0.5\n            * load_sig\n            * (\n                (1 - a**2 / r**2)\n                + (1 + 3 * np.power(a, 4) / np.power(r, 4) - 4 * a**2 / r**2)\n                * np.cos(2 * theta)\n            )\n        )\n    elif component == \"tt\":\n        return (\n            0.5\n            * load_sig\n            * (\n                (1 + a**2 / r**2)\n                - (1 + 3 * np.power(a, 4) / np.power(r, 4)) * np.cos(2 * theta)\n            )\n        )\n    elif component == \"rt\":\n        return (\n            -0.5\n            * load_sig\n            * (\n                (1 - 3 * np.power(a, 4) / np.power(r, 4) + 2 * a**2 / r**2)\n                * np.sin(2 * theta)\n            )\n        )\n    else:\n        raise ValueError(f\"Unknown component: {component}\")\n\n\ngrid = get_pv_grid(mesh)\ngrid[\"sig_rr\"] = sig_rr\ngrid[\"sig_tt\"] = sig_tt\ngrid[\"sig_rt\"] = sig_rt\ngrid: pv.UnstructuredGrid = grid.cell_data_to_point_data()\n\n\ndef get_sig_data_along_line(\n    r: float, lx: float, theta: float\n) -&gt; tuple[Array, dict[str, Array]]:\n    sample = grid.sample_over_line(\n        (r * np.cos(theta), r * np.sin(theta), 0.0),\n        (lx * np.cos(theta), lx * np.sin(theta), 0.0),\n        resolution=200,\n    )\n    sig_data = {}\n    dist = np.hypot(sample.points[:, 0], sample.points[:, 1])\n    idx_sort = np.argsort(dist)\n    ri_data, sig_data[\"rr\"], sig_data[\"tt\"], sig_data[\"rt\"] = (\n        dist[idx_sort],\n        sample[\"sig_rr\"][idx_sort],\n        sample[\"sig_tt\"][idx_sort],\n        sample[\"sig_rt\"][idx_sort],\n    )\n    return ri_data, sig_data\n\n\nfig = plt.figure(figsize=(8.4, 3.4))\ngs = fig.add_gridspec(\n    1, 3, width_ratios=[0.8, 1.2, 1.2], wspace=0.4, left=0.05, right=0.95, bottom=0.15, top=0.85\n)\naxes: list[Axes] = gs.subplots()\n\nri = np.linspace(r, 1, 100)\n\n\ndef plot_stress_component(ax: Axes, theta: float) -&gt; None:\n    color_iter = iter(plt.rcParams[\"axes.prop_cycle\"])\n    for comp in [\"rr\", \"tt\", \"rt\"]:\n        ri_data, sig_data = get_sig_data_along_line(r, lx, theta=theta)\n        c = next(color_iter)[\"color\"]\n        label = comp\n        if comp == \"tt\":\n            label = \"\\\\theta\\\\theta\"\n        elif comp == \"rt\":\n            label = \"r\\\\theta\"\n        ax.plot(\n            ri_data,\n            sig_data[comp],\n            c=c,\n            label=rf\"$\\sigma_{{{label}}}$\",\n            alpha=0.8,\n        )\n        ax.plot(\n            ri,\n            kirsch_sig(comp, sig_loading, ri, theta, r),\n            c=c,\n            ls=\":\",\n            lw=1.5,\n            # marker=\"o\",\n            # markersize=3,\n            # mec=\"w\",\n        )\n\n    ax.set(\n        xlabel=\"r\",\n        ylabel=r\"$\\sigma$\",\n        xlim=(0, 1),\n    )\n    ax.grid()\n    ax.axvline(r, color=\"k\", linestyle=\"--\", linewidth=0.7, alpha=0.5)\n    legend = ax.legend()\n    legend_elements = [\n        Line2D([0], [0], color=\"k\", linestyle=\":\", label=\"analytical\"),\n        Line2D([0], [0], color=\"k\", linestyle=\"-\", label=\"tatva\"),\n    ]\n    legend = ax.legend(\n        handles=[*legend.legend_handles, *legend_elements],\n        loc=\"lower right\",\n        # bbox_to_anchor=(1, 0.2),\n    )\n\n\nfor ax, theta, theta_str in zip(axes[1:], (0.0, np.pi / 4), (r\"0\", r\"\\frac{\\pi}{4}\")):\n    ax.annotate(\n        rf\"$\\theta={theta_str}$\",\n        xy=(0.3, 1.00),\n        xycoords=\"axes fraction\",\n        va=\"top\",\n        bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=\"none\"),\n    )\n    plot_stress_component(ax, theta=theta)\n    ax.set_xlim((0, 0.3))\n\nm = plot_field(axes[0])\ncax = fig.add_axes((0.1, 0.95, 0.15, 0.018))\ncb = plt.colorbar(\n    m,\n    cax=cax,\n    label=r\"$\\sigma_{rr}$\",\n    shrink=0.7,\n    pad=0.12,\n    orientation=\"horizontal\",\n)\ncb.ax.xaxis.set_label_position(\"top\")\n\n\nfor ax in axes[:]:\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n\nfor _ax in axes[1:]:\n    # set y-axis to scientific notation\n    _ax.yaxis.get_major_formatter().set_scientific(True)\n    _ax.yaxis.get_major_formatter().set_powerlimits((-2, 2))\n\n    # Draw a horizontal arrow from x=0 to x=r at y=0.95 of the y-axis\n    _ax.annotate(\n        \"\",\n        xy=(r, 0.8),\n        xytext=(0, 0.8),\n        xycoords=(\"data\", \"axes fraction\"),\n        arrowprops=dict(arrowstyle=\"&lt;-&gt;\", color=\"k\"),\n        annotation_clip=False,\n    )\n    _ax.annotate(\n        r\"$R$\",\n        xy=(r / 2, 0.8),\n        xytext=(0, 1),\n        textcoords=\"offset points\",\n        xycoords=(\"data\", \"axes fraction\"),\n        ha=\"center\",\n        va=\"bottom\",\n    )\n\nax = axes[0]\n# Draw a dashed line from the center to the outer boundary at theta=0\nax.plot([0, 1.1], [0, 0], linestyle=\"--\", color=\"k\", lw=0.7, alpha=0.5)\nax.annotate(\n    r\"$\\theta=0$\", xy=(0.6, 0.0), xytext=(0, 2), textcoords=\"offset points\", color=\"k\"\n)\nax.plot([0, 1.1], [0, 1.1], linestyle=\"--\", color=\"k\", lw=0.7, alpha=0.5)\nax.annotate(\n    r\"$\\theta=\\frac{\\pi}{4}$\",\n    xy=(1, 1),\n    xytext=(5, -2),\n    textcoords=\"offset points\",\n    color=\"k\",\n    va=\"top\",\n)\n\n\ndef subplot_label(ax, label, w_inches=-0.3, h_inches=0.08):\n    \"\"\"Add a label to a subplot.\n\n    Args:\n        ax: axis to add the label to\n        label: label to add\n        w_inches: width offset\n        h_inches: height offset\n    \"\"\"\n    w, h = ax.get_figure().get_size_inches()\n    ax.text(\n        w_inches / ax.get_position().width / w,\n        1 + h_inches / ax.get_position().height / h,\n        rf\"\\textbf{{{label})}}\",\n        transform=ax.transAxes,\n        va=\"bottom\",\n        # fontfamily=\"serif\",\n        fontweight=\"bold\",\n        # fontsize=\"large\",\n    )\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/ncm_metamaterial/","title":"Neural Constitutive Modeling","text":""},{"location":"examples/ncm_metamaterial/#neural-constitutive-modeling","title":"Neural Constitutive Modeling","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"\n\n    import pyvista as pv\n\n    pv.global_theme.jupyter_backend = 'static'\n    pv.global_theme.notebook = True\n    pv.start_xvfb()\n\n    print(\"Installation complete!\")\nelse:\n    import pyvista as pv\n    pv.global_theme.jupyter_backend = 'client'\n</code></pre> <p>In this example, we will implement a neural constitutive model. A neural constitutive model uses neural networks to represent the relationship between stress and strain in materials. This approach allows for more flexible and accurate modeling of complex material behaviors compared to traditional constitutive models.</p> <pre><code>import jax\n\njax.config.update(\"jax_persistent_cache_min_compile_time_secs\", 0)\njax.config.update(\"jax_enable_x64\", True)\n\nfrom functools import partial\n\nimport equinox as eqx\nimport jax.experimental.sparse as jsp\nimport jax.numpy as jnp\nimport numpy as np\nimport pyvista as pv\nimport scipy.sparse as sp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element, sparse\nfrom tatva_coloring import distance2_color_and_seeds\n</code></pre>"},{"location":"examples/ncm_metamaterial/#mesh","title":"Mesh","text":"<p>We start by defining the mesh and material properties for our simulation.</p> Gmsh Geometry Creation and Mesh object creation <pre><code>import gmsh\nimport meshio\n\ncells_x = 4          \ncells_y = 5          \nside_length = 1.0   \nwall_thickness = 0.15 \nheight = 1.0         \nlc = 0.2         \nfillet_radius = 0.6  # New: Radius for rounding the corners\n\ngmsh.initialize()\ngmsh.model.add(\"solid_honeycomb\")\nocc = gmsh.model.occ\n\nh_hex = side_length * np.sqrt(3) \n\ndx = 1.5 * side_length + (wall_thickness * np.sqrt(3)/2)\ndy = h_hex + wall_thickness\n\ntotal_w = (cells_x- 1) * dx + 2 * side_length + 2 * wall_thickness\ntotal_h = (cells_y) * dy + wall_thickness\n\n# Create the main block\nblock = occ.addBox(0.1*total_w, 0.1*total_h, 0, total_w, total_h, height)\n\npunches = []\n\nfor i in range(cells_x+1):\n    for j in range(cells_y+1):\n        cx = i * dx + side_length + wall_thickness\n        offset_y = (dy / 2) if (i % 2 != 0) else 0\n        cy = j * dy + (h_hex/2) + wall_thickness - offset_y\n\n        pts = []\n        for angle in range(0, 360, 60):\n            rad = np.radians(angle)\n            pts.append(occ.addPoint(cx + side_length * np.cos(rad), \n                                    cy + side_length * np.sin(rad), 0, lc))\n\n        lines = [occ.addLine(pts[k], pts[(k+1)%6]) for k in range(6)]\n        loop = occ.addCurveLoop(lines)\n        surf = occ.addPlaneSurface([loop])\n\n        # 2. Extrude to create the prism (Punch)\n        # extrude returns list of (dim, tag)\n        prism = occ.extrude([(2, surf)], 0, 0, height)\n        vol_tag = prism[1][1] # Get the tag of the 3D volume\n\n        # --- FILLET LOGIC START ---\n        # We need to find the 6 vertical edges of this new prism to fillet them.\n        occ.synchronize() # Must sync to query the new volume's edges\n\n        # Get all curves (edges) associated with the volume\n        # getBoundary returns list of (dim, tag)\n        edges = gmsh.model.getBoundary([(3, vol_tag)], combined=False, oriented=False, recursive=True)\n\n        vertical_edges = []\n        for e in edges:\n            dim, tag = e\n            if dim == 1: # Ensure it is a curve\n                xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(1, tag)\n\n                # Check if edge is vertical (aligned with Z)\n                z_len = abs(zmax - zmin)\n                x_len = abs(xmax - xmin)\n                y_len = abs(ymax - ymin)\n\n                if z_len &gt; 0.9 * height and x_len &lt; 1e-4 and y_len &lt; 1e-4:\n                    vertical_edges.append(tag)\n\n        if vertical_edges:\n            filleted_punches = occ.fillet([vol_tag], vertical_edges, fillet_radius)\n\n            punches.append((3, filleted_punches[0][1]))\n        else:\n            punches.append((3, vol_tag))\n\nocc.synchronize()\n\nout, _ = occ.cut([(3, block)], punches, removeTool=True)\nocc.synchronize()\n\nif out:\n    final_vols = [v[1] for v in out]\n    gmsh.model.addPhysicalGroup(3, final_vols, tag=100, name=\"Lattice_Material\")\n\ngmsh.option.setNumber(\"Mesh.Algorithm3D\", 1) # Delaunay\ngmsh.model.mesh.setSize(gmsh.model.getEntities(0), lc)\ngmsh.model.mesh.generate(3)\ngmsh.write(\"../meshes/honeycomb.msh\")\ngmsh.finalize()\n\n_mesh = meshio.read(\"../meshes/honeycomb.msh\")\n\npoints = _mesh.points\nz_points = points[:, 2].copy()  # Store z-coordinates\ny_points = points[:, 1].copy()  # Store y-coordinates\npoints[:, 1] = z_points \npoints[:, 2] = y_points\n\nif \"tetra\" in _mesh.cells_dict:\n    tetra_elements = _mesh.cells_dict[\"tetra\"]\n    print(f\"Successfully loaded {len(tetra_elements)} tetrahedrons.\")\nelse:\n    print(\"No tetrahedrons found. Ensure gmsh.model.mesh.generate(3) was called.\")\n\n\nmesh = Mesh(coords=points, elements=tetra_elements)\n</code></pre> Output <pre><code>Info    : Meshing 1D...ence                                                                                  \nInfo    : [  0%] Meshing curve 13 (Line)\nInfo    : [ 10%] Meshing curve 19 (Line)\nInfo    : [ 10%] Meshing curve 20 (Line)\nInfo    : [ 10%] Meshing curve 21 (Line)\nInfo    : [ 10%] Meshing curve 31 (Line)\nInfo    : [ 10%] Meshing curve 36 (Line)\nInfo    : [ 10%] Meshing curve 37 (Line)\nInfo    : [ 10%] Meshing curve 38 (Line)\nInfo    : [ 10%] Meshing curve 39 (Line)\nInfo    : [ 10%] Meshing curve 46 (Line)\nInfo    : [ 10%] Meshing curve 48 (Line)\nInfo    : [ 10%] Meshing curve 49 (Line)\nInfo    : [ 10%] Meshing curve 54 (Line)\nInfo    : [ 10%] Meshing curve 55 (Line)\nInfo    : [ 10%] Meshing curve 56 (Line)\nInfo    : [ 10%] Meshing curve 57 (Line)\nInfo    : [ 10%] Meshing curve 64 (Line)\nInfo    : [ 10%] Meshing curve 66 (Line)\nInfo    : [ 10%] Meshing curve 67 (Line)\nInfo    : [ 10%] Meshing curve 72 (Line)\nInfo    : [ 10%] Meshing curve 73 (Line)\nInfo    : [ 10%] Meshing curve 74 (Line)\nInfo    : [ 10%] Meshing curve 75 (Line)\nInfo    : [ 10%] Meshing curve 82 (Line)\nInfo    : [ 10%] Meshing curve 84 (Line)\nInfo    : [ 10%] Meshing curve 85 (Line)\nInfo    : [ 10%] Meshing curve 90 (Line)\nInfo    : [ 10%] Meshing curve 91 (Line)\nInfo    : [ 10%] Meshing curve 92 (Line)\nInfo    : [ 10%] Meshing curve 93 (Line)\nInfo    : [ 10%] Meshing curve 100 (Line)\nInfo    : [ 10%] Meshing curve 102 (Line)\nInfo    : [ 10%] Meshing curve 108 (Line)\nInfo    : [ 10%] Meshing curve 109 (Line)\nInfo    : [ 10%] Meshing curve 118 (Line)\nInfo    : [ 10%] Meshing curve 120 (Line)\nInfo    : [ 10%] Meshing curve 139 (Line)\nInfo    : [ 10%] Meshing curve 140 (Line)\nInfo    : [ 10%] Meshing curve 141 (Line)\nInfo    : [ 10%] Meshing curve 142 (Line)\nInfo    : [ 10%] Meshing curve 143 (Line)\nInfo    : [ 10%] Meshing curve 144 (Line)\nInfo    : [ 10%] Meshing curve 145 (Line)\nInfo    : [ 10%] Meshing curve 146 (Line)\nInfo    : [ 10%] Meshing curve 147 (Line)\nInfo    : [ 10%] Meshing curve 148 (Line)\nInfo    : [ 20%] Meshing curve 149 (Line)\nInfo    : [ 20%] Meshing curve 150 (Line)\nInfo    : [ 20%] Meshing curve 151 (Line)\nInfo    : [ 20%] Meshing curve 152 (Line)\nInfo    : [ 20%] Meshing curve 153 (Line)\nInfo    : [ 20%] Meshing curve 154 (Line)\nInfo    : [ 20%] Meshing curve 155 (Line)\nInfo    : [ 20%] Meshing curve 156 (Line)\nInfo    : [ 20%] Meshing curve 157 (Line)\nInfo    : [ 20%] Meshing curve 158 (Line)\nInfo    : [ 20%] Meshing curve 159 (Line)\nInfo    : [ 20%] Meshing curve 160 (Line)\nInfo    : [ 20%] Meshing curve 161 (Line)\nInfo    : [ 20%] Meshing curve 162 (Line)\nInfo    : [ 20%] Meshing curve 163 (Line)\nInfo    : [ 20%] Meshing curve 164 (Line)\nInfo    : [ 20%] Meshing curve 165 (Line)\nInfo    : [ 20%] Meshing curve 166 (Line)\nInfo    : [ 20%] Meshing curve 167 (Line)\nInfo    : [ 20%] Meshing curve 168 (Line)\nInfo    : [ 20%] Meshing curve 169 (Line)\nInfo    : [ 20%] Meshing curve 170 (Line)\nInfo    : [ 20%] Meshing curve 171 (Line)\nInfo    : [ 20%] Meshing curve 172 (Line)\nInfo    : [ 20%] Meshing curve 173 (Line)\nInfo    : [ 20%] Meshing curve 174 (Line)\nInfo    : [ 20%] Meshing curve 175 (Line)\nInfo    : [ 20%] Meshing curve 176 (Line)\nInfo    : [ 20%] Meshing curve 177 (Line)\nInfo    : [ 20%] Meshing curve 178 (Line)\nInfo    : [ 20%] Meshing curve 179 (Line)\nInfo    : [ 20%] Meshing curve 180 (Line)\nInfo    : [ 20%] Meshing curve 181 (Line)\nInfo    : [ 20%] Meshing curve 182 (Line)\nInfo    : [ 20%] Meshing curve 183 (Line)\nInfo    : [ 20%] Meshing curve 184 (Line)\nInfo    : [ 20%] Meshing curve 185 (Line)\nInfo    : [ 20%] Meshing curve 186 (Line)\nInfo    : [ 20%] Meshing curve 187 (Line)\nInfo    : [ 20%] Meshing curve 188 (Line)\nInfo    : [ 20%] Meshing curve 189 (Line)\nInfo    : [ 20%] Meshing curve 190 (Line)\nInfo    : [ 20%] Meshing curve 191 (Line)\nInfo    : [ 20%] Meshing curve 192 (Line)\nInfo    : [ 20%] Meshing curve 193 (Line)\nInfo    : [ 20%] Meshing curve 194 (Line)\nInfo    : [ 30%] Meshing curve 195 (Line)\nInfo    : [ 30%] Meshing curve 196 (Line)\nInfo    : [ 30%] Meshing curve 197 (Line)\nInfo    : [ 30%] Meshing curve 198 (Line)\nInfo    : [ 30%] Meshing curve 199 (Line)\nInfo    : [ 30%] Meshing curve 200 (Line)\nInfo    : [ 30%] Meshing curve 201 (Line)\nInfo    : [ 30%] Meshing curve 202 (Line)\nInfo    : [ 30%] Meshing curve 203 (Line)\nInfo    : [ 30%] Meshing curve 204 (Line)\nInfo    : [ 30%] Meshing curve 205 (Line)\nInfo    : [ 30%] Meshing curve 206 (Line)\nInfo    : [ 30%] Meshing curve 207 (Line)\nInfo    : [ 30%] Meshing curve 208 (Line)\nInfo    : [ 30%] Meshing curve 209 (Line)\nInfo    : [ 30%] Meshing curve 210 (Line)\nInfo    : [ 30%] Meshing curve 211 (Line)\nInfo    : [ 30%] Meshing curve 212 (Line)\nInfo    : [ 30%] Meshing curve 213 (Line)\nInfo    : [ 30%] Meshing curve 214 (Line)\nInfo    : [ 30%] Meshing curve 215 (Line)\nInfo    : [ 30%] Meshing curve 216 (Line)\nInfo    : [ 30%] Meshing curve 217 (Line)\nInfo    : [ 30%] Meshing curve 218 (Line)\nInfo    : [ 30%] Meshing curve 219 (Line)\nInfo    : [ 30%] Meshing curve 220 (Line)\nInfo    : [ 30%] Meshing curve 221 (Line)\nInfo    : [ 30%] Meshing curve 222 (Line)\nInfo    : [ 30%] Meshing curve 223 (Line)\nInfo    : [ 30%] Meshing curve 224 (Line)\nInfo    : [ 30%] Meshing curve 225 (Line)\nInfo    : [ 30%] Meshing curve 226 (Line)\nInfo    : [ 30%] Meshing curve 227 (Line)\nInfo    : [ 30%] Meshing curve 228 (Line)\nInfo    : [ 30%] Meshing curve 229 (Line)\nInfo    : [ 30%] Meshing curve 230 (Line)\nInfo    : [ 30%] Meshing curve 231 (Line)\nInfo    : [ 30%] Meshing curve 235 (Line)\nInfo    : [ 30%] Meshing curve 236 (Line)\nInfo    : [ 30%] Meshing curve 237 (Line)\nInfo    : [ 30%] Meshing curve 238 (Line)\nInfo    : [ 30%] Meshing curve 239 (Line)\nInfo    : [ 30%] Meshing curve 240 (Line)\nInfo    : [ 30%] Meshing curve 241 (Line)\nInfo    : [ 30%] Meshing curve 247 (Line)\nInfo    : [ 40%] Meshing curve 248 (Line)\nInfo    : [ 40%] Meshing curve 249 (Line)\nInfo    : [ 40%] Meshing curve 250 (Line)\nInfo    : [ 40%] Meshing curve 251 (Line)\nInfo    : [ 40%] Meshing curve 252 (Line)\nInfo    : [ 40%] Meshing curve 253 (Line)\nInfo    : [ 40%] Meshing curve 254 (Line)\nInfo    : [ 40%] Meshing curve 255 (Line)\nInfo    : [ 40%] Meshing curve 256 (Line)\nInfo    : [ 40%] Meshing curve 257 (Line)\nInfo    : [ 40%] Meshing curve 258 (Line)\nInfo    : [ 40%] Meshing curve 259 (Line)\nInfo    : [ 40%] Meshing curve 260 (Line)\nInfo    : [ 40%] Meshing curve 261 (Line)\nInfo    : [ 40%] Meshing curve 262 (Line)\nInfo    : [ 40%] Meshing curve 263 (Line)\nInfo    : [ 40%] Meshing curve 264 (Line)\nInfo    : [ 40%] Meshing curve 265 (Line)\nInfo    : [ 40%] Meshing curve 266 (Line)\nInfo    : [ 40%] Meshing curve 267 (Line)\nInfo    : [ 40%] Meshing curve 268 (Line)\nInfo    : [ 40%] Meshing curve 269 (Line)\nInfo    : [ 40%] Meshing curve 270 (Line)\nInfo    : [ 40%] Meshing curve 271 (Line)\nInfo    : [ 40%] Meshing curve 272 (Line)\nInfo    : [ 40%] Meshing curve 273 (Line)\nInfo    : [ 40%] Meshing curve 274 (Line)\nInfo    : [ 40%] Meshing curve 275 (Line)\nInfo    : [ 40%] Meshing curve 276 (Line)\nInfo    : [ 40%] Meshing curve 277 (Line)\nInfo    : [ 40%] Meshing curve 278 (Line)\nInfo    : [ 40%] Meshing curve 279 (Line)\nInfo    : [ 40%] Meshing curve 280 (Line)\nInfo    : [ 40%] Meshing curve 281 (Line)\nInfo    : [ 40%] Meshing curve 282 (Line)\nInfo    : [ 40%] Meshing curve 283 (Line)\nInfo    : [ 40%] Meshing curve 284 (Line)\nInfo    : [ 40%] Meshing curve 285 (Line)\nInfo    : [ 40%] Meshing curve 286 (Line)\nInfo    : [ 40%] Meshing curve 287 (Line)\nInfo    : [ 40%] Meshing curve 288 (Line)\nInfo    : [ 40%] Meshing curve 289 (Line)\nInfo    : [ 40%] Meshing curve 290 (Line)\nInfo    : [ 40%] Meshing curve 291 (Line)\nInfo    : [ 40%] Meshing curve 292 (Line)\nInfo    : [ 40%] Meshing curve 293 (Line)\nInfo    : [ 50%] Meshing curve 294 (Line)\nInfo    : [ 50%] Meshing curve 295 (Line)\nInfo    : [ 50%] Meshing curve 296 (Line)\nInfo    : [ 50%] Meshing curve 297 (Line)\nInfo    : [ 50%] Meshing curve 298 (Line)\nInfo    : [ 50%] Meshing curve 299 (Line)\nInfo    : [ 50%] Meshing curve 300 (Line)\nInfo    : [ 50%] Meshing curve 301 (Line)\nInfo    : [ 50%] Meshing curve 302 (Line)\nInfo    : [ 50%] Meshing curve 303 (Line)\nInfo    : [ 50%] Meshing curve 304 (Line)\nInfo    : [ 50%] Meshing curve 305 (Line)\nInfo    : [ 50%] Meshing curve 306 (Line)\nInfo    : [ 50%] Meshing curve 307 (Line)\nInfo    : [ 50%] Meshing curve 308 (Line)\nInfo    : [ 50%] Meshing curve 309 (Line)\nInfo    : [ 50%] Meshing curve 310 (Line)\nInfo    : [ 50%] Meshing curve 311 (Line)\nInfo    : [ 50%] Meshing curve 312 (Line)\nInfo    : [ 50%] Meshing curve 313 (Line)\nInfo    : [ 50%] Meshing curve 314 (Line)\nInfo    : [ 50%] Meshing curve 315 (Line)\nInfo    : [ 50%] Meshing curve 316 (Line)\nInfo    : [ 50%] Meshing curve 317 (Line)\nInfo    : [ 50%] Meshing curve 318 (Line)\nInfo    : [ 50%] Meshing curve 322 (Line)\nInfo    : [ 50%] Meshing curve 323 (Line)\nInfo    : [ 50%] Meshing curve 324 (Line)\nInfo    : [ 50%] Meshing curve 325 (Line)\nInfo    : [ 50%] Meshing curve 330 (Line)\nInfo    : [ 50%] Meshing curve 332 (Line)\nInfo    : [ 50%] Meshing curve 333 (Line)\nInfo    : [ 50%] Meshing curve 334 (Line)\nInfo    : [ 50%] Meshing curve 335 (Line)\nInfo    : [ 50%] Meshing curve 336 (Line)\nInfo    : [ 50%] Meshing curve 355 (Line)\nInfo    : [ 50%] Meshing curve 356 (Line)\nInfo    : [ 50%] Meshing curve 357 (Line)\nInfo    : [ 50%] Meshing curve 358 (Line)\nInfo    : [ 50%] Meshing curve 359 (Line)\nInfo    : [ 50%] Meshing curve 360 (Line)\nInfo    : [ 50%] Meshing curve 361 (Line)\nInfo    : [ 50%] Meshing curve 362 (Line)\nInfo    : [ 50%] Meshing curve 363 (Line)\nInfo    : [ 50%] Meshing curve 364 (Line)\nInfo    : [ 60%] Meshing curve 365 (Line)\nInfo    : [ 60%] Meshing curve 366 (Line)\nInfo    : [ 60%] Meshing curve 367 (Line)\nInfo    : [ 60%] Meshing curve 368 (Line)\nInfo    : [ 60%] Meshing curve 369 (Line)\nInfo    : [ 60%] Meshing curve 370 (Line)\nInfo    : [ 60%] Meshing curve 371 (Line)\nInfo    : [ 60%] Meshing curve 372 (Line)\nInfo    : [ 60%] Meshing curve 373 (Line)\nInfo    : [ 60%] Meshing curve 374 (Line)\nInfo    : [ 60%] Meshing curve 375 (Line)\nInfo    : [ 60%] Meshing curve 376 (Line)\nInfo    : [ 60%] Meshing curve 377 (Line)\nInfo    : [ 60%] Meshing curve 378 (Line)\nInfo    : [ 60%] Meshing curve 379 (Line)\nInfo    : [ 60%] Meshing curve 380 (Line)\nInfo    : [ 60%] Meshing curve 381 (Line)\nInfo    : [ 60%] Meshing curve 382 (Line)\nInfo    : [ 60%] Meshing curve 383 (Line)\nInfo    : [ 60%] Meshing curve 384 (Line)\nInfo    : [ 60%] Meshing curve 385 (Line)\nInfo    : [ 60%] Meshing curve 386 (Line)\nInfo    : [ 60%] Meshing curve 387 (Line)\nInfo    : [ 60%] Meshing curve 388 (Line)\nInfo    : [ 60%] Meshing curve 389 (Line)\nInfo    : [ 60%] Meshing curve 390 (Line)\nInfo    : [ 60%] Meshing curve 391 (Line)\nInfo    : [ 60%] Meshing curve 392 (Line)\nInfo    : [ 60%] Meshing curve 393 (Line)\nInfo    : [ 60%] Meshing curve 394 (Line)\nInfo    : [ 60%] Meshing curve 395 (Line)\nInfo    : [ 60%] Meshing curve 396 (Line)\nInfo    : [ 60%] Meshing curve 397 (Line)\nInfo    : [ 60%] Meshing curve 398 (Line)\nInfo    : [ 60%] Meshing curve 399 (Line)\nInfo    : [ 60%] Meshing curve 400 (Line)\nInfo    : [ 60%] Meshing curve 401 (Line)\nInfo    : [ 60%] Meshing curve 402 (Line)\nInfo    : [ 60%] Meshing curve 403 (Line)\nInfo    : [ 60%] Meshing curve 404 (Line)\nInfo    : [ 60%] Meshing curve 405 (Line)\nInfo    : [ 60%] Meshing curve 406 (Line)\nInfo    : [ 60%] Meshing curve 407 (Line)\nInfo    : [ 60%] Meshing curve 408 (Line)\nInfo    : [ 60%] Meshing curve 409 (Line)\nInfo    : [ 60%] Meshing curve 410 (Line)\nInfo    : [ 70%] Meshing curve 411 (Line)\nInfo    : [ 70%] Meshing curve 412 (Line)\nInfo    : [ 70%] Meshing curve 413 (Line)\nInfo    : [ 70%] Meshing curve 414 (Line)\nInfo    : [ 70%] Meshing curve 415 (Line)\nInfo    : [ 70%] Meshing curve 416 (Line)\nInfo    : [ 70%] Meshing curve 417 (Line)\nInfo    : [ 70%] Meshing curve 418 (Line)\nInfo    : [ 70%] Meshing curve 419 (Line)\nInfo    : [ 70%] Meshing curve 420 (Line)\nInfo    : [ 70%] Meshing curve 421 (Line)\nInfo    : [ 70%] Meshing curve 422 (Line)\nInfo    : [ 70%] Meshing curve 423 (Line)\nInfo    : [ 70%] Meshing curve 424 (Line)\nInfo    : [ 70%] Meshing curve 425 (Line)\nInfo    : [ 70%] Meshing curve 426 (Line)\nInfo    : [ 70%] Meshing curve 427 (Line)\nInfo    : [ 70%] Meshing curve 428 (Line)\nInfo    : [ 70%] Meshing curve 429 (Line)\nInfo    : [ 70%] Meshing curve 430 (Line)\nInfo    : [ 70%] Meshing curve 431 (Line)\nInfo    : [ 70%] Meshing curve 432 (Line)\nInfo    : [ 70%] Meshing curve 433 (Line)\nInfo    : [ 70%] Meshing curve 434 (Line)\nInfo    : [ 70%] Meshing curve 435 (Line)\nInfo    : [ 70%] Meshing curve 436 (Line)\nInfo    : [ 70%] Meshing curve 437 (Line)\nInfo    : [ 70%] Meshing curve 438 (Line)\nInfo    : [ 70%] Meshing curve 439 (Line)\nInfo    : [ 70%] Meshing curve 440 (Line)\nInfo    : [ 70%] Meshing curve 441 (Line)\nInfo    : [ 70%] Meshing curve 442 (Line)\nInfo    : [ 70%] Meshing curve 443 (Line)\nInfo    : [ 70%] Meshing curve 444 (Line)\nInfo    : [ 70%] Meshing curve 447 (Line)\nInfo    : [ 70%] Meshing curve 454 (Line)\nInfo    : [ 70%] Meshing curve 456 (Line)\nInfo    : [ 70%] Meshing curve 457 (Line)\nInfo    : [ 70%] Meshing curve 465 (Line)\nInfo    : [ 70%] Meshing curve 466 (Line)\nInfo    : [ 70%] Meshing curve 472 (Line)\nInfo    : [ 70%] Meshing curve 474 (Line)\nInfo    : [ 70%] Meshing curve 475 (Line)\nInfo    : [ 70%] Meshing curve 476 (Line)\nInfo    : [ 70%] Meshing curve 477 (Line)\nInfo    : [ 70%] Meshing curve 483 (Line)\nInfo    : [ 80%] Meshing curve 484 (Line)\nInfo    : [ 80%] Meshing curve 490 (Line)\nInfo    : [ 80%] Meshing curve 492 (Line)\nInfo    : [ 80%] Meshing curve 493 (Line)\nInfo    : [ 80%] Meshing curve 494 (Line)\nInfo    : [ 80%] Meshing curve 495 (Line)\nInfo    : [ 80%] Meshing curve 501 (Line)\nInfo    : [ 80%] Meshing curve 502 (Line)\nInfo    : [ 80%] Meshing curve 508 (Line)\nInfo    : [ 80%] Meshing curve 510 (Line)\nInfo    : [ 80%] Meshing curve 511 (Line)\nInfo    : [ 80%] Meshing curve 512 (Line)\nInfo    : [ 80%] Meshing curve 513 (Line)\nInfo    : [ 80%] Meshing curve 519 (Line)\nInfo    : [ 80%] Meshing curve 520 (Line)\nInfo    : [ 80%] Meshing curve 526 (Line)\nInfo    : [ 80%] Meshing curve 528 (Line)\nInfo    : [ 80%] Meshing curve 529 (Line)\nInfo    : [ 80%] Meshing curve 530 (Line)\nInfo    : [ 80%] Meshing curve 531 (Line)\nInfo    : [ 80%] Meshing curve 538 (Line)\nInfo    : [ 80%] Meshing curve 546 (Line)\nInfo    : [ 80%] Meshing curve 548 (Line)\nInfo    : [ 80%] Meshing curve 549 (Line)\nInfo    : [ 80%] Meshing curve 550 (Line)\nInfo    : [ 80%] Meshing curve 551 (Line)\nInfo    : [ 80%] Meshing curve 552 (Line)\nInfo    : [ 80%] Meshing curve 553 (Line)\nInfo    : [ 80%] Meshing curve 554 (Line)\nInfo    : [ 80%] Meshing curve 555 (Line)\nInfo    : [ 80%] Meshing curve 556 (Line)\nInfo    : [ 80%] Meshing curve 557 (Line)\nInfo    : [ 80%] Meshing curve 558 (Line)\nInfo    : [ 80%] Meshing curve 559 (Line)\nInfo    : [ 80%] Meshing curve 560 (Line)\nInfo    : [ 80%] Meshing curve 561 (Line)\nInfo    : [ 80%] Meshing curve 562 (Line)\nInfo    : [ 80%] Meshing curve 563 (Line)\nInfo    : [ 80%] Meshing curve 564 (Line)\nInfo    : [ 80%] Meshing curve 565 (Line)\nInfo    : [ 80%] Meshing curve 566 (Line)\nInfo    : [ 80%] Meshing curve 567 (Line)\nInfo    : [ 80%] Meshing curve 568 (Line)\nInfo    : [ 80%] Meshing curve 569 (Line)\nInfo    : [ 80%] Meshing curve 570 (Line)\nInfo    : [ 90%] Meshing curve 571 (Line)\nInfo    : [ 90%] Meshing curve 572 (Line)\nInfo    : [ 90%] Meshing curve 573 (Line)\nInfo    : [ 90%] Meshing curve 574 (Line)\nInfo    : [ 90%] Meshing curve 575 (Line)\nInfo    : [ 90%] Meshing curve 576 (Line)\nInfo    : [ 90%] Meshing curve 577 (Line)\nInfo    : [ 90%] Meshing curve 578 (Line)\nInfo    : [ 90%] Meshing curve 579 (Line)\nInfo    : [ 90%] Meshing curve 580 (Line)\nInfo    : [ 90%] Meshing curve 581 (Line)\nInfo    : [ 90%] Meshing curve 582 (Line)\nInfo    : [ 90%] Meshing curve 583 (Line)\nInfo    : [ 90%] Meshing curve 584 (Line)\nInfo    : [ 90%] Meshing curve 585 (Line)\nInfo    : [ 90%] Meshing curve 586 (Line)\nInfo    : [ 90%] Meshing curve 587 (Line)\nInfo    : [ 90%] Meshing curve 588 (Line)\nInfo    : [ 90%] Meshing curve 589 (Line)\nInfo    : [ 90%] Meshing curve 590 (Line)\nInfo    : [ 90%] Meshing curve 591 (Line)\nInfo    : [ 90%] Meshing curve 592 (Line)\nInfo    : [ 90%] Meshing curve 593 (Line)\nInfo    : [ 90%] Meshing curve 594 (Line)\nInfo    : [ 90%] Meshing curve 595 (Line)\nInfo    : [ 90%] Meshing curve 596 (Line)\nInfo    : [ 90%] Meshing curve 597 (Line)\nInfo    : [ 90%] Meshing curve 598 (Line)\nInfo    : [ 90%] Meshing curve 599 (Line)\nInfo    : [ 90%] Meshing curve 600 (Line)\nInfo    : [ 90%] Meshing curve 601 (Line)\nInfo    : [ 90%] Meshing curve 602 (Line)\nInfo    : [ 90%] Meshing curve 603 (Line)\nInfo    : [ 90%] Meshing curve 604 (Line)\nInfo    : [ 90%] Meshing curve 605 (Line)\nInfo    : [ 90%] Meshing curve 606 (Line)\nInfo    : [ 90%] Meshing curve 607 (Line)\nInfo    : [ 90%] Meshing curve 608 (Line)\nInfo    : [ 90%] Meshing curve 609 (Line)\nInfo    : [ 90%] Meshing curve 610 (Line)\nInfo    : [ 90%] Meshing curve 611 (Line)\nInfo    : [ 90%] Meshing curve 612 (Line)\nInfo    : [ 90%] Meshing curve 613 (Line)\nInfo    : [ 90%] Meshing curve 614 (Line)\nInfo    : [ 90%] Meshing curve 615 (Line)\nInfo    : [ 90%] Meshing curve 616 (Line)\nInfo    : [100%] Meshing curve 617 (Line)\nInfo    : [100%] Meshing curve 618 (Line)\nInfo    : [100%] Meshing curve 619 (Line)\nInfo    : [100%] Meshing curve 620 (Line)\nInfo    : [100%] Meshing curve 621 (Line)\nInfo    : [100%] Meshing curve 622 (Line)\nInfo    : [100%] Meshing curve 623 (Line)\nInfo    : [100%] Meshing curve 624 (Line)\nInfo    : [100%] Meshing curve 625 (Line)\nInfo    : [100%] Meshing curve 626 (Line)\nInfo    : [100%] Meshing curve 627 (Line)\nInfo    : [100%] Meshing curve 628 (Line)\nInfo    : [100%] Meshing curve 629 (Line)\nInfo    : [100%] Meshing curve 630 (Line)\nInfo    : [100%] Meshing curve 631 (Line)\nInfo    : [100%] Meshing curve 632 (Line)\nInfo    : [100%] Meshing curve 633 (Line)\nInfo    : [100%] Meshing curve 634 (Line)\nInfo    : [100%] Meshing curve 635 (Line)\nInfo    : [100%] Meshing curve 636 (Line)\nInfo    : [100%] Meshing curve 637 (Line)\nInfo    : [100%] Meshing curve 638 (Line)\nInfo    : [100%] Meshing curve 639 (Line)\nInfo    : [100%] Meshing curve 640 (Line)\nInfo    : [100%] Meshing curve 641 (Line)\nInfo    : [100%] Meshing curve 642 (Line)\nInfo    : [100%] Meshing curve 643 (Line)\nInfo    : [100%] Meshing curve 644 (Line)\nInfo    : [100%] Meshing curve 645 (Line)\nInfo    : [100%] Meshing curve 646 (Line)\nInfo    : [100%] Meshing curve 647 (Line)\nInfo    : [100%] Meshing curve 648 (Line)\nInfo    : [100%] Meshing curve 649 (Line)\nInfo    : [100%] Meshing curve 650 (Line)\nInfo    : [100%] Meshing curve 651 (Line)\nInfo    : [100%] Meshing curve 652 (Line)\nInfo    : [100%] Meshing curve 653 (Line)\nInfo    : [100%] Meshing curve 654 (Line)\nInfo    : [100%] Meshing curve 655 (Line)\nInfo    : [100%] Meshing curve 656 (Line)\nInfo    : [100%] Meshing curve 657 (Line)\nInfo    : [100%] Meshing curve 658 (Line)\nInfo    : [100%] Meshing curve 659 (Line)\nInfo    : [100%] Meshing curve 660 (Line)\nInfo    : [100%] Meshing curve 661 (Line)\nInfo    : Done meshing 1D (Wall 0.0319324s, CPU 0.036256s)\nInfo    : Meshing 2D...\nInfo    : [  0%] Meshing surface 8 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 16 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 21 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 24 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 29 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 32 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 37 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 40 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 45 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 53 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 64 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 65 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 66 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 67 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 68 (Plane, Frontal-Delaunay)\nInfo    : [ 10%] Meshing surface 69 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 72 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 73 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 74 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 75 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 76 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 77 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 80 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 81 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 82 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 83 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 84 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 85 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 88 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 89 (Plane, Frontal-Delaunay)\nInfo    : [ 20%] Meshing surface 90 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 91 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 92 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 93 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 96 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 97 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 98 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 99 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 100 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 101 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 104 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 105 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 106 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 112 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 113 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 114 (Plane, Frontal-Delaunay)\nInfo    : [ 30%] Meshing surface 115 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 116 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 117 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 120 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 121 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 122 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 123 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 124 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 125 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 128 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 129 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 130 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 131 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 132 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 133 (Plane, Frontal-Delaunay)\nInfo    : [ 40%] Meshing surface 136 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 137 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 138 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 139 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 140 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 141 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 147 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 148 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 149 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 160 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 161 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 162 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 163 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 164 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 165 (Plane, Frontal-Delaunay)\nInfo    : [ 50%] Meshing surface 168 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 169 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 170 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 171 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 172 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 173 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 176 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 177 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 178 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 179 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 180 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 181 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 184 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 185 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 186 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 187 (Plane, Frontal-Delaunay)\nInfo    : [ 60%] Meshing surface 188 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 189 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 192 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 193 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 194 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 195 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 196 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 197 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 202 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 210 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 211 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 218 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 219 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 226 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 227 (Plane, Frontal-Delaunay)\nInfo    : [ 70%] Meshing surface 234 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 235 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 243 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 244 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 245 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 246 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 247 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 248 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 249 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 250 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 251 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 252 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 253 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 254 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 255 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 256 (Plane, Frontal-Delaunay)\nInfo    : [ 80%] Meshing surface 257 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 258 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 259 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 260 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 261 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 262 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 263 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 264 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 265 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 266 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 267 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 268 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 269 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 270 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 271 (Plane, Frontal-Delaunay)\nInfo    : [ 90%] Meshing surface 272 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 273 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 274 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 275 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 276 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 277 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 278 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 279 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 280 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 281 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 282 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 283 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 284 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 285 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 286 (Plane, Frontal-Delaunay)\nInfo    : [100%] Meshing surface 287 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.219264s, CPU 0.223517s)\nInfo    : Meshing 3D...\nInfo    : 3D Meshing 1 volume with 1 connected component\nInfo    : Tetrahedrizing 5922 nodes...\nInfo    : Done tetrahedrizing 5930 nodes (Wall 0.0745989s, CPU 0.069584s)\nInfo    : Reconstructing mesh...\nInfo    :  - Creating surface mesh\nInfo    :  - Identifying boundary edges\nInfo    :  - Recovering boundary\nInfo    :  - Added 1 Steiner point\nInfo    : Done reconstructing mesh (Wall 0.187552s, CPU 0.172506s)\nInfo    : Found volume 1\nInfo    : It. 0 - 0 nodes created - worst tet radius 0.912402 (nodes removed 0 0)\nInfo    : 3D refinement terminated (5923 nodes total):\nInfo    :  - 0 Delaunay cavities modified for star shapeness\nInfo    :  - 0 nodes could not be inserted\nInfo    :  - 17362 tetrahedra created in 0.00118334 sec. (14672030 tets/s)\nInfo    : 0 node relocations\nInfo    : Done meshing 3D (Wall 0.389538s, CPU 0.375124s)\nInfo    : Optimizing mesh...\nInfo    : Optimizing volume 1\nInfo    : Optimization starts (volume = 10.2837) with worst = 0.000838874 / average = 0.719092:\nInfo    : 0.00 &lt; quality &lt; 0.10 :       342 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :       190 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :       150 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       149 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       485 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :      1345 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      3180 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      5742 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      4856 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       923 elements\nInfo    : 628 edge swaps, 0 node relocations (volume = 10.2837): worst = 0.000838874 / average = 0.738579 (Wall 0.0114649s, CPU 0.011584s)\nInfo    : 663 edge swaps, 0 node relocations (volume = 10.2837): worst = 0.000838874 / average = 0.73902 (Wall 0.0141874s, CPU 0.014421s)\nInfo    : 0.00 &lt; quality &lt; 0.10 :        44 elements\nInfo    : 0.10 &lt; quality &lt; 0.20 :         8 elements\nInfo    : 0.20 &lt; quality &lt; 0.30 :         6 elements\nInfo    : 0.30 &lt; quality &lt; 0.40 :       150 elements\nInfo    : 0.40 &lt; quality &lt; 0.50 :       520 elements\nInfo    : 0.50 &lt; quality &lt; 0.60 :      1307 elements\nInfo    : 0.60 &lt; quality &lt; 0.70 :      3155 elements\nInfo    : 0.70 &lt; quality &lt; 0.80 :      6040 elements\nInfo    : 0.80 &lt; quality &lt; 0.90 :      4704 elements\nInfo    : 0.90 &lt; quality &lt; 1.00 :       857 elements\nInfo    : Done optimizing mesh (Wall 0.0339558s, CPU 0.034895s)\nInfo    : 5923 nodes 31149 elements\nInfo    : Writing '../meshes/honeycomb.msh'...\nInfo    : Done writing '../meshes/honeycomb.msh'\n\nSuccessfully loaded 16817 tetrahedrons.\n</code></pre> <pre><code>Warning : 1 ill-shaped tets are still in the mesh\nWarning : ------------------------------\nWarning : Mesh generation error summary\nWarning :     1 warning\nWarning :     0 errors\nWarning : Check the full log for details\nWarning : ------------------------------\n</code></pre> <pre><code>grid = pv.UnstructuredGrid(\n    np.hstack((np.full((mesh.elements.shape[0], 1), 4), mesh.elements)).flatten(),\n    np.full(mesh.elements.shape[0], pv.CellType.TETRA),\n    np.array(mesh.coords)\n)\n\npl = pv.Plotter()\npl.add_mesh(grid, show_edges=True, color=\"lightgray\",  smooth_shading=False)\npl.view_isometric()\npl.show()\n</code></pre> <pre><code>Widget(value='&lt;iframe src=\"http://localhost:46257/index.html?ui=P_0x7614b44687a0_0&amp;reconnect=auto\" class=\"pyvi\u2026\n</code></pre> <p></p> <p>We use <code>Tetrahedral</code> elements for the mesh and below we define the <code>Operator</code> object.</p> <pre><code>tet = element.Tetrahedron4()\nop = Operator(mesh, tet)\n\n\nn_dofs_per_node = 3\nn_nodes, n_dofs = mesh.coords.shape[0], mesh.coords.shape[0] * n_dofs_per_node\n</code></pre>"},{"location":"examples/ncm_metamaterial/#defining-the-neural-constitutive-model","title":"Defining the Neural Constitutive Model","text":"<p>The specific architecture employed for the neural strain energy density was a feed-forward Multi-Layer Perceptron (MLP). The network consisted of an input layer accepting the two scalar invariants \\((I_1, J)\\), followed by two hidden layers with 16 neurons each, and a final output layer producing the scalar energy value. To ensure that the second-order derivatives (Hessian) remained continuous and numerically stable, a \\texttt{softplus} activation function was utilized across all hidden layers. This choice is critical as standard piecewise linear activations, such as \\texttt{ReLU}, yield zero second derivatives almost everywhere, leading to immediate solver divergence.</p> \\[ \\psi_{\\text{total}}(I_1, J) = \\underbrace{\\left[ \\text{NN}(I_1, J; \\theta) - \\text{NN}(3, 1; \\theta) \\right]}_{\\text{Shifted Neural Potential}} + \\underbrace{\\Psi_{\\text{base}}(I_1, J)}_{\\text{Stiffness Prior}} \\] <p>Note</p> <p>Note we use an untrained neural network and for actual purpose this should be replaced by a trained neural network</p> <pre><code>class NeuralMaterial(eqx.Module):\n    layers: list\n    mu_init: float\n    lmbda_init: float\n\n    def __init__(self, key, mu=500.0, lmbda=1000.0):\n        self.mu_init = mu\n        self.lmbda_init = lmbda\n\n        keys = jax.random.split(key, 3)\n        self.layers = [\n            eqx.nn.Linear(2, 12, key=keys[0]),\n            jax.nn.softplus,\n            eqx.nn.Linear(12, 12, key=keys[1]),\n            jax.nn.softplus,\n            eqx.nn.Linear(12, 1, key=keys[2]),\n        ]\n\n    def __call__(self, x: Array) -&gt; Array:\n\n        y = x\n        for layer in self.layers:\n            y = layer(y)\n        psi_nn = y[0]\n\n        ref_invariants = jnp.array([3.0, 1.0])\n        y_ref = ref_invariants\n        for layer in self.layers:\n            y_ref = layer(y_ref)\n        psi_0 = y_ref[0]\n\n        I1, J = x[0], x[1]\n        psi_base = (\n            (self.mu_init / 2) * (I1 - 3)\n            - self.mu_init * jnp.log(J)\n            + (self.lmbda_init / 2) * (jnp.log(J)) ** 2\n        )\n\n        # Total Energy = (NN - Offset) + Base\n        return (psi_nn - psi_0) + psi_base\n</code></pre> <p>Now, we define the neural network architecture and the total strain energy density function based on the neural network defined above.</p> <pre><code>key = jax.random.PRNGKey(42)\n\nE = 1e4\nnu = 0.3\nmu = E / 2 / (1 + nu)\nlmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n\nnn_material = NeuralMaterial(key, mu=mu, lmbda=lmbda)\n\n\n@autovmap(grad_u=2)\ndef neural_strain_energy(grad_u, model):\n    I = jnp.eye(3)\n    F = I + grad_u\n    C = F.T @ F\n\n    I1 = jnp.trace(C)\n    J = jnp.linalg.det(F)\n\n    invariants = jnp.array([I1, J])\n    return model(invariants)\n\n\n@eqx.filter_jit\ndef total_neural_energy(u_flat: Array, model) -&gt; float:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_grad = op.grad(u)\n    energy_density = neural_strain_energy(u_grad, model)\n    return op.integrate(energy_density)\n</code></pre> <p>To check if the total energy at 0 deformation is zero, we can evaluate the total strain energy density function at the reference configuration where \\(I_1 = 3\\) and \\(J = 1\\). This ensures that the neural network's contribution is shifted appropriately, and the stiffness prior is also evaluated at this point.</p>"},{"location":"examples/ncm_metamaterial/#applying-boundary-conditions-and-loads","title":"Applying Boundary Conditions and Loads","text":"<pre><code>z_min, z_max = jnp.min(mesh.coords[:, 2]), jnp.max(mesh.coords[:, 2])\n\n\ntop_nodes = jnp.where(jnp.isclose(mesh.coords[:, 2], z_max))[0]\nbottom_nodes = jnp.where(jnp.isclose(mesh.coords[:, 2], z_min))[0]\n\nzero_dofs = jnp.concatenate(\n    [\n        3 * bottom_nodes,\n        3 * bottom_nodes + 1,\n        3 * bottom_nodes + 2,\n        3 * top_nodes,\n        3 * top_nodes + 1,\n    ]\n)\napplied_dofs = 3 * top_nodes + 2  # Apply displacement in z-direction\n\nfixed_dofs = jnp.concatenate([applied_dofs, zero_dofs])\n\nprescribed_values = jnp.zeros(n_dofs).at[applied_dofs].set(0.4)\n</code></pre>"},{"location":"examples/ncm_metamaterial/#using-coloring-to-compute-sparse-hessians","title":"Using Coloring to compute Sparse Hessians","text":"<p>We will solve the problem using direct linear solver. To this end, we will need to perform sparse differentiation using the <code>sparse</code> module of <code>tatva</code> and coloring approach from <code>tatva_coloring.</code></p> <pre><code>sparsity_pattern = sparse.create_sparsity_pattern(mesh, n_dofs_per_node=n_dofs_per_node)\nsparsity_pattern_csr = sp.csr_matrix(\n    (\n        sparsity_pattern.data,\n        (sparsity_pattern.indices[:, 0], sparsity_pattern.indices[:, 1]),\n    )\n)\nindptr = sparsity_pattern_csr.indptr\nindices = sparsity_pattern_csr.indices\ncolors = distance2_color_and_seeds(\n    row_ptr=sparsity_pattern_csr.indptr,\n    col_idx=sparsity_pattern_csr.indices,\n    n_dofs=n_dofs,\n)[0]\n\nenergy_fn = eqx.Partial(total_neural_energy, model=nn_material)\ngradient_fn = jax.jacrev(energy_fn)\n\nK_sparse_fn = sparse.jacfwd(\n    gradient=gradient_fn,\n    row_ptr=jnp.array(sparsity_pattern_csr.indptr),\n    col_indices=jnp.array(sparsity_pattern_csr.indices),\n    colors=jnp.array(colors),\n    color_batch_size=10,\n)\n\nzero_indices, one_indices = sparse.get_bc_indices(sparsity_pattern, fixed_dofs)\n</code></pre> <p>Note</p> <p>One can use the matrix-free solver by computing the Jacobian-vector product by simply using <code>jax.jvp</code> on the <code>gradient_fn</code>.</p>"},{"location":"examples/ncm_metamaterial/#defining-newton-solver","title":"Defining Newton Solver","text":"<p>We will use a newton sparse solver</p> Newton Solver with Sparse Linear Solve <pre><code>@eqx.filter_jit\ndef newton_sparse_solver(\n    u,\n    fext,\n    gradient,\n    hessian_sparse,\n    fixed_dofs,\n    zero_indices,\n    one_indices,\n    indptr,\n    indices,\n):\n    fint = gradient(u)\n\n    norm_res = 1.0\n\n    tol = 1e-8\n    max_iter = 10\n\n    def solver(u, n):\n        def true_func(u):\n            fint = gradient(u)\n            residual = fext - fint\n            residual = residual.at[fixed_dofs].set(0.0)\n\n            K_sparse = hessian_sparse(u)\n            K_data_lifted = K_sparse.data.at[zero_indices].set(0)\n            K_data_lifted = K_data_lifted.at[one_indices].set(1)\n\n            du = jsp.linalg.spsolve(\n                K_data_lifted, indices=indices, indptr=indptr, b=residual\n            )\n\n            u = u.at[:].add(du)\n            return u\n\n        def false_func(u):\n            return u\n\n        fint = gradient(u)\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0.0)\n        norm_res = jnp.linalg.norm(residual)\n\n        jax.debug.print(\"residual={}\", norm_res)\n\n        return jax.lax.cond(norm_res &gt; tol, true_func, false_func, u), n\n\n    u, xs = jax.lax.scan(solver, init=u, xs=jnp.arange(0, max_iter))\n\n    fint = gradient(u)\n    residual = fext - fint\n    residual = residual.at[fixed_dofs].set(0.0)\n    norm_res = jnp.linalg.norm(residual)\n\n    return u, norm_res\n</code></pre>"},{"location":"examples/ncm_metamaterial/#solving-the-system","title":"Solving the System","text":"<pre><code>fext = jnp.zeros(n_dofs)\n\nn_steps = 5\napplied_displacement = prescribed_values / n_steps  # displacement increment\n\nfor i in range(n_steps):\n    u_prev = u_prev.at[fixed_dofs].add(applied_displacement[fixed_dofs])\n\n    u_new, rnorm = newton_sparse_solver(\n        u_prev,\n        fext,\n        gradient_fn,\n        K_sparse_fn,\n        fixed_dofs,\n        zero_indices,\n        one_indices,\n        indptr,\n        indices,\n    )\n\n    u_prev = u_new\n\n    print(f\"Iteration {i}: Residual Norm = {rnorm:.4e}\")\n\nu_sol = u_prev.reshape(n_nodes, n_dofs_per_node)\n</code></pre> Output <pre><code>residual=1371.570589894706\nresidual=1402.269075102642\nresidual=516.3211491024834\nresidual=167.34643670888568\nresidual=26.774625960499975\nresidual=0.9441458517834568\nresidual=0.0013813731895300958\nresidual=3.1511744323539518e-09\nresidual=3.1511744323539518e-09\nresidual=3.1511744323539518e-09\nIteration 0: Residual Norm = 3.1512e-09\nresidual=1371.0780886756154\nresidual=1375.7943623328404\nresidual=501.66823707292286\nresidual=160.38678791964037\nresidual=24.923278457678418\nresidual=0.827860417393414\nresidual=0.0010720930028342405\nresidual=1.9273171080981712e-09\nresidual=1.9273171080981712e-09\nresidual=1.9273171080981712e-09\nIteration 1: Residual Norm = 1.9273e-09\nresidual=1370.550620706396\nresidual=1349.8788478066601\nresidual=487.2624762079414\nresidual=153.58816016433408\nresidual=23.16588771120084\nresidual=0.7238842678099198\nresidual=0.0008293137478007945\nresidual=1.1781167225397521e-09\nresidual=1.1781167225397521e-09\nresidual=1.1781167225397521e-09\nIteration 2: Residual Norm = 1.1781e-09\nresidual=1369.9899481741083\nresidual=1324.5185506340106\nresidual=473.1014648963445\nresidual=146.94885917842316\nresidual=21.497995708642627\nresidual=0.6310382481266316\nresidual=0.0006388297473102514\nresidual=7.167711051384289e-10\nresidual=7.167711051384289e-10\nresidual=7.167711051384289e-10\nIteration 3: Residual Norm = 7.1677e-10\nresidual=1369.393738883142\nresidual=1299.7020849297282\nresidual=459.1809042580567\nresidual=140.4662771051909\nresidual=19.91534601710452\nresidual=0.5482549150482866\nresidual=0.0004895203968808261\nresidual=4.316696382420045e-10\nresidual=4.316696382420045e-10\nresidual=4.316696382420045e-10\nIteration 4: Residual Norm = 4.3167e-10\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/ncm_metamaterial/#visualization","title":"Visualization","text":"<p>We will now visualize the deformation of metamaterial.</p> Visualization of Deformed Configuration <pre><code>sargs = dict(\n    title=r\"Displacement Magnitude\",\n    height=0.08,\n    width=0.2,\n    vertical=False,\n    position_x=0.1,\n    position_y=0.2,\n    title_font_size=20,\n    label_font_size=16,\n    color=\"black\",\n    font_family=\"arial\",\n)\n\n\npl = pv.Plotter()\ngrid[\"u\"] = np.array(u_sol)\nwarped = grid.warp_by_vector(\"u\", factor=4.0)\nwarped = warped.cell_data_to_point_data()\npl.add_mesh(\n    warped,\n    show_edges=False,\n    scalars=\"u\",\n    component=0,\n    cmap=\"managua\",\n    line_width=0.1,\n    scalar_bar_args=sargs,\n)\npl.view_vector([-0.55, -0.65, 0.5])\npl.show()\n</code></pre> <p></p>"},{"location":"examples/neural_operator_method_3d/","title":"Neural Operator Element Method","text":""},{"location":"examples/neural_operator_method_3d/#neural-operator-element-method","title":"Neural Operator Element Method","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"\n\n    import pyvista as pv\n\n    pv.global_theme.jupyter_backend = 'static'\n    pv.global_theme.notebook = True\n    pv.start_xvfb()\n\n    print(\"Installation complete!\")\nelse:\n    import pyvista as pv\n    pv.global_theme.jupyter_backend = 'client'\n</code></pre> <p>In this notebook, we will implement a neural constitutive model. A neural constitutive model uses neural networks to represent the relationship between stress and strain in materials. This approach allows for more flexible and accurate modeling of complex material behaviors compared to traditional constitutive models.</p> <pre><code>import os\n\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)  # Use double-precision for FEM stability\n\nimport equinox as eqx\nimport jax.experimental.sparse as jsp\nimport jax.numpy as jnp\nimport numpy as np\nimport pyvista as pv\nimport scipy.sparse as sp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element, sparse\nfrom tatva_coloring import distance2_color_and_seeds\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#mesh-and-material-setup","title":"Mesh and Material Setup","text":"<p>We start by defining the mesh and material properties for our simulation.</p> Mesh Generation <pre><code>import gmsh\nimport meshio\n\n\ndef create_unstructured_3d_through_hole_mesh(\n    L=10.0, H=5.0, a=3.0, mesh_size=0.8, filename=\"noem_3d_hole.msh\"\n):\n    \"\"\"\n    Creates an unstructured tetrahedral mesh for a cuboid with a\n    through-hole along the Z-axis.\n\n    Parameters:\n    - L: Width/Length of the cuboid (X and Y).\n    - H: Height of the cuboid (Z-axis).\n    - a: Side of the square hole.\n    - mesh_size: Characteristic mesh size.\n    \"\"\"\n    gmsh.initialize()\n    gmsh.model.add(\"NOEM_ThroughHole\")\n    occ = gmsh.model.occ\n\n    outer_vol = occ.addBox(-L / 2, -L / 2, 0, L, L, H)\n    cutter_vol = occ.addBox(-a / 2, -a / 2, -0.1, a, a, H + 0.2)\n\n    fem_vol, _ = occ.cut([(3, outer_vol)], [(3, cutter_vol)])\n    occ.synchronize()\n\n    all_surfaces = gmsh.model.getEntities(2)\n    interface_surfaces = []\n\n    for dim, tag in all_surfaces:\n        mass_prop = occ.getCenterOfMass(dim, tag)\n        # Check if surface is on the internal walls (x or y = +/- a/2)\n        is_internal_x = (\n            np.isclose(np.abs(mass_prop[0]), a / 2, atol=1e-3)\n            and np.abs(mass_prop[1]) &lt;= a / 2\n        )\n        is_internal_y = (\n            np.isclose(np.abs(mass_prop[1]), a / 2, atol=1e-3)\n            and np.abs(mass_prop[0]) &lt;= a / 2\n        )\n        # Ensure it's not the top or bottom cap of the cuboid\n        is_not_cap = not np.isclose(mass_prop[2], 0, atol=1e-3) and not np.isclose(\n            mass_prop[2], H, atol=1e-3\n        )\n\n        if (is_internal_x or is_internal_y) and is_not_cap:\n            interface_surfaces.append(tag)\n\n    gmsh.model.addPhysicalGroup(3, [fem_vol[0][1]], name=\"FEM_Volume\")\n    gmsh.model.addPhysicalGroup(2, interface_surfaces, name=\"Interface\")\n\n    gmsh.option.setNumber(\"Mesh.MeshSizeMin\", mesh_size)\n    gmsh.option.setNumber(\"Mesh.MeshSizeMax\", mesh_size)\n    gmsh.model.mesh.generate(3)\n    gmsh.write(filename)\n    gmsh.finalize()\n\n    mesh = meshio.read(filename)\n    nodes = mesh.points\n    fem_elements = mesh.cells_dict[\"tetra\"]\n\n    if \"Interface\" in mesh.cell_sets_dict:\n        # Get the triangles forming the internal boundary\n        interface_tris = mesh.cells_dict[\"triangle\"][\n            mesh.cell_sets_dict[\"Interface\"][\"triangle\"]\n        ]\n        interface_node_ids = np.unique(interface_tris)\n    else:\n        interface_node_ids = np.unique(mesh.cells_dict[\"triangle\"])\n\n    if os.path.exists(filename):\n        os.remove(filename)\n\n    return nodes, fem_elements, interface_node_ids\n\n\ndef get_pyvista_grid(mesh, cell_type=\"quad\"):\n    if mesh.coords.shape[1] == 2:\n        pv_points = np.hstack((mesh.coords, np.zeros(shape=(mesh.coords.shape[0], 1))))\n    else:\n        pv_points = np.array(mesh.coords)\n\n    cell_type_dict = {\n        \"quad\": 4,\n        \"triangle\": 3,\n        \"tetra\": 4,\n        \"hexahedron\": 8,\n    }\n\n    pv_cells = np.hstack(\n        (\n            np.full(\n                fill_value=cell_type_dict[cell_type], shape=(mesh.elements.shape[0], 1)\n            ),\n            mesh.elements,\n        )\n    )\n\n    pv_cell_type_dict = {\n        \"quad\": pv.CellType.QUAD,\n        \"triangle\": pv.CellType.TRIANGLE,\n        \"tetra\": pv.CellType.TETRA,\n        \"hexahedron\": pv.CellType.HEXAHEDRON,\n    }\n    cell_types = np.full(\n        fill_value=pv_cell_type_dict[cell_type], shape=(mesh.elements.shape[0],)\n    )\n\n    grid = pv.UnstructuredGrid(pv_cells.flatten(), cell_types, pv_points)\n\n    return grid\n</code></pre> <pre><code>nodes, elements, interface_idx = create_unstructured_3d_through_hole_mesh(\n    L=10.0, H=2.0, a=a, mesh_size=0.4\n)\n\nmesh = Mesh(coords=nodes, elements=elements)\n\nn_dofs_per_node = 3\nn_nodes = mesh.coords.shape[0]\nn_dofs = n_dofs_per_node * n_nodes\n</code></pre> <pre><code>grid = get_pyvista_grid(mesh, cell_type=\"tetra\")\npl = pv.Plotter()\npl.add_mesh(grid, show_edges=True)\npl.show()\n</code></pre> <p></p> <p>We define a simple 3D bar of length \\(L\\), width \\(W\\), and height \\(H\\). The bar isfixed at one end and subjected to a force at the other end. We use <code>Tetrahedral</code> elements for the mesh.</p> <pre><code>tetra = element.Tetrahedron4()\nop = Operator(mesh, tetra)\n\nn_dofs_per_node = 3\nn_nodes, n_dofs = mesh.coords.shape[0], mesh.coords.shape[0] * n_dofs_per_node\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#defining-fem-energy-functional","title":"Defining FEM energy functional","text":"<pre><code>from typing import NamedTuple\n\n\nclass Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  # Diffusion coefficient\n    lmbda: float  # Diffusion coefficient\n\n\nE = 1e4\nnu = 0.3\nmu = E / 2 / (1 + nu)\nlmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n\nmat = Material(mu=mu, lmbda=lmbda)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    I = jnp.eye(3)\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * I\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n\n\n@jax.jit\ndef total_fem_energy(u_flat: Array) -&gt; float:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_grad = op.grad(u)\n    energy_density = strain_energy(u_grad, mat.mu, mat.lmbda)\n    return op.integrate(energy_density)\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#defining-the-neural-constitutive-model","title":"Defining the Neural Constitutive Model","text":"<p>The specific architecture employed for the neural strain energy density was a feed-forward Multi-Layer Perceptron (MLP). The network consisted of an input layer accepting the two scalar invariants \\((I_1, J)\\), followed by two hidden layers with 16 neurons each, and a final output layer producing the scalar energy value. To ensure that the second-order derivatives (Hessian) remained continuous and numerically stable, a \\texttt{softplus} activation function was  utilized across all hidden layers. This choice is critical as standard piecewise linear activations, such as \\texttt{ReLU}, yield zero second derivatives almost everywhere, leading to immediate solver divergence.</p> \\[ \\psi_{\\text{total}}(I_1, J) = \\underbrace{\\left[ \\text{NN}(I_1, J; \\theta) - \\text{NN}(3, 1; \\theta) \\right]}_{\\text{Shifted Neural Potential}} + \\underbrace{\\Psi_{\\text{base}}(I_1, J)}_{\\text{Stiffness Prior}} \\] <pre><code>class NeuralInclusion(eqx.Module):\n    network: eqx.nn.MLP\n    stiffness_prior: float  # Helps with initial convergence\n\n    def __init__(self, n_interface_dofs, key, stiffness_prior=1e-2):\n        self.stiffness_prior = stiffness_prior\n        self.network = eqx.nn.MLP(\n            in_size=n_interface_dofs,\n            out_size=\"scalar\",\n            width_size=64,\n            depth=3,\n            activation=jax.nn.softplus,  # Must be smooth for Hessian\n            key=key,\n        )\n\n    def __call__(self, u_interface):\n        \"\"\"\n        Computes the shifted energy: G(u) - G(0) + prior\n        u_interface: flattened array of displacements for nodes on the boundary\n        \"\"\"\n        psi_raw = self.network(u_interface)\n\n        u_zero = jnp.zeros_like(u_interface)\n        psi_0 = self.network(u_zero)\n\n        prior = 0.5 * self.stiffness_prior * jnp.sum(u_interface**2)\n\n        return (psi_raw - psi_0) + prior\n\n\nneural_operator = NeuralInclusion(\n    n_interface_dofs=len(interface_idx) * n_dofs_per_node,\n    key=jax.random.PRNGKey(0),\n    stiffness_prior=1e4, #1e-2\n)\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#coupling-the-domains-through-energies","title":"Coupling the domains through energies","text":"<p>Now, we define the neural network architecture and the total strain energy density function based on the neural network defined above.</p> <pre><code>def total_energy(u_flat, neural_operator):\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    energy_fem = total_fem_energy(u_flat)\n\n    # Extract displacements for interface nodes\n    u_interface = u[interface_idx].flatten()\n    energy_neural = neural_operator(u_interface)\n\n    return energy_fem + energy_neural\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#using-coloring-to-compute-sparse-hessians","title":"Using Coloring to compute Sparse Hessians","text":"<pre><code>sparsity_pattern = sparse.create_sparsity_pattern(mesh, n_dofs_per_node=n_dofs_per_node)\nsparsity_pattern_csr = sp.csr_matrix(\n    (\n        sparsity_pattern.data,\n        (sparsity_pattern.indices[:, 0], sparsity_pattern.indices[:, 1]),\n    )\n)\nindptr = sparsity_pattern_csr.indptr\nindices = sparsity_pattern_csr.indices\ncolors = distance2_color_and_seeds(\n    row_ptr=sparsity_pattern_csr.indptr,\n    col_idx=sparsity_pattern_csr.indices,\n    n_dofs=n_dofs,\n)[0]\n\n# Closure for the energy based on the NN weights\nenergy_fn = eqx.Partial(total_energy, neural_operator=neural_operator)\ngradient_fn = jax.jacrev(energy_fn)\n\nK_sparse_fn = sparse.jacfwd(\n    gradient=gradient_fn,\n    row_ptr=jnp.array(sparsity_pattern_csr.indptr),\n    col_indices=jnp.array(sparsity_pattern_csr.indices),\n    colors=jnp.array(colors),\n    color_batch_size=10,\n)\n</code></pre> <p>To check if the total energy at 0 deformation is zero, we can evaluate the total strain energy density function at the reference configuration where \\(I_1 = 3\\) and \\(J = 1\\). This ensures that the neural network's contribution is shifted  appropriately, and the stiffness prior is also evaluated at this point.</p>"},{"location":"examples/neural_operator_method_3d/#applying-boundary-conditions-and-loads","title":"Applying Boundary Conditions and Loads","text":"<pre><code># Boundary Conditions &amp; Solver Setup\ny_min, y_max = jnp.min(mesh.coords[:, 1]), jnp.max(mesh.coords[:, 1])\n\n\ntop_nodes = jnp.where(jnp.isclose(mesh.coords[:, 1], y_max))[0]\nbottom_nodes = jnp.where(jnp.isclose(mesh.coords[:, 1], y_min))[0]\n\napplied_dofs = n_dofs_per_node * top_nodes + 1  # y-direction DOFs at the top nodes\n\nzero_dofs = jnp.concatenate(\n    [n_dofs_per_node * bottom_nodes, n_dofs_per_node * bottom_nodes + 1]\n)\n\nfixed_dofs = jnp.concatenate([applied_dofs, zero_dofs])\n\nprescribed_values = jnp.zeros(n_dofs).at[applied_dofs].set(1.0)\n\nzero_indices, one_indices = sparse.get_bc_indices(sparsity_pattern, fixed_dofs)\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#defining-newton-solver","title":"Defining Newton Solver","text":"Newton Solver with Sparse Hessian <pre><code>@eqx.filter_jit\ndef newton_sparse_solver(\n    u,\n    fext,\n    gradient,\n    hessian_sparse,\n    fixed_dofs,\n    zero_indices,\n    one_indices,\n    indptr,\n    indices,\n):\n    fint = gradient(u)\n\n    norm_res = 1.0\n\n    tol = 1e-8\n    max_iter = 10\n\n    def solver(u, n):\n        def true_func(u):\n            fint = gradient(u)\n            residual = fext - fint\n            residual = residual.at[fixed_dofs].set(0.0)\n\n            K_sparse = hessian_sparse(u)\n            K_data_lifted = K_sparse.data.at[zero_indices].set(0)\n            K_data_lifted = K_data_lifted.at[one_indices].set(1)\n\n            du = jsp.linalg.spsolve(\n                K_data_lifted, indices=indices, indptr=indptr, b=residual\n            )\n\n            u = u.at[:].add(du)\n            return u\n\n        def false_func(u):\n            return u\n\n        fint = gradient(u)\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0.0)\n        norm_res = jnp.linalg.norm(residual)\n\n        jax.debug.print(\"residual={}\", norm_res)\n\n        return jax.lax.cond(norm_res &gt; tol, true_func, false_func, u), n\n\n    u, xs = jax.lax.scan(solver, init=u, xs=jnp.arange(0, max_iter))\n\n    fint = gradient(u)\n    residual = fext - fint\n    residual = residual.at[fixed_dofs].set(0.0)\n    norm_res = jnp.linalg.norm(residual)\n\n    return u, norm_res\n</code></pre>"},{"location":"examples/neural_operator_method_3d/#solving-the-system","title":"Solving the System","text":"<pre><code>fext = jnp.zeros(n_dofs) \n\nn_steps = 5\napplied_displacement = prescribed_values / n_steps  # displacement increment\n\nresidual_history = []\n\nprint(\"Starting Neural Constitutive Solver...\")\nfor i in range(n_steps):  # Newton iterations\n    u_prev = u_prev.at[fixed_dofs].add(applied_displacement[fixed_dofs])\n\n    u_new, rnorm = newton_sparse_solver(\n        u_prev,\n        fext,\n        gradient_fn,\n        K_sparse_fn,\n        fixed_dofs,\n        zero_indices,\n        one_indices,\n        indptr,\n        indices,\n    )\n\n    residual_history.append(rnorm)\n\n    u_prev = u_new\n\n    print(f\"Iteration {i}: Residual Norm = {rnorm:.4e}\")\n\nu_sol = u_prev.reshape(n_nodes, n_dofs_per_node)\n</code></pre> <pre><code>\n</code></pre> Visualization of Results <pre><code>grid = pv.UnstructuredGrid(\n    np.hstack((np.full((mesh.elements.shape[0], 1), 4), mesh.elements)).flatten(),\n    np.full(mesh.elements.shape[0], pv.CellType.TETRA),\n    np.array(mesh.coords),\n)\n\npl = pv.Plotter()\n\ngrad_u = op.grad(u_sol).squeeze()\nstrains = compute_strain(grad_u)\nstresses = compute_stress(strains, mat.mu, mat.lmbda)\n\n\ngrid[\"u\"] = np.array(u_sol)\ngrid[\"sigma_yy\"] = stresses[:, 1, 1].flatten()\n\nwarped = grid.warp_by_vector(\"u\", factor=4.0)\npl.add_mesh(warped, show_edges=False, scalars=\"u\", component=0, cmap=\"managua\", show_scalar_bar=False)\npl.view_isometric()\npl.screenshot(\"../assets/plots/neural_soft_inclusion_deformed_mesh.png\", transparent_background=True)\npl.show()\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/","title":"Rigid Body Constraints","text":""},{"location":"examples/nonlinear_hole_plate/#rigid-body-constraints","title":"Rigid Body Constraints","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\n</code></pre> <p>In the example, we implement rigid body constraint to a nonlinear material using static condensation</p> <pre><code>from typing import NamedTuple\n\nimport gmsh\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nfrom jax import Array\nfrom jax_autovmap import autovmap\n\nfrom tatva import Mesh, Operator\n\njax.config.update(\"jax_enable_x64\", True)\n</code></pre> Code for generating a plate with a hole geometry and meshing it. <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.axes import Axes\n\n\ndef extract_physical_groups(tag_map: dict) -&gt; dict[str, np.ndarray]:\n    print(\"Extracting physical groups from Gmsh model...\")\n    physical_surfaces: dict[str, np.ndarray] = {}\n\n    for dim, pg_tag in gmsh.model.getPhysicalGroups(dim=1):\n        name = gmsh.model.getPhysicalName(dim, pg_tag)\n\n        # Entities (surface tags) that belong to this physical group\n        entities = gmsh.model.getEntitiesForPhysicalGroup(dim, pg_tag)\n\n        els = []\n        for ent in entities:\n            # Get all mesh elements on this surface entity\n            types, _, node_tags_by_type = gmsh.model.mesh.getElements(dim, ent)\n\n            for etype, ntags in zip(types, node_tags_by_type):\n                nodes = np.array(ntags, dtype=np.int64).reshape(-1, etype + 1)\n                els.append(nodes)\n\n        if not els:\n            physical_surfaces[name] = np.zeros((0, 2), dtype=np.int32)\n            continue\n\n        group_els = np.vstack(els, dtype=np.int32)\n        group_els = np.array(\n            [[tag_map[t] for t in tri] for tri in group_els], dtype=np.int32\n        )\n        physical_surfaces[name] = group_els\n\n    return physical_surfaces\n\n\n\ndef plot_mesh(mesh: Mesh, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.tripcolor(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        facecolors=np.ones(len(mesh.elements)),\n        cmap=\"managua\",\n        edgecolors=\"k\",\n        linewidth=0.2,\n    )\n    ax.margins(0, 0)\n    ax.set_aspect(\"equal\")\n\ndef generate_plate(length: float, height: float, hole_radius: float) -&gt; Mesh:\n    y0, y1 = 0 - height / 2, height / 2\n    x0, x1 = 0.0, length\n    gmsh.initialize()\n    gmsh.model.add(\"plate_with_hole\")\n    occ = gmsh.model.occ\n\n    # Define the geometry\n    p1 = occ.addPoint(x0, y0, 0)\n    p2 = occ.addPoint(x1, y0, 0)\n    p3 = occ.addPoint(x1, y1, 0)\n    p4 = occ.addPoint(x0, y1, 0)\n\n    c1 = occ.addPoint(0, -hole_radius, 0)\n    c2 = occ.addPoint(0, hole_radius, 0)\n    cmid = occ.addPoint(0, 0, 0)\n    c_hole = occ.add_circle_arc(c2, cmid, c1)\n\n    l1 = occ.addLine(p1, p2)\n    l2 = occ.addLine(p2, p3)\n    l3 = occ.addLine(p3, p4)\n    l4 = occ.addLine(p4, c2)\n    l5 = c_hole\n    l6 = occ.addLine(c1, p1)\n\n    cl = occ.addCurveLoop([l1, l2, l3, l4, l5, l6])\n    surface = gmsh.model.occ.addPlaneSurface([cl])\n\n    gmsh.model.occ.synchronize()\n\n    # Refine along the hole boundary\n    base_size = min(length, height) / 30\n    fine_size = base_size / 3\n    dist_field = gmsh.model.mesh.field.add(\"Distance\")\n    gmsh.model.mesh.field.setNumbers(dist_field, \"CurvesList\", [c_hole])\n    thresh_field = gmsh.model.mesh.field.add(\"Threshold\")\n    gmsh.model.mesh.field.setNumber(thresh_field, \"InField\", dist_field)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"SizeMin\", fine_size)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"SizeMax\", base_size)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"DistMin\", hole_radius * 0.25)\n    gmsh.model.mesh.field.setNumber(thresh_field, \"DistMax\", hole_radius * 1.25)\n    gmsh.model.mesh.field.setAsBackgroundMesh(thresh_field)\n\n    # Mesh the geometry\n    gmsh.model.mesh.generate(2)\n\n    gmsh.model.addPhysicalGroup(2, [surface], 2, \"plate_surface\")\n    gmsh.model.addPhysicalGroup(1, [c_hole], 1, \"hole_boundary\")\n    gmsh.model.addPhysicalGroup(1, [l4, l6], 3, \"left_edge\")\n    gmsh.model.addPhysicalGroup(1, [l2], 4, \"right_edge\")\n    gmsh.model.addPhysicalGroup(1, [l1], 5, \"bottom_edge\")\n    gmsh.model.addPhysicalGroup(1, [l3], 6, \"top_edge\")\n\n    # Extract nodes and elements\n    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()\n    tag_map = {tag: i for i, tag in enumerate(node_tags)}\n    nodes = jnp.array(node_coords).reshape(-1, 3)[:, :2]\n\n    elem_types, elem_tags, elem_node_tags = gmsh.model.mesh.getElements(2)\n    elements = jnp.array(elem_node_tags[0]).reshape(-1, 3) - 1\n\n    pg = extract_physical_groups(tag_map)\n    gmsh.finalize()\n    return Mesh(nodes, elements=elements), pg\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/#creating-mesh","title":"Creating Mesh","text":"<p>We define a plate with a hole at its center. Because of symmetry we only model, one half of the plate.</p> <pre><code>lx = 1.0\nly = 2.0\nr = 0.2\nmesh, pg = generate_plate(lx, ly, r)\nn_dofs_per_node = 2\nn_nodes = mesh.coords.shape[0]\nn_dofs = n_dofs_per_node * n_nodes\nplot_mesh(mesh)\n</code></pre> <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Circle)\nInfo    : [ 20%] Meshing curve 2 (Line)\nInfo    : [ 40%] Meshing curve 3 (Line)\nInfo    : [ 60%] Meshing curve 4 (Line)\nInfo    : [ 70%] Meshing curve 5 (Line)\nInfo    : [ 90%] Meshing curve 6 (Line)\nInfo    : Done meshing 1D (Wall 0.00501475s, CPU 0.005614s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.12732s, CPU 0.120661s)\nInfo    : 3518 nodes 7039 elements\nExtracting physical groups from Gmsh model...\n</code></pre> <p></p> <p>To define rigid body constraint, we define a rigid disk of radius = 0.15, which is attached to the top right part of the plate. </p> <pre><code>radius = 0.15\ndisk_center = jnp.array([lx * 3 / 4, ly / 2 * 3 / 4])\ndisk_nodes = jnp.where(\n    jnp.linalg.norm(mesh.coords - disk_center, axis=1) &lt; (radius + 1e-12)\n)[0]\n</code></pre> <p>We can now define the <code>Operator</code> object which takes the mesh and the associated element type which in this case is <code>Tri3</code>.</p> <pre><code>from tatva.element import Tri3\n\nop = Operator(mesh, Tri3())\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/#defining-boundaries","title":"Defining boundaries","text":"<p>We start with identify the degrees of freedom associated with boundaries</p> <pre><code>boundary_left = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nboundary_right = jnp.where(jnp.isclose(mesh.coords[:, 0], lx))[0]\npoint_at_y_0 = jnp.where(\n    jnp.isclose(mesh.coords[:, 0], lx) &amp; jnp.isclose(mesh.coords[:, 1], 0.0)\n)[0][0]\nboundary_left_bottom = jnp.where(\n    (jnp.isclose(mesh.coords[:, 0], 0.0)) &amp; (mesh.coords[:, 1] &lt; 0.0)\n)[0]\n\nfixed_dofs = jnp.concatenate(\n    [\n        boundary_left_bottom * n_dofs_per_node,  # u_x = 0 at left-bottom nodes\n        jnp.array([n_dofs + 1]),\n    ]\n)\n\nfree_dofs = jnp.setdiff1d(\n    jnp.arange(mesh.coords.shape[0] * n_dofs_per_node + 3), fixed_dofs\n)\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/#defining-constraints","title":"Defining constraints","text":"<p>To apply the symmetric boundary conditions and the rigid body constraints we define to functions that take the displacements and assign the appropriate boundary conditions.</p> <pre><code>@jax.jit\ndef apply_dirichlet_bc(u_flat: Array) -&gt; Array:\n    u_flat = u_flat.at[fixed_dofs].set(0.0)\n    return u_flat\n\n\n@jax.jit\ndef apply_rigid_body_bc(u_flat: Array) -&gt; Array:\n    ux_c, uy_c, theta_c = u_flat[-3:]\n    vecs = mesh.coords[disk_nodes] - disk_center\n\n    cos, sin = jnp.cos(theta_c), jnp.sin(theta_c)\n    rotation_matrix = jnp.array([[cos, -sin], [sin, cos]])\n    rotated_vecs = vecs @ rotation_matrix.T\n    u_rotation = rotated_vecs - vecs\n    u_rigid = jnp.stack([ux_c, uy_c]) + u_rotation\n    # Set the displacements at the disk nodes\n    u_flat = u_flat.at[disk_nodes * n_dofs_per_node].set(u_rigid[:, 0])\n    u_flat = u_flat.at[disk_nodes * n_dofs_per_node + 1].set(u_rigid[:, 1])\n    return u_flat\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/#defining-energy-functional","title":"Defining Energy Functional","text":"<p>We are now in a position to define the total global energy functional </p> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float\n    lmbda: float\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat = Material.from_youngs_poisson_2d(1, 0.3)\n\n\n# Hyperelastic material model\n@autovmap(grad_u=2)\ndef compute_deformation_gradient(grad_u):\n    return jnp.eye(2) + grad_u\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy_mpc(grad_u, mu, lmbda):\n    F = compute_deformation_gradient(grad_u)\n    C = F.T @ F\n    J = jnp.linalg.det(F)\n    return (\n        mat.mu / 2 * (jnp.trace(C) - 2)  # 2D case\n        - mat.mu * jnp.log(J)\n        + (mat.lmbda / 2) * (jnp.log(J)) ** 2\n    )\n\n\ndef total_energy_mpc_full(u_flat: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat[:-3].reshape(-1, n_dofs_per_node)\n    e_density = strain_energy_mpc(op.grad(u), mat.mu, mat.lmbda)\n    return op.integrate(e_density)\n\n\ndef total_energy_mpc(u_free: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = (\n        jnp.zeros(n_dofs + 3).at[free_dofs].set(u_free)\n    )  # +3 for the rigid body DOFs\n    u_full = apply_dirichlet_bc(u_full)\n    u_full = apply_rigid_body_bc(u_full)\n    return total_energy_mpc_full(u_full)\n\n\nresidual_mpc = jax.jacrev(total_energy_mpc)\n</code></pre> Newton-Krylov solver for the nonlinear system. <pre><code>from functools import partial\n\n\n@partial(jax.jit, static_argnames=[\"gradient\",\"compute_tangent\"])\ndef newton_krylov_solver(\n    u,\n    gradient,\n    compute_tangent,\n):\n    residual = gradient(u)\n    norm_res = jnp.linalg.norm(residual)\n\n    init_val = (u, 0, norm_res)\n\n    def cond_fun(state):\n        u, iiter, norm_res = state\n        return jnp.logical_and(norm_res &gt; 1e-8, iiter &lt; 10)\n\n    def body_fun(state):\n        u, iiter, norm_res = state\n        residual = gradient(u)\n\n        A = jax.jit(partial(compute_tangent, u_prev=u))\n\n        du, _ = jax.scipy.sparse.linalg.cg(A=A, b=-residual)\n\n        u = u + du\n\n        residual = gradient(u)\n        norm_res = jnp.linalg.norm(residual)\n\n        return (u, iiter + 1, norm_res)\n\n    final_u, final_iiter, final_norm = jax.lax.while_loop(cond_fun, body_fun, init_val)\n    jax.debug.print(\"  Residual: {res:.2e}\", res=final_norm)\n\n    return final_u, final_norm\n</code></pre> <p>We move the disk in the right direction while keeping its y position fixed. The disk is allowed to rotate \\(\\theta\\) such that the disk experiences no moment about its center.</p> <pre><code>u_disk_x_dof = -2  # hardcoded last 2 dofs correspond to u_disk (one is fixed by BC)\n\n\n@jax.jit\ndef func_mpc(u_free: Array) -&gt; Array:\n    res = residual_mpc(u_free)\n    return res.at[u_disk_x_dof].add(-0.02)\n\ndef compute_tangent(du, u_prev):\n    tangent = jax.jvp(func_mpc, (u_prev,), (du,))[1]\n    return tangent\n</code></pre>"},{"location":"examples/nonlinear_hole_plate/#solving-the-system","title":"Solving the system","text":"<p>We solve the system for the applied rigid body displacement.</p> <pre><code>f_ext = jnp.zeros(len(free_dofs))\n\nu_sol, norm_res  = newton_krylov_solver(\n    u=jnp.zeros_like(f_ext),\n    gradient=func_mpc,\n    compute_tangent=compute_tangent,\n)\n</code></pre> <pre><code>Residual: 8.96e-11\n</code></pre> Visualization of the deformed configuration and strain energy density. <pre><code>from matplotlib.collections import LineCollection\nfrom matplotlib.tri import Triangulation\n\n_u = jnp.zeros(n_dofs + 3).at[free_dofs].set(u_sol)\n_u = apply_rigid_body_bc(_u)\nu_solid = _u.at[:-3].get()\nu_disk = _u.at[-3:].get()\n\nu = u_solid.reshape(-1, n_dofs_per_node)\n\nfig, ax = plt.subplots(figsize=(3.4, 3))\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\ne_sig = strain_energy_mpc(op.grad(u), mat.mu, mat.lmbda).squeeze()\ncb = ax.tripcolor(tri, e_sig, alpha=0.95, cmap=\"managua\")\nax.set_aspect(\"equal\")\nplt.colorbar(cb, ax=ax, label=r\"$\\Psi_{\\varepsilon}$\")\n\nedge_elems = jnp.concatenate(\n    (\n        pg[\"hole_boundary\"],\n        pg[\"left_edge\"],\n        pg[\"right_edge\"],\n        pg[\"bottom_edge\"],\n        pg[\"top_edge\"],\n    )\n)\nsegments = mesh.coords[edge_elems][:, :, :2]\ncoll_boundary = LineCollection(\n    segments + u[edge_elems][:, :, :2], colors=\"k\", linewidths=0.5\n)\nax.add_collection(coll_boundary)\nax.scatter(\n    (mesh.coords[disk_nodes] + u[disk_nodes])[:, 0],\n    (mesh.coords[disk_nodes] + u[disk_nodes])[:, 1],\n    color=\"k\",\n    s=1,\n    alpha=0.3,\n)\n\nrigid_circle = plt.Circle(\n    disk_center + u_disk[:2],\n    radius,\n    color=\"k\",\n    fc=\"#0000003f\",\n    linewidth=0.7,\n)\nudx, udy, theta_d = u_disk\nrigid_cross = plt.Line2D(\n    [\n        disk_center[0] + udx - np.cos(theta_d) * radius,\n        disk_center[0] + udx + np.cos(theta_d) * radius,\n    ],\n    [\n        disk_center[1] + udy - np.sin(theta_d) * radius,\n        disk_center[1] + udy + np.sin(theta_d) * radius,\n    ],\n    color=\"k\",\n    linewidth=0.7,\n)\nrigid_cross_vertical = plt.Line2D(\n    [\n        disk_center[0] + udx - np.sin(theta_d) * radius,\n        disk_center[0] + udx + np.sin(theta_d) * radius,\n    ],\n    [\n        disk_center[1] + udy + np.cos(theta_d) * radius,\n        disk_center[1] + udy - np.cos(theta_d) * radius,\n    ],\n    color=\"k\",\n    linewidth=0.7,\n)\nax.add_line(rigid_cross)\nax.add_line(rigid_cross_vertical)\nax.add_artist(rigid_circle)\n\nax.grid()\nax.set(\n    xlabel=\"$x$\",\n    ylabel=\"$y$\",\n)\nplt.show()\n#u_disk\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/soft_hydrogel/","title":"Embedded 1D Fibres","text":""},{"location":"examples/soft_hydrogel/#embedded-1d-fibers","title":"Embedded 1D Fibers","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\nelse:\n    import pyvista as pv\n</code></pre> <p>we consider a fiber-reinforced composite in which stiff 1D fibers are embedded in a soft 2D soft material. A central difficulty in such problems is that the fiber geometry typically does not align with the bulk mesh. The fibers may intersect bulk elements at arbitrary positions and orientations. In this example, we use an embedded-element approach formulated entirely at the level of the total potential energy.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)  # use double-precision\n\nfrom functools import partial\nfrom typing import NamedTuple\n\nimport equinox as eqx\nimport jax.numpy as jnp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element\n</code></pre> Mesh Generation <pre><code>import os\n\nimport gmsh\nimport matplotlib.pyplot as plt\nimport meshio\nimport numpy as np\n\n\ndef generate_plate_mesh(\n    Lx: float, Ly: float, mesh_size: float, work_dir: str = \".\"\n) -&gt; Mesh:\n    \"\"\"\n    Generates a 2D unstructured triangular mesh for a rectangular plate.\n\n    Args:\n        Lx (float): Length of the plate in the x-direction.\n        Ly (float): Length of the plate in the y-direction.\n        mesh_size (float): Target mesh size for the mesh generation.\n        work_dir (str): Directory to store temporary mesh files.\n\n    Returns:\n        Mesh: The generated plate mesh.\n    \"\"\"\n    if not os.path.exists(work_dir):\n        os.makedirs(work_dir)\n\n    filename = os.path.join(work_dir, \"plate_2d.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"plate\")\n\n    p1 = gmsh.model.geo.addPoint(0, 0, 0, mesh_size)\n    p2 = gmsh.model.geo.addPoint(Lx, 0, 0, mesh_size)\n    p3 = gmsh.model.geo.addPoint(Lx, Ly, 0, mesh_size)\n    p4 = gmsh.model.geo.addPoint(0, Ly, 0, mesh_size)\n\n    l1 = gmsh.model.geo.addLine(p1, p2)\n    l2 = gmsh.model.geo.addLine(p2, p3)\n    l3 = gmsh.model.geo.addLine(p3, p4)\n    l4 = gmsh.model.geo.addLine(p4, p1)\n\n    loop = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])\n    surface = gmsh.model.geo.addPlaneSurface([loop])\n\n    # 2. Mesh Generation\n    gmsh.model.geo.synchronize()\n    gmsh.model.mesh.generate(2)\n    gmsh.write(filename)\n    gmsh.finalize()\n\n    # 3. Read back with meshio\n    m = meshio.read(filename)\n    if os.path.exists(filename):\n        os.remove(filename)\n\n    points = m.points[:, :2]  # Drop z-coordinate for 2D\n    triangles = m.cells_dict[\"triangle\"]\n\n    return Mesh(points, triangles)\n\n\ndef generate_honeycomb_mesh(\n    start_x: float,\n    start_y: float,\n    n_x: int,\n    n_y: int,\n    side_length: float,\n    segments_per_side: int = 1,\n) -&gt; Mesh:\n    \"\"\"\n    Generates a 2D honeycomb mesh (hexagonal grid) with specified parameters.\n    Each hexagon side can be subdivided into smaller segments.\n\n    Args:\n        start_x (float): Starting x-coordinate of the honeycomb grid.\n        start_y (float): Starting y-coordinate of the honeycomb grid.\n        n_x (int): Number of hexagons along the x-direction.\n        n_y (int): Number of hexagons along the y-direction.\n        side_length (float): Length of each side of the hexagon.\n        segments_per_side (int): Number of subdivisions per hexagon side.\n\n    Returns:\n        Mesh: The generated honeycomb mesh.\n    \"\"\"\n\n    dx = np.sqrt(3) * side_length\n    dy = 1.5 * side_length\n    row_offset = (np.sqrt(3) * side_length) / 2.0\n\n    node_map = {}\n    coords_list = []\n    lines_list = []\n    edge_set = set()\n\n    def get_or_create_node(x, y):\n        key = (round(x, 6), round(y, 6))\n        if key not in node_map:\n            idx = len(coords_list)\n            coords_list.append([x, y])\n            node_map[key] = idx\n            return idx\n        return node_map[key]\n\n    angles = np.deg2rad([30, 90, 150, 210, 270, 330])\n\n    for row in range(n_y):\n        cols_in_this_row = n_x if (row % 2 == 0) else (n_x - 1)\n        current_offset = 0.0 if (row % 2 == 0) else row_offset\n\n        for col in range(cols_in_this_row):\n            cx = start_x + (col * dx) + current_offset\n            cy = start_y + (row * dy)\n\n            corners = []\n            for theta in angles:\n                vx = cx + side_length * np.cos(theta)\n                vy = cy + side_length * np.sin(theta)\n                corners.append((vx, vy))\n\n            for k in range(6):\n                # Start and End coordinates of the current side\n                start_pt = np.array(corners[k])\n                end_pt = np.array(corners[(k + 1) % 6])\n\n                # Get the Node Index for the start of the side\n                current_node_idx = get_or_create_node(start_pt[0], start_pt[1])\n\n                # Vector along the side\n                side_vector = end_pt - start_pt\n\n                for i in range(1, segments_per_side + 1):\n                    # Calculate fraction of distance (e.g., 1/3, 2/3, 3/3)\n                    t = i / segments_per_side\n\n                    # Calculate next coordinate\n                    next_pt = start_pt + t * side_vector\n\n                    # Get index for this new point\n                    next_node_idx = get_or_create_node(next_pt[0], next_pt[1])\n\n                    # Create the small segment\n                    edge_key = tuple(sorted((current_node_idx, next_node_idx)))\n                    if edge_key not in edge_set:\n                        edge_set.add(edge_key)\n                        lines_list.append([current_node_idx, next_node_idx])\n\n                    # Move forward\n                    current_node_idx = next_node_idx\n\n    return Mesh(np.array(coords_list), np.array(lines_list))\n</code></pre> <pre><code>plate_mesh = generate_plate_mesh(Lx=Lx, Ly=Ly, mesh_size=0.04)\nn_nodes = plate_mesh.coords.shape[0]\nn_dofs_per_node = 2  \nn_dofs = n_nodes * n_dofs_per_node\n\nfiber_mesh = generate_honeycomb_mesh(\n    start_x=0.6, start_y=0.7, n_x=3, n_y=3, side_length=0.2, segments_per_side=3\n)\n</code></pre> Output <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Line)\nInfo    : [ 30%] Meshing curve 2 (Line)\nInfo    : [ 60%] Meshing curve 3 (Line)\nInfo    : [ 80%] Meshing curve 4 (Line)\nInfo    : Done meshing 1D (Wall 0.000440115s, CPU 0.00057s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.103935s, CPU 0.103244s)\nInfo    : 3013 nodes 6028 elements\nInfo    : Writing './plate_2d.msh'...\nInfo    : Done writing './plate_2d.msh'\n</code></pre> Visualize Meshes <pre><code>plt.figure(figsize=(3, 3))\nax = plt.gca()\n\nax.tripcolor(\n    plate_mesh.coords[:, 0],\n    plate_mesh.coords[:, 1],\n    plate_mesh.elements,\n    facecolors=jnp.ones(plate_mesh.elements.shape[0]),\n    edgecolors=\"k\",\n    cmap=\"managua\",\n    lw=0.2,\n)\n\nfor i, el in enumerate(fiber_mesh.elements):\n    p0 = fiber_mesh.coords[el[0]]\n    p1 = fiber_mesh.coords[el[1]]\n    ax.plot(\n        [p0[0], p1[0]],\n        [p0[1], p1[1]],\n        \"k-\",\n        lw=1,\n    )\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.axis(\"equal\")\nax.margins(0.0, 0.0)\nplt.show()\n</code></pre> <p></p> <p>We now find the bulk material elements that contain the nodes of each fiber and then map these nodes tot he quadrature points of that element.</p> Barycentric Coordinate Computation and Embedding Logic <pre><code>def compute_barycentric(p, a, b, c):\n    \"\"\"\n    Computes local coordinates (xi, eta) of point p in triangle abc.\n    Returns (xi, eta) and a boolean 'is_inside'.\n    \"\"\"\n    v0 = c - a\n    v1 = b - a\n    v2 = p - a\n\n    dot00 = np.dot(v0, v0)\n    dot01 = np.dot(v0, v1)\n    dot02 = np.dot(v0, v2)\n    dot11 = np.dot(v1, v1)\n    dot12 = np.dot(v1, v2)\n\n    invDenom = 1 / (dot00 * dot11 - dot01 * dot01)\n    eta = (dot11 * dot02 - dot01 * dot12) * invDenom\n    xi = (dot00 * dot12 - dot01 * dot02) * invDenom\n\n    tol = 1e-10\n    is_inside = (xi &gt;= -tol) and (eta &gt;= -tol) and (xi + eta &lt;= 1 + tol)\n\n    return xi, eta, is_inside\n\n\ndef embed_fiber_into_plate(host_mesh, fiber_mesh):\n\n    fiber_nodes = fiber_mesh.coords\n    n_nodes = fiber_nodes.shape[0]\n\n    n_triangles = len(host_mesh.elements)\n\n    host_elem_indices = np.full(n_nodes, -1, dtype=int)\n    local_coords = np.zeros((n_nodes, 2))  # (xi, eta)\n\n    print(f\"Embedding {n_nodes} fiber nodes into {n_triangles} triangles...\")\n\n    tri_coords = host_mesh.coords[host_mesh.elements]  # (N_tri, 3, 2)\n    tri_min = tri_coords.min(axis=1)\n    tri_max = tri_coords.max(axis=1)\n\n    for i, pt in enumerate(fiber_nodes):\n        candidates = np.where(\n            (pt[0] &gt;= tri_min[:, 0])\n            &amp; (pt[0] &lt;= tri_max[:, 0])\n            &amp; (pt[1] &gt;= tri_min[:, 1])\n            &amp; (pt[1] &lt;= tri_max[:, 1])\n        )[0]\n\n        found = False\n        for tri_idx in candidates:\n            a, b, c = tri_coords[tri_idx]\n\n            xi, eta, is_inside = compute_barycentric(pt, a, b, c)\n\n            if is_inside:\n                host_elem_indices[i] = tri_idx\n                local_coords[i] = [xi, eta]\n                found = True\n                break\n\n        if not found:\n            print(f\"Warning: Fiber segment {i} at {pt} is outside the mesh domain!\")\n\n    return {\n        \"host_elem_indices\": host_elem_indices,\n        \"local_coords\": local_coords,  # (xi, eta)\n    }\n</code></pre> <pre><code>embedding_data = embed_fiber_into_plate(plate_mesh, fiber_mesh)\n</code></pre> <pre><code>Embedding 98 fiber nodes into 5824 triangles...\n</code></pre> <p>We define two operator one for the bulk material which consists of <code>Tri3</code> elements and one for fibers which are 1D elements emebeded in 2D space. For this we define a new elemenr <code>Line2in3D</code> which takes the displacements defined in 2D or 3D space and then project this displacement along its tangent vector.</p> Define Custom Line Element in 3D for Fiber Representation <pre><code>class Line2In3D(element.Element):\n    \"\"\"\n    A 2-node linear element embedded in 3D space.\n    Reference domain: [-1, 1]\n    \"\"\"\n\n    quad_points = jnp.array([[0.0]])\n    quad_weights = jnp.array([2.0])\n\n    def shape_function(self, xi: Array) -&gt; Array:\n        return jnp.array([0.5 * (1.0 - xi[0]), 0.5 * (1.0 + xi[0])])\n\n    def shape_function_derivative(self, xi: Array) -&gt; Array:\n        return jnp.array([[-0.5, 0.5]])\n\n    def get_jacobian(self, xi: Array, nodal_coords: Array) -&gt; tuple[Array, Array]:\n        \"\"\"\n        nodal_coords: (2, 3) -&gt; Two nodes in 3D space\n        \"\"\"\n        dN_dxi = self.shape_function_derivative(xi)\n\n        J_vec = dN_dxi @ nodal_coords  # (1, 2) @ (2, 3) -&gt; (1, 3)\n\n        detJ = jnp.linalg.norm(J_vec)\n        return J_vec, detJ\n\n    def gradient(self, xi: Array, nodal_values: Array, nodal_coords: Array) -&gt; Array:\n        \"\"\"\n        Returns the 3D Gradient vector.\n        \"\"\"\n        J_vec, detJ = self.get_jacobian(xi, nodal_coords)\n        dN_dxi = self.shape_function_derivative(xi)\n        du_dxi = dN_dxi @ nodal_values\n\n        du_ds = du_dxi / detJ\n\n        tangent = J_vec / detJ\n        grad_u_3d = jnp.vdot(du_ds, tangent)\n\n        return grad_u_3d\n</code></pre> <pre><code>op_plate = Operator(plate_mesh, element.Tri3())\nop_line = Operator(fiber_mesh, Line2In3D())\n</code></pre>"},{"location":"examples/soft_hydrogel/#defining-the-energy-for-the-bulk-material","title":"Defining the energy for the bulk material","text":"<pre><code>@autovmap(grad_u=2)\ndef compute_deformation_gradient(grad_u):\n    I = jnp.eye(2)\n    F = I + grad_u\n    return F\n\n\n@autovmap(F=2, mu=0, lmbda=0)\ndef strain_energy(F, mu, lmbda):\n    C = F.T @ F\n    I1 = jnp.trace(C)\n    J = jnp.linalg.det(F)\n    # return mu / 2 * (I1 - 3) - lmbda * jnp.log(J) + (lmbda / 2) * (jnp.log(J)) ** 2\n    return 0.5 * mu * (I1 - 3 - 2 * jnp.log(J)) + (lmbda / 2) * (jnp.log(J)) ** 2\n\n\n@jax.jit\ndef total_material_energy(u_flat: Array) -&gt; float:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_grad = op_plate.grad(u)\n    F = compute_deformation_gradient(u_grad)\n    energy_density = strain_energy(F, mat.mu, mat.lmbda)\n    return op_plate.integrate(energy_density)\n\n\n@autovmap(grad_u=0)\ndef compute_fiber_energy(grad_u):\n    return 0.5 * E_fiber * jnp.dot(grad_u, grad_u) * Area_fiber\n</code></pre> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float \n    lmbda: float  \n\n\nmat = Material(mu=1, lmbda=10.0)\n\nE = mat.mu * (3 * mat.lmbda + 2 * mat.mu) / (mat.lmbda + mat.mu)\nprint(f\"Effective Young's Modulus of the Plate: E = {E:.2f}\")\n</code></pre> <pre><code>Effective Young's Modulus of the Plate: E = 2.91\n</code></pre>"},{"location":"examples/soft_hydrogel/#defining-energy-for-the-fiber-network","title":"Defining energy for the fiber network","text":"<p>We now compute the energy of the fibe network which defined as </p> \\[ \\psi_\\text{fiber}(\\varepsilon_\\text{fiber}) = \\frac{1}{2}E_\\text{fiber}A_\\text{fiber} \\varepsilon_\\text{fiber}^2 \\] <pre><code>E_fiber = 100 * E  # Much stiffer than bulk\nArea_fiber = 0.01\n</code></pre> <pre><code>p0 = fiber_mesh.coords[fiber_mesh.elements[:, 0]]\np1 = fiber_mesh.coords[fiber_mesh.elements[:, 1]]\nvecs = p1 - p0\nlengths = np.linalg.norm(vecs, axis=1)\ntangents = vecs / lengths[:, None]  # Unit vectors (N_seg, 2)\n\nhost_indices = jnp.array(embedding_data[\"host_elem_indices\"])\nlocal_coords = jnp.array(embedding_data[\"local_coords\"])\nfiber_L0 = jnp.array(lengths)\nfiber_tangents = jnp.array(tangents)\n</code></pre> <pre><code>@eqx.filter_jit\ndef compute_u_fiber(u_flat: Array, host_indices: Array, local_coords: Array) -&gt; Array:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n\n    xi = local_coords[:, 0]\n    eta = local_coords[:, 1]\n    N1 = 1 - xi - eta\n    N2 = xi\n    N3 = eta\n\n    u1 = u[host_elems[:, 0]]  # (N_seg, 2)\n    u2 = u[host_elems[:, 1]]  # (N_seg, 2)\n    u3 = u[host_elems[:, 2]]  # (N_seg, 2)\n\n    u_fiber = N1[:, None] * u1 + N2[:, None] * u2 + N3[:, None] * u3  # (N_seg, 2)\n\n    return u_fiber\n\n\n@autovmap(u_elem=2, local_coords=1)\ndef compute_u_at_fiber(u_elem: Array, local_coords: Array) -&gt; Array:\n    N = element.Tri3().shape_function(local_coords)  # (3,)\n    u_quad = N @ u_elem  # (2,)\n    return u_quad\n\n\n@autovmap(host_elem=1, local_coord=2)\ndef compute_fiber_stretch(host_elem, local_coord, u):\n    u_elem = u[host_elem]  # (3, 2)\n    u_at_a = compute_u_at_fiber(u_elem, local_coord[0])\n    u_at_b = compute_u_at_fiber(u_elem, local_coord[1])\n\n    strain = (u_at_b - u_at_a) / fiber_L0\n\n    return strain\n\n\n@eqx.filter_jit\ndef fiber_strain_energy(\n    u_flat: Array,\n    host_elems: Array,\n    local_coords: Array,\n) -&gt; float:\n    u = u_flat.reshape(-1, n_dofs_per_node)\n    u_elem = u[host_elems]  # (N_seg, 3, 2)\n    u_at_nodes = compute_u_at_fiber(u_elem, local_coords)\n    u_grad = op_line.grad(u_at_nodes)  # (N_seg, 1, 2)\n    energy_density = compute_fiber_energy(u_grad)  # (N_seg,)\n    return op_line.integrate(energy_density)\n\n\nhost_elems = plate_mesh.elements[host_indices]\ntotal_fiber_energy = jax.jit(\n    partial(\n        fiber_strain_energy,\n        host_elems=host_elems,\n        local_coords=local_coords,\n    )\n)\n</code></pre>"},{"location":"examples/soft_hydrogel/#coupling-the-energies","title":"Coupling the energies","text":"\\[ \\Psi(\\boldsymbol{u}) = \\underbrace{\\int_{\\Omega_{\\text{bulk}}} \\psi_\\varepsilon(\\nabla \\boldsymbol{u}) ~\\mathrm{d\\Omega}}_{\\Psi_\\mathrm{bulk}} + \\underbrace{\\int_{\\Gamma_{\\text{fiber}}} \\psi_{\\text{fiber}}(\\epsilon_{\\text{fiber}})~ \\mathrm{dS}}_{\\Psi_{\\text{fiber}}} \\] <pre><code>@jax.jit\ndef total_energy(u_flat: Array) -&gt; float:\n    U_plate = total_material_energy(u_flat)\n    U_fiber = total_fiber_energy(u_flat)\n    return U_plate + U_fiber\n\n\n@jax.jit\ndef total_energy_without_fibre(u_flat: Array) -&gt; float:\n    U_plate = total_material_energy(u_flat)\n    return U_plate\n</code></pre>"},{"location":"examples/soft_hydrogel/#applying-boundary-conditions","title":"Applying boundary conditions","text":"<p>We apply uniaxial tension to the bulk material.</p> <pre><code>y_max = jnp.max(plate_mesh.coords[:, 1])\ny_min = jnp.min(plate_mesh.coords[:, 1])\nx_min = jnp.min(plate_mesh.coords[:, 0])\nheight = y_max - y_min\n\n\nupper_nodes = jnp.where(jnp.isclose(plate_mesh.coords[:, 1], y_max))[0]\nlower_nodes = jnp.where(jnp.isclose(plate_mesh.coords[:, 1], y_min))[0]\n\nfixed_dofs = jnp.concatenate(\n    [\n        2 * upper_nodes,\n        2 * upper_nodes + 1,\n        2 * lower_nodes,\n        2 * lower_nodes + 1,\n    ]\n)\n\n\napplied_disp = height * 0.2  # 10% strain\n\nprescribed_values = jnp.zeros(n_dofs).at[2 * upper_nodes].set(0.0)\nprescribed_values = prescribed_values.at[2 * upper_nodes + 1].set(applied_disp / 2.0)\nprescribed_values = prescribed_values.at[2 * lower_nodes].set(0.0)\nprescribed_values = prescribed_values.at[2 * lower_nodes + 1].set(-applied_disp / 2.0)\n\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"examples/soft_hydrogel/#matrix-free-approach","title":"Matrix-free approach","text":"<p>We use a matrix-free approach to automatically consider the additions terms due to the embedding of the fibers in the bulk material.</p> <pre><code>gradient = jax.jacrev(total_energy)\ngradient_wo_fiber = jax.jacrev(total_energy_without_fibre)\n\n\n@eqx.filter_jit\ndef compute_tangent(du, u_prev, gradient):\n    du_projected = du.at[fixed_dofs].set(0)\n    tangent = jax.jvp(gradient, (u_prev,), (du_projected,))[1]\n    tangent = tangent.at[fixed_dofs].set(0)\n    return tangent\n</code></pre> Conjugate Gradient Solver and Newton-Krylov Loop <pre><code>@eqx.filter_jit\ndef conjugate_gradient(A, b, atol=1e-8, max_iter=100):\n    iiter = 0\n\n    def body_fun(state):\n        b, p, r, rsold, x, iiter = state\n        Ap = A(p)\n        alpha = rsold / jnp.vdot(p, Ap)\n        x = x + jnp.dot(alpha, p)\n        r = r - jnp.dot(alpha, Ap)\n        rsnew = jnp.vdot(r, r)\n        p = r + (rsnew / rsold) * p\n        rsold = rsnew\n        iiter = iiter + 1\n        return (b, p, r, rsold, x, iiter)\n\n    def cond_fun(state):\n        b, p, r, rsold, x, iiter = state\n        return jnp.logical_and(jnp.sqrt(rsold) &gt; atol, iiter &lt; max_iter)\n\n    x = jnp.full_like(b, fill_value=0.0)\n    r = b - A(x)\n    p = r\n    rsold = jnp.vdot(r, p)\n\n    b, p, r, rsold, x, iiter = jax.lax.while_loop(\n        cond_fun, body_fun, (b, p, r, rsold, x, iiter)\n    )\n    return x, iiter\n\n\ndef newton_krylov_solver(\n    u,\n    fext,\n    gradient,\n    compute_tangent,\n    fixed_dofs,\n):\n    fint = gradient(u)\n    du = jnp.zeros_like(u)\n    iiter = 0\n    norm_res = 1.0\n    tol = 1e-8\n    max_iter = 80\n    while norm_res &gt; tol and iiter &lt; max_iter:\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n\n        A = eqx.Partial(compute_tangent, u_prev=u, gradient=gradient)\n        du, cg_iiter = conjugate_gradient(A=A, b=residual, atol=1e-8, max_iter=100)\n        u = u.at[:].add(du)\n\n        fint = gradient(u)\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n        norm_res = jnp.linalg.norm(residual)\n\n        print(f\"  Residual: {norm_res:.2e}\")\n        iiter += 1\n    return u, norm_res\n</code></pre> <pre><code>u_prev_wo_fiber = jnp.zeros(n_dofs)\n\nfext = jnp.zeros(n_dofs)\n\nn_steps = 10\napplied_displacement = prescribed_values / n_steps\nforce_on_top = [0.0]\ndisp_on_top = [0.0]\nforce_on_top_wo_fiber = [0.0]\ndisp_on_top_wo_fiber = [0.0]\n\nfor i in range(n_steps):\n    u_prev = u_prev.at[fixed_dofs].add(applied_displacement[fixed_dofs])\n    u_prev_wo_fiber = u_prev_wo_fiber.at[fixed_dofs].add(\n        applied_displacement[fixed_dofs]\n    )\n\n    u_new, rnorm = newton_krylov_solver(\n        u_prev,\n        fext,\n        gradient,\n        compute_tangent,\n        fixed_dofs,\n    )\n\n    u_new_wo_fiber, rnorm = newton_krylov_solver(\n        u_prev_wo_fiber,\n        fext,\n        gradient_wo_fiber,\n        compute_tangent,\n        fixed_dofs,\n    )\n\n    u_prev = u_new\n    u_prev_wo_fiber = u_new_wo_fiber\n\n    fint = gradient(u_prev).reshape(-1, n_dofs_per_node)\n    force_on_top.append(jnp.sum(fint[upper_nodes, 1]))\n    disp_on_top.append(jnp.mean(u_prev.reshape(-1, n_dofs_per_node)[upper_nodes, 1]))\n\n    fint_wo_fiber = gradient_wo_fiber(u_prev_wo_fiber).reshape(-1, n_dofs_per_node)\n    force_on_top_wo_fiber.append(jnp.sum(fint_wo_fiber[upper_nodes, 1]))\n    disp_on_top_wo_fiber.append(\n        jnp.mean(u_prev_wo_fiber.reshape(-1, n_dofs_per_node)[upper_nodes, 1])\n    )\n\n    print(f\"Iteration {i}: Residual Norm = {rnorm:.4e}\")\n\nu_sol = u_prev.reshape(n_nodes, n_dofs_per_node)\nu_sol_wo_fiber = u_prev_wo_fiber.reshape(n_nodes, n_dofs_per_node)\n</code></pre> Output <pre><code>Residual: 5.60e+00\n  Residual: 2.00e+00\n  Residual: 5.44e-01\n  Residual: 9.69e-02\n  Residual: 9.13e-03\n  Residual: 1.82e-04\n  Residual: 3.75e-05\n  Residual: 2.48e-05\n  Residual: 1.38e-05\n  Residual: 6.50e-06\n  Residual: 5.91e-06\n  Residual: 2.19e-06\n  Residual: 1.93e-06\n  Residual: 8.48e-07\n  Residual: 6.57e-07\n  Residual: 3.22e-07\n  Residual: 2.38e-07\n  Residual: 1.17e-07\n  Residual: 9.15e-08\n  Residual: 4.27e-08\n  Residual: 3.37e-08\n  Residual: 1.68e-08\n  Residual: 9.69e-09\n  Residual: 5.65e+00\n  Residual: 2.01e+00\n  Residual: 5.37e-01\n  Residual: 8.60e-02\n  Residual: 6.63e-03\n  Residual: 8.05e-05\n  Residual: 1.75e-05\n  Residual: 3.47e-06\n  Residual: 1.77e-06\n  Residual: 3.77e-07\n  Residual: 2.04e-07\n  Residual: 4.35e-08\n  Residual: 2.39e-08\n  Residual: 9.59e-09\nIteration 0: Residual Norm = 9.5937e-09\n  Residual: 5.22e+00\n  Residual: 1.84e+00\n  Residual: 4.82e-01\n  Residual: 7.75e-02\n  Residual: 5.91e-03\n  Residual: 1.26e-04\n  Residual: 4.13e-05\n  Residual: 1.39e-05\n  Residual: 1.58e-05\n  Residual: 3.30e-06\n  Residual: 5.89e-06\n  Residual: 9.55e-07\n  Residual: 1.94e-06\n  Residual: 3.22e-07\n  Residual: 6.38e-07\n  Residual: 1.24e-07\n  Residual: 2.00e-07\n  Residual: 3.59e-08\n  Residual: 7.78e-08\n  Residual: 1.31e-08\n  Residual: 4.83e-08\n  Residual: 9.99e-09\n  Residual: 5.30e+00\n  Residual: 1.86e+00\n  Residual: 4.78e-01\n  Residual: 6.75e-02\n  Residual: 3.92e-03\n  Residual: 3.84e-05\n  Residual: 1.41e-05\n  Residual: 2.63e-06\n  Residual: 1.46e-06\n  Residual: 3.03e-07\n  Residual: 1.74e-07\n  Residual: 3.57e-08\n  Residual: 2.04e-08\n  Residual: 9.68e-09\nIteration 1: Residual Norm = 9.6778e-09\n  Residual: 4.89e+00\n  Residual: 1.70e+00\n  Residual: 4.28e-01\n  Residual: 6.11e-02\n  Residual: 3.65e-03\n  Residual: 1.15e-04\n  Residual: 3.41e-05\n  Residual: 7.33e-06\n  Residual: 6.52e-06\n  Residual: 2.61e-06\n  Residual: 4.15e-06\n  Residual: 6.73e-07\n  Residual: 7.85e-07\n  Residual: 2.58e-07\n  Residual: 2.70e-07\n  Residual: 1.31e-07\n  Residual: 2.49e-07\n  Residual: 2.29e-08\n  Residual: 6.09e-08\n  Residual: 9.86e-09\n  Residual: 5.00e+00\n  Residual: 1.74e+00\n  Residual: 4.32e-01\n  Residual: 5.50e-02\n  Residual: 2.49e-03\n  Residual: 2.65e-05\n  Residual: 1.24e-05\n  Residual: 2.10e-06\n  Residual: 1.20e-06\n  Residual: 2.55e-07\n  Residual: 1.50e-07\n  Residual: 3.27e-08\n  Residual: 1.94e-08\n  Residual: 9.92e-09\nIteration 2: Residual Norm = 9.9184e-09\n  Residual: 4.62e+00\n  Residual: 1.58e+00\n  Residual: 3.87e-01\n  Residual: 5.01e-02\n  Residual: 2.42e-03\n  Residual: 1.01e-04\n  Residual: 2.78e-05\n  Residual: 5.07e-06\n  Residual: 1.94e-06\n  Residual: 1.04e-06\n  Residual: 7.17e-07\n  Residual: 3.12e-07\n  Residual: 2.72e-07\n  Residual: 1.17e-07\n  Residual: 9.63e-08\n  Residual: 4.74e-08\n  Residual: 2.64e-08\n  Residual: 3.42e-08\n  Residual: 9.94e-09\n  Residual: 4.75e+00\n  Residual: 1.63e+00\n  Residual: 3.94e-01\n  Residual: 4.58e-02\n  Residual: 1.65e-03\n  Residual: 2.07e-05\n  Residual: 1.05e-05\n  Residual: 1.46e-06\n  Residual: 9.42e-07\n  Residual: 1.65e-07\n  Residual: 1.11e-07\n  Residual: 2.07e-08\n  Residual: 9.97e-09\nIteration 3: Residual Norm = 9.9748e-09\n  Residual: 4.37e+00\n  Residual: 1.48e+00\n  Residual: 3.52e-01\n  Residual: 4.17e-02\n  Residual: 1.65e-03\n  Residual: 9.04e-05\n  Residual: 2.01e-05\n  Residual: 6.88e-06\n  Residual: 1.57e-06\n  Residual: 1.38e-06\n  Residual: 7.93e-07\n  Residual: 4.18e-07\n  Residual: 4.54e-07\n  Residual: 1.25e-07\n  Residual: 1.18e-07\n  Residual: 3.97e-08\n  Residual: 3.53e-08\n  Residual: 1.77e-08\n  Residual: 9.79e-09\n  Residual: 4.53e+00\n  Residual: 1.54e+00\n  Residual: 3.63e-01\n  Residual: 3.90e-02\n  Residual: 1.15e-03\n  Residual: 1.81e-05\n  Residual: 9.50e-06\n  Residual: 1.96e-06\n  Residual: 1.08e-06\n  Residual: 2.29e-07\n  Residual: 1.29e-07\n  Residual: 2.76e-08\n  Residual: 1.57e-08\n  Residual: 9.83e-09\nIteration 4: Residual Norm = 9.8288e-09\n  Residual: 4.16e+00\n  Residual: 1.40e+00\n  Residual: 3.24e-01\n  Residual: 3.60e-02\n  Residual: 1.22e-03\n  Residual: 8.49e-05\n  Residual: 2.04e-05\n  Residual: 6.07e-06\n  Residual: 6.55e-06\n  Residual: 1.73e-06\n  Residual: 3.52e-06\n  Residual: 5.09e-07\n  Residual: 1.15e-06\n  Residual: 1.71e-07\n  Residual: 4.55e-07\n  Residual: 5.63e-08\n  Residual: 2.03e-07\n  Residual: 1.65e-08\n  Residual: 4.63e-08\n  Residual: 9.62e-09\n  Residual: 4.33e+00\n  Residual: 1.46e+00\n  Residual: 3.37e-01\n  Residual: 3.39e-02\n  Residual: 8.50e-04\n  Residual: 1.76e-05\n  Residual: 8.26e-06\n  Residual: 2.69e-06\n  Residual: 1.40e-06\n  Residual: 4.75e-07\n  Residual: 2.56e-07\n  Residual: 8.85e-08\n  Residual: 4.83e-08\n  Residual: 1.68e-08\n  Residual: 9.91e-09\nIteration 5: Residual Norm = 9.9107e-09\n  Residual: 3.98e+00\n  Residual: 1.32e+00\n  Residual: 3.00e-01\n  Residual: 3.17e-02\n  Residual: 9.52e-04\n  Residual: 9.32e-05\n  Residual: 1.72e-05\n  Residual: 9.94e-06\n  Residual: 5.74e-06\n  Residual: 3.38e-06\n  Residual: 2.02e-06\n  Residual: 8.72e-07\n  Residual: 9.17e-07\n  Residual: 3.18e-07\n  Residual: 2.62e-07\n  Residual: 1.18e-07\n  Residual: 9.84e-08\n  Residual: 4.27e-08\n  Residual: 4.06e-08\n  Residual: 1.53e-08\n  Residual: 9.95e-09\n  Residual: 4.15e+00\n  Residual: 1.39e+00\n  Residual: 3.13e-01\n  Residual: 2.98e-02\n  Residual: 6.46e-04\n  Residual: 1.83e-05\n  Residual: 5.12e-06\n  Residual: 2.43e-06\n  Residual: 7.44e-07\n  Residual: 3.73e-07\n  Residual: 1.18e-07\n  Residual: 6.05e-08\n  Residual: 1.93e-08\n  Residual: 9.99e-09\nIteration 6: Residual Norm = 9.9871e-09\n  Residual: 3.82e+00\n  Residual: 1.26e+00\n  Residual: 2.81e-01\n  Residual: 2.89e-02\n  Residual: 8.26e-04\n  Residual: 9.04e-05\n  Residual: 1.91e-05\n  Residual: 1.17e-05\n  Residual: 7.13e-06\n  Residual: 3.12e-06\n  Residual: 1.86e-06\n  Residual: 1.06e-06\n  Residual: 9.78e-07\n  Residual: 3.31e-07\n  Residual: 6.31e-07\n  Residual: 9.57e-08\n  Residual: 1.39e-07\n  Residual: 4.14e-08\n  Residual: 4.47e-08\n  Residual: 1.29e-08\n  Residual: 9.77e-09\n  Residual: 4.00e+00\n  Residual: 1.32e+00\n  Residual: 2.94e-01\n  Residual: 2.67e-02\n  Residual: 5.26e-04\n  Residual: 1.89e-05\n  Residual: 2.19e-06\n  Residual: 8.70e-07\n  Residual: 3.87e-07\n  Residual: 1.74e-07\n  Residual: 7.78e-08\n  Residual: 3.46e-08\n  Residual: 9.91e-09\nIteration 7: Residual Norm = 9.9117e-09\n  Residual: 3.67e+00\n  Residual: 1.20e+00\n  Residual: 2.64e-01\n  Residual: 2.67e-02\n  Residual: 7.18e-04\n  Residual: 8.21e-05\n  Residual: 1.74e-05\n  Residual: 1.10e-05\n  Residual: 5.85e-06\n  Residual: 3.73e-06\n  Residual: 1.63e-06\n  Residual: 2.10e-06\n  Residual: 5.02e-07\n  Residual: 6.80e-07\n  Residual: 1.72e-07\n  Residual: 2.08e-07\n  Residual: 6.14e-08\n  Residual: 1.20e-07\n  Residual: 1.99e-08\n  Residual: 4.53e-08\n  Residual: 9.76e-09\n  Residual: 3.86e+00\n  Residual: 1.27e+00\n  Residual: 2.78e-01\n  Residual: 2.44e-02\n  Residual: 4.50e-04\n  Residual: 2.14e-05\n  Residual: 2.19e-06\n  Residual: 5.22e-07\n  Residual: 4.66e-07\n  Residual: 7.56e-08\n  Residual: 8.34e-08\n  Residual: 1.40e-08\n  Residual: 9.98e-09\nIteration 8: Residual Norm = 9.9847e-09\n  Residual: 3.54e+00\n  Residual: 1.15e+00\n  Residual: 2.50e-01\n  Residual: 2.51e-02\n  Residual: 6.49e-04\n  Residual: 8.67e-05\n  Residual: 1.91e-05\n  Residual: 9.68e-06\n  Residual: 6.52e-06\n  Residual: 3.59e-06\n  Residual: 2.09e-06\n  Residual: 1.43e-06\n  Residual: 7.21e-07\n  Residual: 3.90e-07\n  Residual: 2.42e-07\n  Residual: 1.96e-07\n  Residual: 8.53e-08\n  Residual: 7.76e-08\n  Residual: 2.73e-08\n  Residual: 2.59e-08\n  Residual: 9.82e-09\n  Residual: 3.73e+00\n  Residual: 1.22e+00\n  Residual: 2.64e-01\n  Residual: 2.28e-02\n  Residual: 4.04e-04\n  Residual: 2.24e-05\n  Residual: 3.30e-06\n  Residual: 1.33e-06\n  Residual: 6.86e-07\n  Residual: 2.93e-07\n  Residual: 1.47e-07\n  Residual: 6.41e-08\n  Residual: 3.16e-08\n  Residual: 9.99e-09\nIteration 9: Residual Norm = 9.9888e-09\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/soft_hydrogel/#visualization","title":"Visualization","text":"<p>We now visualize the deformation of the bulk material and the embedded fibres.</p> Post-processing and Visualization <pre><code>import matplotlib.patches as patches\nimport matplotlib.tri as tri_mat\nimport pyvista as pv\nfrom matplotlib.collections import LineCollection\n\n\ndef set_size(fraction=1, height_ratio=\"golden\", width=\"two-column\", subplots=(1, 1)):\n    if width == \"two-column\":\n        width_pt = 180  # mm\n    elif width == \"one-column\":\n        width_pt = 90  # mm\n    else:\n        width_pt = width\n\n    if height_ratio == \"golden\":\n        ratio_pt = (np.sqrt(5) - 1.0) / 2.0\n    else:\n        ratio_pt = height_ratio\n\n    fig_width_pt = width_pt * fraction\n    inches_per_pt = 1.0 / 25.4\n    fig_width_in = fig_width_pt * inches_per_pt\n    fig_height_in = fig_width_in * ratio_pt * (subplots[0] / subplots[1])\n    fig_dim = (fig_width_in, fig_height_in)\n\n    return fig_dim\n\n\ndef get_pv_grid(mesh: Mesh) -&gt; pv.UnstructuredGrid:\n    \"\"\"Convert Tatva mesh to PyVista UnstructuredGrid.\"\"\"\n    if mesh.coords.shape[1] == 2:\n        pv_points = np.hstack((mesh.coords, np.zeros(shape=(mesh.coords.shape[0], 1))))\n    else:\n        pv_points = np.array(mesh.coords)\n    cells = np.hstack(\n        [\n            np.full((mesh.elements.shape[0], 1), 3, dtype=np.int64),\n            np.array(mesh.elements, dtype=np.int64),\n        ]\n    )\n    grid = pv.UnstructuredGrid(\n        cells, np.full(mesh.elements.shape[0], pv.CellType.TRIANGLE), pv_points\n    )\n    return grid\n\n\ndef find_domain_boundary(elements):\n    edges = np.concatenate(\n        [elements[:, [0, 1]], elements[:, [1, 2]], elements[:, [2, 0]]], axis=0\n    )\n\n    edges_sorted = np.sort(edges, axis=1)\n\n    unique_edges, indices, counts = np.unique(\n        edges_sorted, axis=0, return_index=True, return_counts=True\n    )\n\n    boundary_edges = edges[indices[counts == 1]]\n\n    return boundary_edges\n\n\ngrad_u = op_plate.grad(u_sol)\nF = jnp.eye(2) + grad_u.squeeze()\n\ngrad_u_wo_fiber = op_plate.grad(u_sol_wo_fiber)\nF_wo_fiber = jnp.eye(2) + grad_u_wo_fiber.squeeze()\n\n\ndef add_bounding_box(ax):\n    rect = patches.Rectangle(\n        (x_min, y_min),\n        Lx,\n        Ly,\n        linewidth=0.5,\n        edgecolor=\"black\",\n        facecolor=\"none\",\n    )\n    ax.add_patch(rect)\n\n\ndef compute_strain_energy_flattened(F_flat):\n    F_mat = F_flat.reshape(-1, 2, 2)\n    return jnp.sum(strain_energy(F_mat, mat.mu, mat.lmbda))\n\n\ncompute_piola_kirchoff = jax.jacrev(compute_strain_energy_flattened, argnums=0)\nP = compute_piola_kirchoff(F.flatten()).reshape(-1, 2, 2)\nP_wo_fiber = compute_piola_kirchoff(F_wo_fiber.flatten()).reshape(-1, 2, 2)\n\ngrid = get_pv_grid(plate_mesh)\ngrid[\"sig_xx\"] = P[:, 0, 0] / P_wo_fiber[:, 0, 0]\ngrid[\"sig_yy\"] = P[:, 1, 1] / P_wo_fiber[:, 1, 1]\ngrid[\"sig_xy\"] = P[:, 0, 1] / P_wo_fiber[:, 0, 1]\ngrid[\"sig_xx_wo_fiber\"] = P_wo_fiber[:, 0, 0]\ngrid[\"sig_yy_wo_fiber\"] = P_wo_fiber[:, 1, 1]\ngrid[\"sig_xy_wo_fiber\"] = P_wo_fiber[:, 0, 1]\n\ngrid: pv.UnstructuredGrid = grid.cell_data_to_point_data()\nsample = grid.sample_over_line(\n    pointa=(x_min, y_max / 2, 0),\n    pointb=(x_min + Lx, y_max / 2, 0),\n    resolution=200,\n)\n\nu_quad = op_plate.eval(u_sol).squeeze()\nu_fiber = u_quad[host_indices]  # (N_seg, 2)\ngrad_u_fiber = op_line.grad(u_fiber)  # (N_seg, 1, 2)\n\ntriang = tri_mat.Triangulation(\n    plate_mesh.coords[:, 0] + u_sol[:, 0],\n    plate_mesh.coords[:, 1] + u_sol[:, 1],\n    plate_mesh.elements,\n)\n\n\nplt.style.use(\"./latex_sans_serif.mplstyle\")\nfig = plt.figure(\n    figsize=set_size(height_ratio=0.7, subplots=(2, 4)),\n    layout=\"constrained\",\n)\ngs = fig.add_gridspec(\n    1,\n    4,\n    width_ratios=[0.8, 0.4, 0.9, 0.7],\n    wspace=0.075,\n)\nax = fig.add_subplot(gs[0, 0])\nbx = fig.add_subplot(gs[0, 2])\nex = fig.add_subplot(gs[0, 3])\n\ncb = ax.tripcolor(\n    *plate_mesh.coords.T,\n    plate_mesh.elements,\n    facecolors=jnp.ones(plate_mesh.elements.shape[0]),\n    edgecolors=\"gray\",\n    lw=0.2,\n    alpha=0.8,\n    cmap=\"managua\",\n)\n\nadd_bounding_box(ax)\n\naxins = fig.add_subplot(gs[0, 1])\naxins.tripcolor(\n    *plate_mesh.coords.T,\n    plate_mesh.elements,\n    facecolors=jnp.ones(plate_mesh.elements.shape[0]),\n    edgecolors=\"gray\",\n    lw=0.2,\n    alpha=1.0,\n    cmap=\"managua\",\n)\naxins.set(xticks=[], yticks=[])\naxins.set_xlim(1.35, 1.5)\naxins.set_ylim(1.35, 1.5)\naxins.set_aspect(\"equal\", adjustable=\"box\")\naxins.grid(True)\nax.indicate_inset_zoom(axins, edgecolor=\"black\", linewidth=0.7)\n\n\ncb = bx.tripcolor(\n    triang,\n    grid[\"sig_yy\"].flatten(),\n    cmap=\"managua_r\",\n    shading=\"gouraud\",\n)\n\n\ncax = fig.add_axes((0.73, 0.375, 0.005, 0.275))\ncb = plt.colorbar(\n    cb,\n    cax=cax,\n    label=r\"$P_{yy}/P_{yy}^{o}$\",\n    shrink=0.7,\n    pad=0.01,\n    orientation=\"vertical\",\n)\ncb.ax.xaxis.set_label_position(\"top\")\n\nedge_elems = find_domain_boundary(plate_mesh.elements)\n\nsegments = plate_mesh.coords[edge_elems][:, :, :2]\ncoll_boundary = LineCollection(\n    segments + u_sol[edge_elems][:, :, :2], colors=\"k\", linewidths=0.7\n)\nbx.add_collection(coll_boundary)\n\nfor coords, disp in zip(\n    fiber_mesh.coords[fiber_mesh.elements], u_fiber[fiber_mesh.elements]\n):\n    axins.plot(\n        coords[:, 0],\n        coords[:, 1],\n        color=\"k\",\n        linewidth=1.5,\n        markersize=5,\n        marker=\"o\",\n    )\n    ax.plot(\n        coords[:, 0],\n        coords[:, 1],\n        color=\"k\",\n        marker=\"o\",\n        markersize=1,\n    )\n    bx.plot(\n        coords[:, 0] + disp[:, 0],\n        coords[:, 1] + disp[:, 1],\n        color=\"white\",\n        linewidth=0.5,\n    )\n\nsegments = fiber_mesh.coords[fiber_mesh.elements] + u_fiber[fiber_mesh.elements]\nlc = LineCollection(segments, linewidth=1.5, cmap=\"magma\")\nlc.set_array(grad_u_fiber.flatten())\n\nlines = ex.add_collection(lc)\ncax = fig.add_axes((0.835, 0.15, 0.1, 0.01))\ncb = plt.colorbar(\n    lines,\n    cax=cax,\n    label=r\"$\\varepsilon_S$\",\n    shrink=0.7,\n    pad=0.01,\n    orientation=\"horizontal\",\n)\ncb.ax.xaxis.set_label_position(\"top\")\n\n\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\n\n# ax.set_xlim([x_min - 0.1, x_min + Lx + 0.1])\n# ax.set_ylim([y_min - 0.1, y_min + Ly + 0.1])\nex.set_xlim([x_min + 0.35, x_min + Lx - 0.35])\nex.set_ylim([y_min + 0.35, y_min + Ly - 0.35])\nax.set_aspect(\"equal\", adjustable=\"box\")\nbx.set_aspect(\"equal\", adjustable=\"box\")\nex.set_aspect(\"equal\", adjustable=\"box\")\n\nax.grid(True)\nax.set(xlabel=r\"$x$\", ylabel=r\"$y$\")\nbx.set(xlabel=r\"$x$\")\nex.set(xlabel=r\"$x$\")\nbx.set_yticklabels([])\nbx.set_yticks([])\nbx.set_axis_off()\nex.set_yticklabels([])\nex.set_yticks([])\nex.set_axis_off()\nex.margins(0.01, 0.01)\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"examples/thermal_shock_fracture/","title":"Thermal-Shock Fracture","text":""},{"location":"examples/thermal_shock_fracture/#thermal-shock-fracture","title":"Thermal-Shock Fracture","text":"Colab Setup (Install Dependencies) <pre><code># Only run this if we are in Google Colab\nif 'google.colab' in str(get_ipython()):\n    print(\"Installing dependencies from pyproject.toml...\")\n    # This installs the repo itself (and its dependencies)\n    !apt-get install gmsh \n    !apt-get install -qq xvfb libgl1-mesa-glx\n    !pip install pyvista -qq\n    !pip install -q \"git+https://github.com/smec-ethz/tatva-docs.git\"    \n    print(\"Installation complete!\")\n</code></pre> <p>In this example, we demonstrate the power of the energy-centric approach by simulating a complex multiphysics problem: Thermal Shock Fracture where we will use Phase-field approach to simulate fracture process.</p> <p>A hot ceramic plate (\\(T_{initial} = 500^\\circ C\\)) is suddenly submerged in a cold bath (\\(T_{boundary} = 0^\\circ C\\)) . The rapid cooling creates tensile stresses on the surface, causing cracks to initiate and propagate inward.</p> <p>The Physics (3-Way Coupling):</p> <ul> <li>Thermal: Heat diffusion (potentially degraded by cracks).</li> <li>Mechanical: Thermal contraction creates stress; Stiffness is degraded by damage.</li> <li>Phase-Field: Damage evolves to minimize the stored elastic energy and surface energy.</li> </ul> <p>The total energy functional is:</p> \\[  \\Psi(u, T, d) = \\Psi_\\text{elastic}(u, T, d) + \\Psi_\\text{fracture}(d) + \\Psi_\\text{thermal}(T, d) \\] <p>Where the elastic energy is degraded by the damage variable \\(d\\):</p> \\[ \\Psi_\\text{elastic} = \\int_\\Omega \\left( (1-d)^2 + \\eta \\right) \\Psi^+_0(\\boldsymbol{\\epsilon}) \\, d\\Omega \\] <p>And the fracture energy follows the standard <code>AT2</code> regularization:</p> \\[ \\Psi_\\text{fracture} = G_c \\int_\\Omega \\left( \\frac{d^2}{2l_0} + \\frac{l_0}{2} |\\nabla d|^2 \\right) \\, d\\Omega \\] <p>This complex coupling is handled automatically by the Tatva engine.</p> <pre><code>import jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nfrom typing import NamedTuple\n\nimport equinox as eqx\nimport gmsh\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport meshio\nimport numpy as np\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator, element\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#model-setup","title":"Model Setup","text":"<p>We generate a fine, uniform mesh for a rectangular ceramic strip. The mesh size must be smaller than the phase field length scale \\(l_0\\).</p> Generate a strip mesh using gmsh <pre><code>def generate_strip_mesh(width: float, height: float, mesh_size: float):\n    import os\n\n    mesh_dir = os.path.join(os.getcwd(), \"../meshes\")\n    os.makedirs(mesh_dir, exist_ok=True)\n    output_filename = os.path.join(mesh_dir, \"strip_fine.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"strip\")\n\n    p1 = gmsh.model.geo.addPoint(0, 0, 0, mesh_size)\n    p2 = gmsh.model.geo.addPoint(width, 0, 0, mesh_size)\n    p3 = gmsh.model.geo.addPoint(width, height, 0, mesh_size)\n    p4 = gmsh.model.geo.addPoint(0, height, 0, mesh_size)\n\n    l1 = gmsh.model.geo.addLine(p1, p2)\n    l2 = gmsh.model.geo.addLine(p2, p3)\n    l3 = gmsh.model.geo.addLine(p3, p4)\n    l4 = gmsh.model.geo.addLine(p4, p1)\n\n    loop = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])\n    surface = gmsh.model.geo.addPlaneSurface([loop])\n\n    gmsh.model.geo.synchronize()\n    gmsh.model.addPhysicalGroup(2, [surface], 1, name=\"domain\")\n\n    # Boundary groups\n    gmsh.model.addPhysicalGroup(1, [l1, l2, l3, l4], 2, name=\"boundaries\")\n\n    gmsh.model.mesh.generate(2)\n    gmsh.write(output_filename)\n    gmsh.finalize()\n\n    _mesh = meshio.read(output_filename)\n    mesh = Mesh(coords=_mesh.points[:, :2], elements=_mesh.cells_dict[\"triangle\"])\n    return mesh\n</code></pre> <pre><code>L = 50  # Length mm\nH = 4.9  # Height mm\nl0 = 0.2  # 0.2 # Length scale parameter\nh_mesh = l0 / 2.0  # Mesh size must be approx l0/2\n\nmesh = generate_strip_mesh(width=L, height=H, mesh_size=h_mesh)\nn_nodes = mesh.coords.shape[0]\nprint(f\"Number of nodes: {n_nodes}\")\n\nplt.figure(figsize=(5, 5))\nax = plt.axes()\nax.tripcolor(\n    *mesh.coords.T,\n    mesh.elements,\n    facecolors=jnp.zeros(mesh.elements.shape[0]),\n    edgecolors=\"k\",\n    lw=0.1,\n    cmap=\"managua_r\",\n)\n\nax.axhline(0, color=\"k\", lw=0.4)\nax.set_aspect(\"equal\")\nax.margins(0.0, 0.0)\nplt.show()\n</code></pre> <pre><code>Info    : Meshing 1D...\nInfo    : [  0%] Meshing curve 1 (Line)\nInfo    : [ 30%] Meshing curve 2 (Line)\nInfo    : [ 60%] Meshing curve 3 (Line)\nInfo    : [ 80%] Meshing curve 4 (Line)\nInfo    : Done meshing 1D (Wall 0.000743599s, CPU 0.000928s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.891818s, CPU 0.880898s)\nInfo    : 29077 nodes 58156 elements\nInfo    : Writing '/home/pundir/Documents/research-notes/tatva-examples/examples/../meshes/strip_fine.msh'...\nInfo    : Done writing '/home/pundir/Documents/research-notes/tatva-examples/examples/../meshes/strip_fine.msh'\n\nNumber of nodes: 29077\n</code></pre> <p></p> <pre><code>class Material(NamedTuple):\n    E: float = 340e3  # Young's modulus (N/mm2)\n    nu: float = 0.2  # Poisson's ratio\n    alpha: float = 8e-6  # Thermal expansion (1/K)\n    kappa: float = 300  # Thermal conductivity\n    Gc: float = 0.042  # Critical energy release rate (Fracture toughness N/m)\n    l0: float = l0  # Phase field length scale\n\n\nmat = Material()\nmu = mat.E / (2 * (1 + mat.nu))\nlmbda = mat.E * mat.nu / ((1 + mat.nu) * (1 - 2 * mat.nu))\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#energy-functionals","title":"Energy Functionals","text":"<p>This is the core of the energy-centric approach. We define densities for Elasticity, Thermal, and Fracture.</p>"},{"location":"examples/thermal_shock_fracture/#coupled-elastic-energy","title":"Coupled Elastic Energy","text":"<p>Strain energy is driven by thermal contraction and degraded by damage:</p> \\[  \\psi_{el} = ((1-d)^2 + \\eta) \\cdot \\frac{1}{2} \\boldsymbol{\\epsilon}_{el} : \\mathbb{C} : \\boldsymbol{\\epsilon}_{el}  \\] <p>where \\(\\boldsymbol{\\epsilon}_{el} = \\boldsymbol{\\epsilon}_{total} - \\alpha \\Delta T \\mathbf{I}\\).</p> <pre><code>@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps: Array, mu: float, lmbda: float) -&gt; Array:\n    \"\"\"Compute the stress tensor from the strain tensor.\"\"\"\n    I = jnp.eye(2)\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * I\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef strain_energy(eps: Array, mu: float, lmbda: float) -&gt; Array:\n    \"\"\"Compute the strain energy density.\"\"\"\n    sig = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sig, eps)\n\n\n@autovmap(grad_u=2, theta_quad=0, mu=0, lmbda=0, alpha=0)\ndef compute_elastic_energy_density(\n    grad_u: Array, theta_quad: Array, mu: float, lmbda: float, alpha: float\n) -&gt; Array:\n    \"\"\"Computes the tensile part of the strain energy (driven by thermal contraction).\"\"\"\n\n    # Total Strain\n    eps_total = 0.5 * (grad_u + grad_u.T)\n\n    # Thermal Strain (Isotropic expansion/contraction)\n    eps_thermal = alpha * theta_quad * jnp.eye(2)\n\n    # Elastic Strain\n    eps_el = eps_total - eps_thermal\n\n    tr_eps = jnp.trace(eps_el)\n    tr_plus = jnp.maximum(tr_eps, 0.0)  # macalay_bracket_plus(tr_eps)\n    tr_minus = jnp.minimum(tr_eps, 0.0)  # macalay_bracket_minus(tr_eps)\n\n    # Volumetric/deviatoric split\n    dim = eps_el.shape[0]\n    eps_vol = (tr_eps / dim) * jnp.eye(2)\n    eps_dev = eps_el - eps_vol\n\n    K = lmbda + 2 * mu / dim  # Bulk modulus\n\n    # Volumetric and deviatoric strain energy densities\n    psi_vol = 0.5 * K * tr_plus**2 + mu * jnp.einsum(\"ij,ij-&gt;\", eps_dev, eps_dev)\n    psi_dev = 0.5 * K * tr_minus**2\n\n    return psi_vol, psi_dev\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#fracture-energy-phase-field","title":"Fracture Energy (Phase Field)","text":"<p>The geometric resistance to cracking.</p> \\[  \\underbrace{\\int_\\Omega \\Gamma \\left[ \\frac{(d-1)^2}{2l_0} + \\frac{l_0}{2} |\\nabla d|^2 \\right] ~ \\mathrm{d\\Omega}}_{\\text{Fracture Surface Energy}} \\] <p>We employ a \"History Field\" strategy. Damage is irreversible; it should only grow. A common way to handle this in phase-field is to drive damage by the maximum historical strain energy (\\(\\mathcal{H}\\)).</p> \\[ \\Psi_d = \\int_\\Omega \\left( [(1-d)^2 + \\eta] \\mathcal{H} + \\psi_{frac} \\right) d\\Omega \\] <pre><code>@autovmap(d=0)\ndef degradation_function(d: Array) -&gt; Array:\n    \"\"\"Degradation function g(d) = (1-d)^2 + small_residual\"\"\"\n    return (1.0 - d) ** 2 + 1e-6\n\n\n@autovmap(d=0, grad_d=1, Gc=0, l0=0)\ndef fracture_energy_density(d: Array, grad_d: Array, Gc: float, l0: float) -&gt; Array:\n    \"\"\"Griffith energy approximation.\"\"\"\n    w_d = (d**2) / (2 * l0)\n    w_grad = (l0 / 2.0) * jnp.dot(grad_d, grad_d)\n    return Gc * (w_d + w_grad)\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#thermal-problem-simple-transient-heat-equation","title":"Thermal Problem (Simple Transient Heat Equation)","text":"<p>We treat Thermal as a simple linear step for this demo (Backward Euler)</p> \\[ \\underbrace{\\int_\\Omega \\frac{1}{2}\\Delta t (T^{t}-T^{t-1})^2~\\mathrm{d\\Omega} + \\int_\\Omega \\kappa \\nabla T\\cdot\\nabla T~\\mathrm{d\\Omega}}_{\\text{Transient Heat Potential}, \\Psi_{\\mathrm{th}}} \\] <pre><code>@autovmap(grad_theta=1, kappa=0)\ndef thermal_energy_density(grad_theta: Array, kappa: float) -&gt; Array:\n    \"\"\"compute_thermal energy_density\n\n    Args:\n        grad_theta (Array): gradient of temperature field\n        kappa (float): thermal conductivity\n\n    Returns:\n        Array: thermal energy density\n    \"\"\"\n\n    return 0.5 * kappa * jnp.einsum(\"i, i-&gt;\", grad_theta, grad_theta)\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#total-energy-for-each-physical-process","title":"Total Energy for each physical process","text":"<p>We will now define the energy functional for each process. Since all the 3 process are happening int he same domain, we can define a sinle <code>Operator</code>.</p> <pre><code>tri = element.Tri3()\nop = Operator(mesh, tri)\n</code></pre> <p>First, we start with defining the total potential for thermal process. Here we define the temporal evolution.</p> <pre><code>@jax.jit\ndef total_thermal_energy(theta_new, theta_old, dt):\n    theta_new_quad = op.eval(theta_new)\n    theta_old_quad = op.eval(theta_old)\n\n    grad_theta = op.grad(theta_new)\n\n    diff_term = thermal_energy_density(grad_theta, mat.kappa)\n\n    inertial_term = (0.5 / dt) * (theta_new_quad - theta_old_quad) ** 2\n    return op.integrate(diff_term + inertial_term)\n</code></pre> <p>Next, we define the fracture and deformation total energies under quasi-static assumption.</p> <pre><code>@jax.jit\ndef total_damage_energy(d_flat: Array, history_field_quad: Array) -&gt; Array:\n    \"\"\"\n    Minimizing this w.r.t 'd' solves the Phase Field evolution.\n    Args:\n        d_flat: Nodal damage values\n        history_field_quad: Max historical strain energy at quadrature points\n    \"\"\"\n    grad_d = op.grad(d_flat)\n    d_quad = op.eval(d_flat)\n\n    g_d = degradation_function(d_quad)\n\n    strain_energy_comp = op.integrate(g_d * history_field_quad)\n\n    fracture_dens = fracture_energy_density(d_quad, grad_d, mat.Gc, mat.l0)\n    fracture_energy_comp = op.integrate(fracture_dens)\n\n    return strain_energy_comp + fracture_energy_comp\n\n\n@jax.jit\ndef total_strain_energy(\n    u_flat: Array, theta_flat: Array, theta_ref: Array, d_flat: Array\n) -&gt; Array:\n    \"\"\"\n    Minimizing this w.r.t 'u' solves Mechanical Equilibrium.\n    \"\"\"\n    u = u_flat.reshape(-1, 2)\n    grad_u = op.grad(u)\n    theta_quad = op.eval(theta_flat)\n    delta_theta = theta_quad - theta_ref\n    d_quad = op.eval(d_flat)\n\n    # Compute undegraded elastic energy density\n    psi_plus, psi_minus = compute_elastic_energy_density(\n        grad_u, delta_theta, mu, lmbda, mat.alpha\n    )\n\n    g_d = degradation_function(d_quad)\n\n    return op.integrate(g_d * psi_plus + psi_minus)\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#matrix-free-solvers-setup","title":"Matrix-Free Solvers Setup","text":"<p>We define our gradients (residuals) and tangent operators. Note the simplicity: we just ask <code>JAX</code> to differentiate the potentials. We use a projected conjugate gradient to apply the Diriechlet boundary conditions.</p> <pre><code>grad_thermal = jax.jacrev(total_thermal_energy, argnums=0)\ngrad_mechanical = jax.jacrev(total_strain_energy, argnums=0)\ngrad_damage = jax.jacrev(total_damage_energy, argnums=0)\n\n\n@eqx.filter_jit\ndef compute_tangent(dx, u_prev, gradient, fixed_dofs):\n    \"\"\"Generic Tangent Vector Product for any physics\"\"\"\n    dx_proj = dx.at[fixed_dofs].set(0)\n    tangent = jax.jvp(gradient, (u_prev,), (dx_proj,))[1]\n    return tangent.at[fixed_dofs].set(0)\n</code></pre> Newton-Krylov solver <pre><code>@eqx.filter_jit\ndef conjugate_gradient(A, b, atol=1e-8, max_iter=100):\n    iiter = 0\n\n    def body_fun(state):\n        b, p, r, rsold, x, iiter = state\n        Ap = A(p)\n        alpha = rsold / jnp.vdot(p, Ap)\n        x = x + jnp.dot(alpha, p)\n        r = r - jnp.dot(alpha, Ap)\n        rsnew = jnp.vdot(r, r)\n        p = r + (rsnew / rsold) * p\n        rsold = rsnew\n        iiter = iiter + 1\n        return (b, p, r, rsold, x, iiter)\n\n    def cond_fun(state):\n        b, p, r, rsold, x, iiter = state\n        return jnp.logical_and(jnp.sqrt(rsold) &gt; atol, iiter &lt; max_iter)\n\n    x = jnp.full_like(b, fill_value=0.0)\n    r = b - A(x)\n    p = r\n    rsold = jnp.vdot(r, p)\n\n    b, p, r, rsold, x, iiter = jax.lax.while_loop(\n        cond_fun, body_fun, (b, p, r, rsold, x, iiter)\n    )\n    return x, iiter\n\n\ndef newton_krylov_solver(\n    u,\n    fext,\n    gradient,\n    compute_tangent,\n    fixed_dofs,\n    tol: float = 1e-8,\n):\n    fint = gradient(u)\n\n    iiter = 0\n    norm_res = 1.0\n\n    max_iter = 80\n\n    while norm_res &gt; tol and iiter &lt; max_iter:\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n        A = eqx.Partial(\n            compute_tangent, u_prev=u, gradient=gradient, fixed_dofs=fixed_dofs\n        )\n        du, cg_iiter = conjugate_gradient(A=A, b=residual, atol=1e-8, max_iter=1000)\n\n        u = u.at[:].add(du)\n        fint = gradient(u)\n        residual = fext - fint\n        residual = residual.at[fixed_dofs].set(0)\n        norm_res = jnp.linalg.norm(residual)\n        iiter += 1\n\n        jax.debug.print(\n            \"  Newton Iteration {iiter}, Residual Norm: {norm_res:.3e}\",\n            iiter=iiter,\n            norm_res=norm_res,\n        )\n\n    return u, norm_res\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#applying-boundary-conditions","title":"Applying boundary conditions","text":"<pre><code>x_min = jnp.min(mesh.coords[:, 0])\nx_max = jnp.max(mesh.coords[:, 0])\ny_min = jnp.min(mesh.coords[:, 1])\ny_max = jnp.max(mesh.coords[:, 1])\n\n\neps_geo = 1e-5\nbnd_nodes = jnp.where(\n    (mesh.coords[:, 0] &lt; eps_geo)\n    | (mesh.coords[:, 0] &gt; L - eps_geo)\n    | (mesh.coords[:, 1] &lt; eps_geo)\n    | (mesh.coords[:, 1] &gt; H - eps_geo)\n)[0]\n\n\nleft_nodes = jnp.where(mesh.coords[:, 0] == x_min)[0]\nbottom_nodes = jnp.where(mesh.coords[:, 1] == y_min)[0]\ntop_nodes = jnp.where(mesh.coords[:, 1] == y_max)[0]\nright_nodes = jnp.where(mesh.coords[:, 0] == x_max)[0]\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#simulation-loop-the-staggered-solver","title":"Simulation Loop: The Staggered Solver","text":"<p>We implement a robust staggered scheme for Thermal Shock:</p> <ul> <li>Initialize: \\(T = 500\\), \\(d = 0\\).</li> <li>Apply BC: Boundary \\(T = 0\\).</li> <li>Time Loop:<ul> <li>Step A (Thermal): Solve heat diffusion.</li> <li>Step B (Coupling): Compute strain energy \\(\\Psi_0(u, T)\\) and update History \\(\\mathcal{H} = \\max(\\mathcal{H}, \\Psi_0)\\).</li> <li>Step C (Phase Field): Solve for \\(d\\) using \\(\\mathcal{H}\\).</li> <li>Step D (Mechanical): Solve for \\(u\\) using new \\(T\\) and \\(d\\).</li> </ul> </li> </ul> <pre><code>u_sol = jnp.zeros(n_nodes * 2)\nd_sol = jnp.zeros(n_nodes)\ntheta_sol = jnp.ones(n_nodes) * T_initial\n\nfext_u = jnp.zeros_like(u_sol)\nfext_d = jnp.zeros_like(d_sol)\nfext_th = jnp.zeros_like(theta_sol)\n\n\nfixed_dofs_th = jnp.concatenate([left_nodes, bottom_nodes])  # bnd_nodes\nfixed_vals_th = jnp.full(len(fixed_dofs_th), 300)  # Cold bath\n\nfixed_dofs_u = jnp.concatenate([2 * top_nodes + 1, 2 * right_nodes])\nfixed_dofs_d = jnp.array([], dtype=int)\n\nu_reshaped = u_sol.reshape(-1, 2)\ngrad_u = op.grad(u_reshaped)\ntheta_quad = op.eval(theta_sol)\ntheta_quad_ref = op.eval(theta_sol)\n\ndelta_theta = theta_quad - theta_quad_ref\n\npsi_plus, psi_minus = compute_elastic_energy_density(\n    grad_u, delta_theta, mu, lmbda, mat.alpha\n)\nhistory_field = psi_plus  # Start with initial elastic energy\n\ndt = 1e-5\nn_time_steps = 300\n\nresults_u = []\nresults_d = []\nresults_T = []\n\nprint(f\"Starting Simulation with {n_nodes} nodes...\")\n\nfor step in range(1, n_time_steps + 1):\n    print(f\"--- Time Step {step} ---\")\n\n    theta_sol = theta_sol.at[fixed_dofs_th].set(fixed_vals_th)\n\n    grad_fn_th = eqx.Partial(grad_thermal, theta_old=theta_sol, dt=dt)\n    theta_sol, norm_T = newton_krylov_solver(\n        theta_sol,\n        fext=fext_th,\n        gradient=grad_fn_th,\n        compute_tangent=compute_tangent,\n        fixed_dofs=fixed_dofs_th,\n        tol=1e-7,\n    )\n\n    for stag in range(1):\n        u_reshaped = u_sol.reshape(-1, 2)\n        grad_u = op.grad(u_reshaped)\n        theta_quad = op.eval(theta_sol)\n        delta_theta = theta_quad - theta_quad_ref\n\n        psi_plus_current, psi_minus_current = compute_elastic_energy_density(\n            grad_u, delta_theta, mu, lmbda, mat.alpha\n        )\n\n        history_field = jnp.maximum(history_field, psi_plus_current)\n\n        # Solve Phase Field\n        grad_fn_d = eqx.Partial(grad_damage, history_field_quad=history_field)\n        d_sol, norm_d = newton_krylov_solver(\n            d_sol,\n            fext=fext_d,\n            gradient=grad_fn_d,\n            compute_tangent=compute_tangent,\n            fixed_dofs=fixed_dofs_d,\n        )\n\n        # Solve Mechanical\n        grad_fn_u = eqx.Partial(\n            grad_mechanical,\n            theta_flat=theta_sol,\n            theta_ref=theta_quad_ref,\n            d_flat=d_sol,\n        )\n        u_sol, norm_u = newton_krylov_solver(\n            u_sol,\n            fext=fext_u,\n            gradient=grad_fn_u,\n            compute_tangent=compute_tangent,\n            fixed_dofs=fixed_dofs_u,\n        )\n\n        print(f\"   Iter {stag}: Res_d={norm_d:.2e}, Res_u={norm_u:.2e}\")\n\n    results_u.append(u_sol)\n    results_d.append(d_sol)\n    results_T.append(theta_sol)\n</code></pre> Output <pre><code>Starting Simulation with 29077 nodes...\n--- Time Step 1 ---\n  Newton Iteration 1, Residual Norm: 7.534e-09\n  Newton Iteration 1, Residual Norm: 8.811e-09\n  Newton Iteration 1, Residual Norm: 2.628e+00\n  Newton Iteration 2, Residual Norm: 9.845e-02\n  Newton Iteration 3, Residual Norm: 1.830e-04\n  Newton Iteration 4, Residual Norm: 9.949e-09\n   Iter 0: Res_d=8.81e-09, Res_u=9.95e-09\n--- Time Step 2 ---\n  Newton Iteration 1, Residual Norm: 9.717e-09\n  Newton Iteration 1, Residual Norm: 7.276e-09\n  Newton Iteration 1, Residual Norm: 2.461e+00\n  Newton Iteration 2, Residual Norm: 6.174e-02\n  Newton Iteration 3, Residual Norm: 1.400e-03\n  Newton Iteration 4, Residual Norm: 9.950e-09\n   Iter 0: Res_d=7.28e-09, Res_u=9.95e-09\n--- Time Step 3 ---\n  Newton Iteration 1, Residual Norm: 7.273e-09\n  Newton Iteration 1, Residual Norm: 7.093e-09\n  Newton Iteration 1, Residual Norm: 2.698e+00\n  Newton Iteration 2, Residual Norm: 4.024e-02\n  Newton Iteration 3, Residual Norm: 7.229e-08\n  Newton Iteration 4, Residual Norm: 9.886e-09\n   Iter 0: Res_d=7.09e-09, Res_u=9.89e-09\n--- Time Step 4 ---\n  Newton Iteration 1, Residual Norm: 6.295e-09\n  Newton Iteration 1, Residual Norm: 7.360e-09\n  Newton Iteration 1, Residual Norm: 2.560e+00\n  Newton Iteration 2, Residual Norm: 7.019e-03\n  Newton Iteration 3, Residual Norm: 1.604e-08\n  Newton Iteration 4, Residual Norm: 9.891e-09\n   Iter 0: Res_d=7.36e-09, Res_u=9.89e-09\n--- Time Step 5 ---\n  Newton Iteration 1, Residual Norm: 1.125e-08\n  Newton Iteration 1, Residual Norm: 7.035e-09\n  Newton Iteration 1, Residual Norm: 2.486e+00\n  Newton Iteration 2, Residual Norm: 7.051e-02\n  Newton Iteration 3, Residual Norm: 1.267e-07\n  Newton Iteration 4, Residual Norm: 9.808e-09\n   Iter 0: Res_d=7.03e-09, Res_u=9.81e-09\n--- Time Step 6 ---\n  Newton Iteration 1, Residual Norm: 9.629e-09\n  Newton Iteration 1, Residual Norm: 9.520e-09\n  Newton Iteration 1, Residual Norm: 2.519e+00\n  Newton Iteration 2, Residual Norm: 1.183e-02\n  Newton Iteration 3, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.52e-09, Res_u=9.99e-09\n--- Time Step 7 ---\n  Newton Iteration 1, Residual Norm: 8.810e-09\n  Newton Iteration 1, Residual Norm: 8.982e-09\n  Newton Iteration 1, Residual Norm: 2.355e+00\n  Newton Iteration 2, Residual Norm: 4.398e-02\n  Newton Iteration 3, Residual Norm: 3.317e-08\n  Newton Iteration 4, Residual Norm: 9.928e-09\n   Iter 0: Res_d=8.98e-09, Res_u=9.93e-09\n--- Time Step 8 ---\n  Newton Iteration 1, Residual Norm: 8.340e-09\n  Newton Iteration 1, Residual Norm: 8.461e-09\n  Newton Iteration 1, Residual Norm: 2.191e+00\n  Newton Iteration 2, Residual Norm: 3.990e-02\n  Newton Iteration 3, Residual Norm: 5.867e-08\n  Newton Iteration 4, Residual Norm: 9.918e-09\n   Iter 0: Res_d=8.46e-09, Res_u=9.92e-09\n--- Time Step 9 ---\n  Newton Iteration 1, Residual Norm: 8.168e-09\n  Newton Iteration 1, Residual Norm: 7.962e-09\n  Newton Iteration 1, Residual Norm: 2.128e+00\n  Newton Iteration 2, Residual Norm: 2.300e-03\n  Newton Iteration 3, Residual Norm: 1.308e-08\n  Newton Iteration 4, Residual Norm: 9.263e-09\n   Iter 0: Res_d=7.96e-09, Res_u=9.26e-09\n--- Time Step 10 ---\n  Newton Iteration 1, Residual Norm: 7.843e-09\n  Newton Iteration 1, Residual Norm: 7.491e-09\n  Newton Iteration 1, Residual Norm: 2.117e+00\n  Newton Iteration 2, Residual Norm: 1.578e-05\n  Newton Iteration 3, Residual Norm: 9.608e-09\n   Iter 0: Res_d=7.49e-09, Res_u=9.61e-09\n--- Time Step 11 ---\n  Newton Iteration 1, Residual Norm: 7.555e-09\n  Newton Iteration 1, Residual Norm: 7.055e-09\n  Newton Iteration 1, Residual Norm: 2.272e+00\n  Newton Iteration 2, Residual Norm: 5.456e-02\n  Newton Iteration 3, Residual Norm: 1.349e-07\n  Newton Iteration 4, Residual Norm: 9.966e-09\n   Iter 0: Res_d=7.05e-09, Res_u=9.97e-09\n--- Time Step 12 ---\n  Newton Iteration 1, Residual Norm: 7.382e-09\n  Newton Iteration 1, Residual Norm: 9.620e-09\n  Newton Iteration 1, Residual Norm: 2.146e+00\n  Newton Iteration 2, Residual Norm: 1.023e-03\n  Newton Iteration 3, Residual Norm: 9.963e-09\n   Iter 0: Res_d=9.62e-09, Res_u=9.96e-09\n--- Time Step 13 ---\n  Newton Iteration 1, Residual Norm: 7.400e-09\n  Newton Iteration 1, Residual Norm: 9.063e-09\n  Newton Iteration 1, Residual Norm: 1.995e+00\n  Newton Iteration 2, Residual Norm: 8.497e-03\n  Newton Iteration 3, Residual Norm: 4.222e-08\n  Newton Iteration 4, Residual Norm: 9.893e-09\n   Iter 0: Res_d=9.06e-09, Res_u=9.89e-09\n--- Time Step 14 ---\n  Newton Iteration 1, Residual Norm: 7.354e-09\n  Newton Iteration 1, Residual Norm: 8.571e-09\n  Newton Iteration 1, Residual Norm: 1.934e+00\n  Newton Iteration 2, Residual Norm: 1.452e-05\n  Newton Iteration 3, Residual Norm: 9.718e-09\n   Iter 0: Res_d=8.57e-09, Res_u=9.72e-09\n--- Time Step 15 ---\n  Newton Iteration 1, Residual Norm: 7.176e-09\n  Newton Iteration 1, Residual Norm: 8.130e-09\n  Newton Iteration 1, Residual Norm: 1.830e+00\n  Newton Iteration 2, Residual Norm: 1.456e-05\n  Newton Iteration 3, Residual Norm: 9.604e-09\n   Iter 0: Res_d=8.13e-09, Res_u=9.60e-09\n--- Time Step 16 ---\n  Newton Iteration 1, Residual Norm: 7.138e-09\n  Newton Iteration 1, Residual Norm: 7.738e-09\n  Newton Iteration 1, Residual Norm: 1.672e+00\n  Newton Iteration 2, Residual Norm: 3.576e-02\n  Newton Iteration 3, Residual Norm: 9.868e-09\n   Iter 0: Res_d=7.74e-09, Res_u=9.87e-09\n--- Time Step 17 ---\n  Newton Iteration 1, Residual Norm: 7.264e-09\n  Newton Iteration 1, Residual Norm: 7.383e-09\n  Newton Iteration 1, Residual Norm: 1.583e+00\n  Newton Iteration 2, Residual Norm: 9.864e-03\n  Newton Iteration 3, Residual Norm: 3.459e-08\n  Newton Iteration 4, Residual Norm: 9.830e-09\n   Iter 0: Res_d=7.38e-09, Res_u=9.83e-09\n--- Time Step 18 ---\n  Newton Iteration 1, Residual Norm: 1.196e-08\n  Newton Iteration 1, Residual Norm: 7.063e-09\n  Newton Iteration 1, Residual Norm: 1.472e+00\n  Newton Iteration 2, Residual Norm: 1.365e-02\n  Newton Iteration 3, Residual Norm: 2.201e-08\n  Newton Iteration 4, Residual Norm: 9.965e-09\n   Iter 0: Res_d=7.06e-09, Res_u=9.97e-09\n--- Time Step 19 ---\n  Newton Iteration 1, Residual Norm: 1.142e-08\n  Newton Iteration 1, Residual Norm: 6.778e-09\n  Newton Iteration 1, Residual Norm: 1.324e+00\n  Newton Iteration 2, Residual Norm: 9.998e-06\n  Newton Iteration 3, Residual Norm: 9.871e-09\n   Iter 0: Res_d=6.78e-09, Res_u=9.87e-09\n--- Time Step 20 ---\n  Newton Iteration 1, Residual Norm: 1.104e-08\n  Newton Iteration 1, Residual Norm: 9.657e-09\n  Newton Iteration 1, Residual Norm: 1.355e+00\n  Newton Iteration 2, Residual Norm: 3.874e-02\n  Newton Iteration 3, Residual Norm: 7.203e-08\n  Newton Iteration 4, Residual Norm: 9.848e-09\n   Iter 0: Res_d=9.66e-09, Res_u=9.85e-09\n--- Time Step 21 ---\n  Newton Iteration 1, Residual Norm: 1.079e-08\n  Newton Iteration 1, Residual Norm: 9.303e-09\n  Newton Iteration 1, Residual Norm: 1.238e+00\n  Newton Iteration 2, Residual Norm: 4.336e-02\n  Newton Iteration 3, Residual Norm: 1.105e-07\n  Newton Iteration 4, Residual Norm: 9.839e-09\n   Iter 0: Res_d=9.30e-09, Res_u=9.84e-09\n--- Time Step 22 ---\n  Newton Iteration 1, Residual Norm: 1.041e-08\n  Newton Iteration 1, Residual Norm: 8.978e-09\n  Newton Iteration 1, Residual Norm: 1.132e+00\n  Newton Iteration 2, Residual Norm: 3.589e-03\n  Newton Iteration 3, Residual Norm: 1.795e-08\n  Newton Iteration 4, Residual Norm: 9.901e-09\n   Iter 0: Res_d=8.98e-09, Res_u=9.90e-09\n--- Time Step 23 ---\n  Newton Iteration 1, Residual Norm: 1.004e-08\n  Newton Iteration 1, Residual Norm: 8.678e-09\n  Newton Iteration 1, Residual Norm: 1.066e+00\n  Newton Iteration 2, Residual Norm: 1.481e-02\n  Newton Iteration 3, Residual Norm: 2.966e-08\n  Newton Iteration 4, Residual Norm: 9.872e-09\n   Iter 0: Res_d=8.68e-09, Res_u=9.87e-09\n--- Time Step 24 ---\n  Newton Iteration 1, Residual Norm: 9.876e-09\n  Newton Iteration 1, Residual Norm: 8.409e-09\n  Newton Iteration 1, Residual Norm: 1.141e+00\n  Newton Iteration 2, Residual Norm: 5.067e-03\n  Newton Iteration 3, Residual Norm: 2.777e-08\n  Newton Iteration 4, Residual Norm: 9.916e-09\n   Iter 0: Res_d=8.41e-09, Res_u=9.92e-09\n--- Time Step 25 ---\n  Newton Iteration 1, Residual Norm: 9.656e-09\n  Newton Iteration 1, Residual Norm: 8.168e-09\n  Newton Iteration 1, Residual Norm: 1.285e+00\n  Newton Iteration 2, Residual Norm: 3.608e-02\n  Newton Iteration 3, Residual Norm: 8.784e-08\n  Newton Iteration 4, Residual Norm: 9.945e-09\n   Iter 0: Res_d=8.17e-09, Res_u=9.94e-09\n--- Time Step 26 ---\n  Newton Iteration 1, Residual Norm: 9.570e-09\n  Newton Iteration 1, Residual Norm: 7.955e-09\n  Newton Iteration 1, Residual Norm: 1.247e+00\n  Newton Iteration 2, Residual Norm: 8.309e-03\n  Newton Iteration 3, Residual Norm: 2.384e-08\n  Newton Iteration 4, Residual Norm: 9.826e-09\n   Iter 0: Res_d=7.96e-09, Res_u=9.83e-09\n--- Time Step 27 ---\n  Newton Iteration 1, Residual Norm: 9.323e-09\n  Newton Iteration 1, Residual Norm: 7.774e-09\n  Newton Iteration 1, Residual Norm: 1.160e+00\n  Newton Iteration 2, Residual Norm: 9.526e-06\n  Newton Iteration 3, Residual Norm: 9.881e-09\n   Iter 0: Res_d=7.77e-09, Res_u=9.88e-09\n--- Time Step 28 ---\n  Newton Iteration 1, Residual Norm: 9.159e-09\n  Newton Iteration 1, Residual Norm: 7.639e-09\n  Newton Iteration 1, Residual Norm: 1.077e+00\n  Newton Iteration 2, Residual Norm: 6.540e-06\n  Newton Iteration 3, Residual Norm: 9.911e-09\n   Iter 0: Res_d=7.64e-09, Res_u=9.91e-09\n--- Time Step 29 ---\n  Newton Iteration 1, Residual Norm: 9.069e-09\n  Newton Iteration 1, Residual Norm: 7.545e-09\n  Newton Iteration 1, Residual Norm: 9.985e-01\n  Newton Iteration 2, Residual Norm: 6.834e-06\n  Newton Iteration 3, Residual Norm: 9.886e-09\n   Iter 0: Res_d=7.54e-09, Res_u=9.89e-09\n--- Time Step 30 ---\n  Newton Iteration 1, Residual Norm: 9.265e-09\n  Newton Iteration 1, Residual Norm: 7.495e-09\n  Newton Iteration 1, Residual Norm: 9.426e-01\n  Newton Iteration 2, Residual Norm: 9.308e-06\n  Newton Iteration 3, Residual Norm: 9.968e-09\n   Iter 0: Res_d=7.49e-09, Res_u=9.97e-09\n--- Time Step 31 ---\n  Newton Iteration 1, Residual Norm: 9.002e-09\n  Newton Iteration 1, Residual Norm: 7.503e-09\n  Newton Iteration 1, Residual Norm: 8.794e-01\n  Newton Iteration 2, Residual Norm: 1.352e-02\n  Newton Iteration 3, Residual Norm: 1.874e-08\n  Newton Iteration 4, Residual Norm: 9.918e-09\n   Iter 0: Res_d=7.50e-09, Res_u=9.92e-09\n--- Time Step 32 ---\n  Newton Iteration 1, Residual Norm: 9.212e-09\n  Newton Iteration 1, Residual Norm: 7.573e-09\n  Newton Iteration 1, Residual Norm: 8.145e-01\n  Newton Iteration 2, Residual Norm: 7.588e-04\n  Newton Iteration 3, Residual Norm: 9.995e-09\n   Iter 0: Res_d=7.57e-09, Res_u=9.99e-09\n--- Time Step 33 ---\n  Newton Iteration 1, Residual Norm: 9.146e-09\n  Newton Iteration 1, Residual Norm: 7.708e-09\n  Newton Iteration 1, Residual Norm: 7.554e-01\n  Newton Iteration 2, Residual Norm: 2.281e-03\n  Newton Iteration 3, Residual Norm: 1.530e-08\n  Newton Iteration 4, Residual Norm: 9.967e-09\n   Iter 0: Res_d=7.71e-09, Res_u=9.97e-09\n--- Time Step 34 ---\n  Newton Iteration 1, Residual Norm: 8.893e-09\n  Newton Iteration 1, Residual Norm: 7.906e-09\n  Newton Iteration 1, Residual Norm: 7.864e-01\n  Newton Iteration 2, Residual Norm: 1.338e-03\n  Newton Iteration 3, Residual Norm: 9.986e-09\n   Iter 0: Res_d=7.91e-09, Res_u=9.99e-09\n--- Time Step 35 ---\n  Newton Iteration 1, Residual Norm: 8.821e-09\n  Newton Iteration 1, Residual Norm: 8.176e-09\n  Newton Iteration 1, Residual Norm: 7.911e-01\n  Newton Iteration 2, Residual Norm: 1.309e-02\n  Newton Iteration 3, Residual Norm: 4.312e-08\n  Newton Iteration 4, Residual Norm: 9.868e-09\n   Iter 0: Res_d=8.18e-09, Res_u=9.87e-09\n--- Time Step 36 ---\n  Newton Iteration 1, Residual Norm: 8.825e-09\n  Newton Iteration 1, Residual Norm: 8.525e-09\n  Newton Iteration 1, Residual Norm: 7.526e-01\n  Newton Iteration 2, Residual Norm: 2.105e-02\n  Newton Iteration 3, Residual Norm: 7.817e-08\n  Newton Iteration 4, Residual Norm: 9.907e-09\n   Iter 0: Res_d=8.52e-09, Res_u=9.91e-09\n--- Time Step 37 ---\n  Newton Iteration 1, Residual Norm: 8.843e-09\n  Newton Iteration 1, Residual Norm: 8.987e-09\n  Newton Iteration 1, Residual Norm: 7.248e-01\n  Newton Iteration 2, Residual Norm: 8.546e-06\n  Newton Iteration 3, Residual Norm: 9.845e-09\n   Iter 0: Res_d=8.99e-09, Res_u=9.84e-09\n--- Time Step 38 ---\n  Newton Iteration 1, Residual Norm: 8.698e-09\n  Newton Iteration 1, Residual Norm: 9.670e-09\n  Newton Iteration 1, Residual Norm: 6.749e-01\n  Newton Iteration 2, Residual Norm: 8.233e-06\n  Newton Iteration 3, Residual Norm: 9.869e-09\n   Iter 0: Res_d=9.67e-09, Res_u=9.87e-09\n--- Time Step 39 ---\n  Newton Iteration 1, Residual Norm: 8.803e-09\n  Newton Iteration 1, Residual Norm: 7.290e-09\n  Newton Iteration 1, Residual Norm: 6.483e-01\n  Newton Iteration 2, Residual Norm: 9.672e-06\n  Newton Iteration 3, Residual Norm: 9.897e-09\n   Iter 0: Res_d=7.29e-09, Res_u=9.90e-09\n--- Time Step 40 ---\n  Newton Iteration 1, Residual Norm: 8.734e-09\n  Newton Iteration 1, Residual Norm: 7.998e-09\n  Newton Iteration 1, Residual Norm: 6.202e-01\n  Newton Iteration 2, Residual Norm: 8.811e-06\n  Newton Iteration 3, Residual Norm: 9.984e-09\n   Iter 0: Res_d=8.00e-09, Res_u=9.98e-09\n--- Time Step 41 ---\n  Newton Iteration 1, Residual Norm: 8.873e-09\n  Newton Iteration 1, Residual Norm: 9.278e-09\n  Newton Iteration 1, Residual Norm: 6.044e-01\n  Newton Iteration 2, Residual Norm: 9.493e-06\n  Newton Iteration 3, Residual Norm: 9.718e-09\n   Iter 0: Res_d=9.28e-09, Res_u=9.72e-09\n--- Time Step 42 ---\n  Newton Iteration 1, Residual Norm: 8.744e-09\n  Newton Iteration 1, Residual Norm: 6.872e-09\n  Newton Iteration 1, Residual Norm: 6.055e-01\n  Newton Iteration 2, Residual Norm: 1.457e-02\n  Newton Iteration 3, Residual Norm: 8.320e-08\n  Newton Iteration 4, Residual Norm: 9.813e-09\n   Iter 0: Res_d=6.87e-09, Res_u=9.81e-09\n--- Time Step 43 ---\n  Newton Iteration 1, Residual Norm: 8.743e-09\n  Newton Iteration 1, Residual Norm: 7.323e-09\n  Newton Iteration 1, Residual Norm: 6.258e-01\n  Newton Iteration 2, Residual Norm: 1.491e-05\n  Newton Iteration 3, Residual Norm: 2.162e-08\n  Newton Iteration 4, Residual Norm: 9.868e-09\n   Iter 0: Res_d=7.32e-09, Res_u=9.87e-09\n--- Time Step 44 ---\n  Newton Iteration 1, Residual Norm: 8.811e-09\n  Newton Iteration 1, Residual Norm: 7.562e-09\n  Newton Iteration 1, Residual Norm: 6.547e-01\n  Newton Iteration 2, Residual Norm: 3.664e-05\n  Newton Iteration 3, Residual Norm: 1.942e-07\n  Newton Iteration 4, Residual Norm: 9.952e-09\n   Iter 0: Res_d=7.56e-09, Res_u=9.95e-09\n--- Time Step 45 ---\n  Newton Iteration 1, Residual Norm: 8.573e-09\n  Newton Iteration 1, Residual Norm: 8.712e-09\n  Newton Iteration 1, Residual Norm: 7.094e-01\n  Newton Iteration 2, Residual Norm: 6.399e-03\n  Newton Iteration 3, Residual Norm: 4.237e-06\n  Newton Iteration 4, Residual Norm: 5.928e-08\n  Newton Iteration 5, Residual Norm: 9.917e-09\n   Iter 0: Res_d=8.71e-09, Res_u=9.92e-09\n--- Time Step 46 ---\n  Newton Iteration 1, Residual Norm: 8.811e-09\n  Newton Iteration 1, Residual Norm: 8.565e-09\n  Newton Iteration 1, Residual Norm: 6.939e-01\n  Newton Iteration 2, Residual Norm: 2.475e-04\n  Newton Iteration 3, Residual Norm: 3.530e-06\n  Newton Iteration 4, Residual Norm: 3.912e-08\n  Newton Iteration 5, Residual Norm: 9.971e-09\n   Iter 0: Res_d=8.57e-09, Res_u=9.97e-09\n--- Time Step 47 ---\n  Newton Iteration 1, Residual Norm: 8.670e-09\n  Newton Iteration 1, Residual Norm: 8.926e-09\n  Newton Iteration 1, Residual Norm: 7.206e-01\n  Newton Iteration 2, Residual Norm: 4.134e-04\n  Newton Iteration 3, Residual Norm: 1.000e-05\n  Newton Iteration 4, Residual Norm: 1.274e-07\n  Newton Iteration 5, Residual Norm: 9.974e-09\n   Iter 0: Res_d=8.93e-09, Res_u=9.97e-09\n--- Time Step 48 ---\n  Newton Iteration 1, Residual Norm: 8.760e-09\n  Newton Iteration 1, Residual Norm: 7.555e-09\n  Newton Iteration 1, Residual Norm: 7.654e-01\n  Newton Iteration 2, Residual Norm: 1.989e-04\n  Newton Iteration 3, Residual Norm: 9.525e-06\n  Newton Iteration 4, Residual Norm: 6.785e-08\n  Newton Iteration 5, Residual Norm: 9.954e-09\n   Iter 0: Res_d=7.55e-09, Res_u=9.95e-09\n--- Time Step 49 ---\n  Newton Iteration 1, Residual Norm: 8.540e-09\n  Newton Iteration 1, Residual Norm: 9.982e-09\n  Newton Iteration 1, Residual Norm: 7.868e-01\n  Newton Iteration 2, Residual Norm: 6.032e-03\n  Newton Iteration 3, Residual Norm: 1.917e-05\n  Newton Iteration 4, Residual Norm: 5.669e-07\n  Newton Iteration 5, Residual Norm: 9.945e-09\n   Iter 0: Res_d=9.98e-09, Res_u=9.94e-09\n--- Time Step 50 ---\n  Newton Iteration 1, Residual Norm: 8.824e-09\n  Newton Iteration 1, Residual Norm: 8.977e-09\n  Newton Iteration 1, Residual Norm: 8.152e-01\n  Newton Iteration 2, Residual Norm: 2.084e-03\n  Newton Iteration 3, Residual Norm: 1.551e-04\n  Newton Iteration 4, Residual Norm: 3.162e-06\n  Newton Iteration 5, Residual Norm: 2.212e-07\n  Newton Iteration 6, Residual Norm: 9.988e-09\n   Iter 0: Res_d=8.98e-09, Res_u=9.99e-09\n--- Time Step 51 ---\n  Newton Iteration 1, Residual Norm: 8.477e-09\n  Newton Iteration 1, Residual Norm: 9.121e-09\n  Newton Iteration 1, Residual Norm: 8.338e-01\n  Newton Iteration 2, Residual Norm: 2.306e-03\n  Newton Iteration 3, Residual Norm: 1.373e-04\n  Newton Iteration 4, Residual Norm: 3.365e-06\n  Newton Iteration 5, Residual Norm: 3.465e-07\n  Newton Iteration 6, Residual Norm: 9.922e-09\n   Iter 0: Res_d=9.12e-09, Res_u=9.92e-09\n--- Time Step 52 ---\n  Newton Iteration 1, Residual Norm: 8.667e-09\n  Newton Iteration 1, Residual Norm: 9.720e-09\n  Newton Iteration 1, Residual Norm: 7.894e-01\n  Newton Iteration 2, Residual Norm: 2.061e-03\n  Newton Iteration 3, Residual Norm: 1.867e-04\n  Newton Iteration 4, Residual Norm: 4.311e-06\n  Newton Iteration 5, Residual Norm: 4.798e-07\n  Newton Iteration 6, Residual Norm: 9.977e-09\n   Iter 0: Res_d=9.72e-09, Res_u=9.98e-09\n--- Time Step 53 ---\n  Newton Iteration 1, Residual Norm: 8.566e-09\n  Newton Iteration 1, Residual Norm: 9.666e-09\n  Newton Iteration 1, Residual Norm: 8.043e-01\n  Newton Iteration 2, Residual Norm: 2.220e-03\n  Newton Iteration 3, Residual Norm: 2.159e-04\n  Newton Iteration 4, Residual Norm: 4.922e-06\n  Newton Iteration 5, Residual Norm: 5.199e-07\n  Newton Iteration 6, Residual Norm: 1.382e-08\n  Newton Iteration 7, Residual Norm: 9.748e-09\n   Iter 0: Res_d=9.67e-09, Res_u=9.75e-09\n--- Time Step 54 ---\n  Newton Iteration 1, Residual Norm: 1.277e-08\n  Newton Iteration 1, Residual Norm: 9.377e-09\n  Newton Iteration 1, Residual Norm: 8.083e-01\n  Newton Iteration 2, Residual Norm: 1.863e-03\n  Newton Iteration 3, Residual Norm: 1.575e-04\n  Newton Iteration 4, Residual Norm: 4.521e-06\n  Newton Iteration 5, Residual Norm: 3.932e-07\n  Newton Iteration 6, Residual Norm: 9.967e-09\n   Iter 0: Res_d=9.38e-09, Res_u=9.97e-09\n--- Time Step 55 ---\n  Newton Iteration 1, Residual Norm: 1.257e-08\n  Newton Iteration 1, Residual Norm: 8.121e-09\n  Newton Iteration 1, Residual Norm: 7.197e-01\n  Newton Iteration 2, Residual Norm: 1.340e-03\n  Newton Iteration 3, Residual Norm: 1.290e-04\n  Newton Iteration 4, Residual Norm: 2.823e-06\n  Newton Iteration 5, Residual Norm: 3.093e-07\n  Newton Iteration 6, Residual Norm: 9.967e-09\n   Iter 0: Res_d=8.12e-09, Res_u=9.97e-09\n--- Time Step 56 ---\n  Newton Iteration 1, Residual Norm: 1.243e-08\n  Newton Iteration 1, Residual Norm: 8.669e-09\n  Newton Iteration 1, Residual Norm: 7.299e-01\n  Newton Iteration 2, Residual Norm: 1.875e-03\n  Newton Iteration 3, Residual Norm: 8.515e-05\n  Newton Iteration 4, Residual Norm: 3.916e-06\n  Newton Iteration 5, Residual Norm: 2.572e-07\n  Newton Iteration 6, Residual Norm: 9.846e-09\n   Iter 0: Res_d=8.67e-09, Res_u=9.85e-09\n--- Time Step 57 ---\n  Newton Iteration 1, Residual Norm: 1.220e-08\n  Newton Iteration 1, Residual Norm: 9.867e-09\n  Newton Iteration 1, Residual Norm: 6.807e-01\n  Newton Iteration 2, Residual Norm: 1.007e-03\n  Newton Iteration 3, Residual Norm: 9.281e-05\n  Newton Iteration 4, Residual Norm: 2.975e-06\n  Newton Iteration 5, Residual Norm: 5.067e-07\n  Newton Iteration 6, Residual Norm: 1.308e-08\n  Newton Iteration 7, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.87e-09, Res_u=1.00e-08\n--- Time Step 58 ---\n  Newton Iteration 1, Residual Norm: 1.216e-08\n  Newton Iteration 1, Residual Norm: 9.952e-09\n  Newton Iteration 1, Residual Norm: 6.562e-01\n  Newton Iteration 2, Residual Norm: 1.058e-03\n  Newton Iteration 3, Residual Norm: 1.251e-04\n  Newton Iteration 4, Residual Norm: 6.511e-06\n  Newton Iteration 5, Residual Norm: 6.980e-07\n  Newton Iteration 6, Residual Norm: 3.901e-08\n  Newton Iteration 7, Residual Norm: 9.881e-09\n   Iter 0: Res_d=9.95e-09, Res_u=9.88e-09\n--- Time Step 59 ---\n  Newton Iteration 1, Residual Norm: 1.209e-08\n  Newton Iteration 1, Residual Norm: 8.139e-09\n  Newton Iteration 1, Residual Norm: 6.503e-01\n  Newton Iteration 2, Residual Norm: 5.078e-03\n  Newton Iteration 3, Residual Norm: 1.035e-04\n  Newton Iteration 4, Residual Norm: 7.548e-06\n  Newton Iteration 5, Residual Norm: 4.960e-07\n  Newton Iteration 6, Residual Norm: 5.666e-08\n  Newton Iteration 7, Residual Norm: 9.958e-09\n   Iter 0: Res_d=8.14e-09, Res_u=9.96e-09\n--- Time Step 60 ---\n  Newton Iteration 1, Residual Norm: 1.195e-08\n  Newton Iteration 1, Residual Norm: 8.987e-09\n  Newton Iteration 1, Residual Norm: 6.455e-01\n  Newton Iteration 2, Residual Norm: 2.636e-03\n  Newton Iteration 3, Residual Norm: 1.101e-04\n  Newton Iteration 4, Residual Norm: 7.397e-06\n  Newton Iteration 5, Residual Norm: 7.836e-07\n  Newton Iteration 6, Residual Norm: 5.182e-08\n  Newton Iteration 7, Residual Norm: 9.965e-09\n   Iter 0: Res_d=8.99e-09, Res_u=9.96e-09\n--- Time Step 61 ---\n  Newton Iteration 1, Residual Norm: 1.193e-08\n  Newton Iteration 1, Residual Norm: 7.839e-09\n  Newton Iteration 1, Residual Norm: 6.418e-01\n  Newton Iteration 2, Residual Norm: 1.050e-03\n  Newton Iteration 3, Residual Norm: 6.140e-05\n  Newton Iteration 4, Residual Norm: 2.128e-06\n  Newton Iteration 5, Residual Norm: 2.977e-07\n  Newton Iteration 6, Residual Norm: 9.928e-09\n   Iter 0: Res_d=7.84e-09, Res_u=9.93e-09\n--- Time Step 62 ---\n  Newton Iteration 1, Residual Norm: 1.183e-08\n  Newton Iteration 1, Residual Norm: 8.825e-09\n  Newton Iteration 1, Residual Norm: 6.193e-01\n  Newton Iteration 2, Residual Norm: 9.952e-04\n  Newton Iteration 3, Residual Norm: 5.407e-05\n  Newton Iteration 4, Residual Norm: 4.289e-06\n  Newton Iteration 5, Residual Norm: 3.893e-07\n  Newton Iteration 6, Residual Norm: 3.003e-08\n  Newton Iteration 7, Residual Norm: 9.991e-09\n   Iter 0: Res_d=8.82e-09, Res_u=9.99e-09\n--- Time Step 63 ---\n  Newton Iteration 1, Residual Norm: 1.174e-08\n  Newton Iteration 1, Residual Norm: 8.446e-09\n  Newton Iteration 1, Residual Norm: 5.566e-01\n  Newton Iteration 2, Residual Norm: 4.694e-04\n  Newton Iteration 3, Residual Norm: 4.052e-05\n  Newton Iteration 4, Residual Norm: 2.759e-06\n  Newton Iteration 5, Residual Norm: 2.310e-07\n  Newton Iteration 6, Residual Norm: 1.686e-08\n  Newton Iteration 7, Residual Norm: 9.935e-09\n   Iter 0: Res_d=8.45e-09, Res_u=9.93e-09\n--- Time Step 64 ---\n  Newton Iteration 1, Residual Norm: 1.166e-08\n  Newton Iteration 1, Residual Norm: 9.839e-09\n  Newton Iteration 1, Residual Norm: 5.417e-01\n  Newton Iteration 2, Residual Norm: 4.569e-04\n  Newton Iteration 3, Residual Norm: 4.481e-05\n  Newton Iteration 4, Residual Norm: 2.482e-06\n  Newton Iteration 5, Residual Norm: 2.516e-07\n  Newton Iteration 6, Residual Norm: 1.795e-08\n  Newton Iteration 7, Residual Norm: 9.931e-09\n   Iter 0: Res_d=9.84e-09, Res_u=9.93e-09\n--- Time Step 65 ---\n  Newton Iteration 1, Residual Norm: 1.143e-08\n  Newton Iteration 1, Residual Norm: 8.049e-09\n  Newton Iteration 1, Residual Norm: 5.362e-01\n  Newton Iteration 2, Residual Norm: 2.820e-04\n  Newton Iteration 3, Residual Norm: 3.003e-05\n  Newton Iteration 4, Residual Norm: 1.252e-06\n  Newton Iteration 5, Residual Norm: 1.690e-07\n  Newton Iteration 6, Residual Norm: 9.944e-09\n   Iter 0: Res_d=8.05e-09, Res_u=9.94e-09\n--- Time Step 66 ---\n  Newton Iteration 1, Residual Norm: 1.141e-08\n  Newton Iteration 1, Residual Norm: 8.124e-09\n  Newton Iteration 1, Residual Norm: 5.258e-01\n  Newton Iteration 2, Residual Norm: 4.935e-04\n  Newton Iteration 3, Residual Norm: 5.971e-06\n  Newton Iteration 4, Residual Norm: 7.388e-07\n  Newton Iteration 5, Residual Norm: 5.436e-08\n  Newton Iteration 6, Residual Norm: 9.940e-09\n   Iter 0: Res_d=8.12e-09, Res_u=9.94e-09\n--- Time Step 67 ---\n  Newton Iteration 1, Residual Norm: 1.134e-08\n  Newton Iteration 1, Residual Norm: 9.796e-09\n  Newton Iteration 1, Residual Norm: 5.352e-01\n  Newton Iteration 2, Residual Norm: 1.829e-04\n  Newton Iteration 3, Residual Norm: 9.848e-06\n  Newton Iteration 4, Residual Norm: 6.483e-07\n  Newton Iteration 5, Residual Norm: 3.586e-08\n  Newton Iteration 6, Residual Norm: 9.967e-09\n   Iter 0: Res_d=9.80e-09, Res_u=9.97e-09\n--- Time Step 68 ---\n  Newton Iteration 1, Residual Norm: 1.131e-08\n  Newton Iteration 1, Residual Norm: 9.643e-09\n  Newton Iteration 1, Residual Norm: 5.448e-01\n  Newton Iteration 2, Residual Norm: 5.638e-04\n  Newton Iteration 3, Residual Norm: 1.951e-05\n  Newton Iteration 4, Residual Norm: 1.639e-06\n  Newton Iteration 5, Residual Norm: 8.118e-08\n  Newton Iteration 6, Residual Norm: 9.993e-09\n   Iter 0: Res_d=9.64e-09, Res_u=9.99e-09\n--- Time Step 69 ---\n  Newton Iteration 1, Residual Norm: 1.116e-08\n  Newton Iteration 1, Residual Norm: 9.780e-09\n  Newton Iteration 1, Residual Norm: 5.382e-01\n  Newton Iteration 2, Residual Norm: 8.017e-04\n  Newton Iteration 3, Residual Norm: 3.885e-05\n  Newton Iteration 4, Residual Norm: 3.266e-06\n  Newton Iteration 5, Residual Norm: 2.328e-07\n  Newton Iteration 6, Residual Norm: 3.114e-08\n  Newton Iteration 7, Residual Norm: 9.935e-09\n   Iter 0: Res_d=9.78e-09, Res_u=9.94e-09\n--- Time Step 70 ---\n  Newton Iteration 1, Residual Norm: 1.104e-08\n  Newton Iteration 1, Residual Norm: 9.461e-09\n  Newton Iteration 1, Residual Norm: 5.306e-01\n  Newton Iteration 2, Residual Norm: 3.650e-04\n  Newton Iteration 3, Residual Norm: 6.135e-05\n  Newton Iteration 4, Residual Norm: 2.709e-06\n  Newton Iteration 5, Residual Norm: 4.442e-07\n  Newton Iteration 6, Residual Norm: 2.320e-08\n  Newton Iteration 7, Residual Norm: 9.995e-09\n   Iter 0: Res_d=9.46e-09, Res_u=9.99e-09\n--- Time Step 71 ---\n  Newton Iteration 1, Residual Norm: 1.106e-08\n  Newton Iteration 1, Residual Norm: 9.381e-09\n  Newton Iteration 1, Residual Norm: 5.235e-01\n  Newton Iteration 2, Residual Norm: 3.645e-04\n  Newton Iteration 3, Residual Norm: 7.468e-05\n  Newton Iteration 4, Residual Norm: 2.424e-06\n  Newton Iteration 5, Residual Norm: 4.554e-07\n  Newton Iteration 6, Residual Norm: 2.912e-08\n  Newton Iteration 7, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.38e-09, Res_u=1.00e-08\n--- Time Step 72 ---\n  Newton Iteration 1, Residual Norm: 1.092e-08\n  Newton Iteration 1, Residual Norm: 9.093e-09\n  Newton Iteration 1, Residual Norm: 5.144e-01\n  Newton Iteration 2, Residual Norm: 2.894e-04\n  Newton Iteration 3, Residual Norm: 6.247e-05\n  Newton Iteration 4, Residual Norm: 1.554e-06\n  Newton Iteration 5, Residual Norm: 2.992e-07\n  Newton Iteration 6, Residual Norm: 9.976e-09\n   Iter 0: Res_d=9.09e-09, Res_u=9.98e-09\n--- Time Step 73 ---\n  Newton Iteration 1, Residual Norm: 1.089e-08\n  Newton Iteration 1, Residual Norm: 9.865e-09\n  Newton Iteration 1, Residual Norm: 5.032e-01\n  Newton Iteration 2, Residual Norm: 8.110e-03\n  Newton Iteration 3, Residual Norm: 4.013e-05\n  Newton Iteration 4, Residual Norm: 8.361e-07\n  Newton Iteration 5, Residual Norm: 1.626e-07\n  Newton Iteration 6, Residual Norm: 9.982e-09\n   Iter 0: Res_d=9.87e-09, Res_u=9.98e-09\n--- Time Step 74 ---\n  Newton Iteration 1, Residual Norm: 1.080e-08\n  Newton Iteration 1, Residual Norm: 7.778e-09\n  Newton Iteration 1, Residual Norm: 4.804e-01\n  Newton Iteration 2, Residual Norm: 2.020e-04\n  Newton Iteration 3, Residual Norm: 3.691e-05\n  Newton Iteration 4, Residual Norm: 6.147e-07\n  Newton Iteration 5, Residual Norm: 1.203e-07\n  Newton Iteration 6, Residual Norm: 9.898e-09\n   Iter 0: Res_d=7.78e-09, Res_u=9.90e-09\n--- Time Step 75 ---\n  Newton Iteration 1, Residual Norm: 1.077e-08\n  Newton Iteration 1, Residual Norm: 9.685e-09\n  Newton Iteration 1, Residual Norm: 4.757e-01\n  Newton Iteration 2, Residual Norm: 1.873e-04\n  Newton Iteration 3, Residual Norm: 3.424e-05\n  Newton Iteration 4, Residual Norm: 5.888e-07\n  Newton Iteration 5, Residual Norm: 1.256e-07\n  Newton Iteration 6, Residual Norm: 9.943e-09\n   Iter 0: Res_d=9.68e-09, Res_u=9.94e-09\n--- Time Step 76 ---\n  Newton Iteration 1, Residual Norm: 1.074e-08\n  Newton Iteration 1, Residual Norm: 9.742e-09\n  Newton Iteration 1, Residual Norm: 4.715e-01\n  Newton Iteration 2, Residual Norm: 1.613e-04\n  Newton Iteration 3, Residual Norm: 2.529e-05\n  Newton Iteration 4, Residual Norm: 4.243e-07\n  Newton Iteration 5, Residual Norm: 7.038e-08\n  Newton Iteration 6, Residual Norm: 9.946e-09\n   Iter 0: Res_d=9.74e-09, Res_u=9.95e-09\n--- Time Step 77 ---\n  Newton Iteration 1, Residual Norm: 1.065e-08\n  Newton Iteration 1, Residual Norm: 9.517e-09\n  Newton Iteration 1, Residual Norm: 4.733e-01\n  Newton Iteration 2, Residual Norm: 1.174e-03\n  Newton Iteration 3, Residual Norm: 2.862e-05\n  Newton Iteration 4, Residual Norm: 6.900e-07\n  Newton Iteration 5, Residual Norm: 1.167e-07\n  Newton Iteration 6, Residual Norm: 9.929e-09\n   Iter 0: Res_d=9.52e-09, Res_u=9.93e-09\n--- Time Step 78 ---\n  Newton Iteration 1, Residual Norm: 1.053e-08\n  Newton Iteration 1, Residual Norm: 9.655e-09\n  Newton Iteration 1, Residual Norm: 5.380e-01\n  Newton Iteration 2, Residual Norm: 2.647e-04\n  Newton Iteration 3, Residual Norm: 4.936e-05\n  Newton Iteration 4, Residual Norm: 9.780e-07\n  Newton Iteration 5, Residual Norm: 2.103e-07\n  Newton Iteration 6, Residual Norm: 9.908e-09\n   Iter 0: Res_d=9.65e-09, Res_u=9.91e-09\n--- Time Step 79 ---\n  Newton Iteration 1, Residual Norm: 1.051e-08\n  Newton Iteration 1, Residual Norm: 8.665e-09\n  Newton Iteration 1, Residual Norm: 5.513e-01\n  Newton Iteration 2, Residual Norm: 3.049e-04\n  Newton Iteration 3, Residual Norm: 5.872e-05\n  Newton Iteration 4, Residual Norm: 1.875e-06\n  Newton Iteration 5, Residual Norm: 3.488e-07\n  Newton Iteration 6, Residual Norm: 9.956e-09\n   Iter 0: Res_d=8.66e-09, Res_u=9.96e-09\n--- Time Step 80 ---\n  Newton Iteration 1, Residual Norm: 1.045e-08\n  Newton Iteration 1, Residual Norm: 8.561e-09\n  Newton Iteration 1, Residual Norm: 5.693e-01\n  Newton Iteration 2, Residual Norm: 1.744e-03\n  Newton Iteration 3, Residual Norm: 5.147e-05\n  Newton Iteration 4, Residual Norm: 2.910e-06\n  Newton Iteration 5, Residual Norm: 3.240e-07\n  Newton Iteration 6, Residual Norm: 2.214e-08\n  Newton Iteration 7, Residual Norm: 9.983e-09\n   Iter 0: Res_d=8.56e-09, Res_u=9.98e-09\n--- Time Step 81 ---\n  Newton Iteration 1, Residual Norm: 1.042e-08\n  Newton Iteration 1, Residual Norm: 9.684e-09\n  Newton Iteration 1, Residual Norm: 5.833e-01\n  Newton Iteration 2, Residual Norm: 1.980e-03\n  Newton Iteration 3, Residual Norm: 5.775e-05\n  Newton Iteration 4, Residual Norm: 2.980e-06\n  Newton Iteration 5, Residual Norm: 3.424e-07\n  Newton Iteration 6, Residual Norm: 2.151e-08\n  Newton Iteration 7, Residual Norm: 9.931e-09\n   Iter 0: Res_d=9.68e-09, Res_u=9.93e-09\n--- Time Step 82 ---\n  Newton Iteration 1, Residual Norm: 1.036e-08\n  Newton Iteration 1, Residual Norm: 9.836e-09\n  Newton Iteration 1, Residual Norm: 5.931e-01\n  Newton Iteration 2, Residual Norm: 7.358e-04\n  Newton Iteration 3, Residual Norm: 6.943e-05\n  Newton Iteration 4, Residual Norm: 2.842e-06\n  Newton Iteration 5, Residual Norm: 4.051e-07\n  Newton Iteration 6, Residual Norm: 2.083e-08\n  Newton Iteration 7, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.84e-09, Res_u=1.00e-08\n--- Time Step 83 ---\n  Newton Iteration 1, Residual Norm: 1.019e-08\n  Newton Iteration 1, Residual Norm: 9.605e-09\n  Newton Iteration 1, Residual Norm: 5.966e-01\n  Newton Iteration 2, Residual Norm: 2.454e-03\n  Newton Iteration 3, Residual Norm: 6.983e-05\n  Newton Iteration 4, Residual Norm: 1.929e-06\n  Newton Iteration 5, Residual Norm: 5.385e-07\n  Newton Iteration 6, Residual Norm: 1.486e-08\n  Newton Iteration 7, Residual Norm: 9.992e-09\n   Iter 0: Res_d=9.61e-09, Res_u=9.99e-09\n--- Time Step 84 ---\n  Newton Iteration 1, Residual Norm: 1.019e-08\n  Newton Iteration 1, Residual Norm: 8.010e-09\n  Newton Iteration 1, Residual Norm: 6.016e-01\n  Newton Iteration 2, Residual Norm: 8.249e-03\n  Newton Iteration 3, Residual Norm: 6.250e-05\n  Newton Iteration 4, Residual Norm: 2.309e-06\n  Newton Iteration 5, Residual Norm: 4.054e-07\n  Newton Iteration 6, Residual Norm: 1.791e-08\n  Newton Iteration 7, Residual Norm: 9.897e-09\n   Iter 0: Res_d=8.01e-09, Res_u=9.90e-09\n--- Time Step 85 ---\n  Newton Iteration 1, Residual Norm: 1.018e-08\n  Newton Iteration 1, Residual Norm: 9.515e-09\n  Newton Iteration 1, Residual Norm: 6.039e-01\n  Newton Iteration 2, Residual Norm: 3.538e-04\n  Newton Iteration 3, Residual Norm: 6.710e-05\n  Newton Iteration 4, Residual Norm: 2.175e-06\n  Newton Iteration 5, Residual Norm: 4.373e-07\n  Newton Iteration 6, Residual Norm: 1.597e-08\n  Newton Iteration 7, Residual Norm: 9.943e-09\n   Iter 0: Res_d=9.52e-09, Res_u=9.94e-09\n--- Time Step 86 ---\n  Newton Iteration 1, Residual Norm: 1.013e-08\n  Newton Iteration 1, Residual Norm: 8.346e-09\n  Newton Iteration 1, Residual Norm: 6.051e-01\n  Newton Iteration 2, Residual Norm: 2.786e-04\n  Newton Iteration 3, Residual Norm: 6.653e-05\n  Newton Iteration 4, Residual Norm: 1.973e-06\n  Newton Iteration 5, Residual Norm: 3.172e-07\n  Newton Iteration 6, Residual Norm: 9.998e-09\n   Iter 0: Res_d=8.35e-09, Res_u=1.00e-08\n--- Time Step 87 ---\n  Newton Iteration 1, Residual Norm: 1.012e-08\n  Newton Iteration 1, Residual Norm: 8.291e-09\n  Newton Iteration 1, Residual Norm: 6.088e-01\n  Newton Iteration 2, Residual Norm: 2.285e-04\n  Newton Iteration 3, Residual Norm: 5.842e-05\n  Newton Iteration 4, Residual Norm: 1.127e-06\n  Newton Iteration 5, Residual Norm: 3.773e-07\n  Newton Iteration 6, Residual Norm: 9.941e-09\n   Iter 0: Res_d=8.29e-09, Res_u=9.94e-09\n--- Time Step 88 ---\n  Newton Iteration 1, Residual Norm: 1.002e-08\n  Newton Iteration 1, Residual Norm: 9.411e-09\n  Newton Iteration 1, Residual Norm: 6.143e-01\n  Newton Iteration 2, Residual Norm: 2.368e-04\n  Newton Iteration 3, Residual Norm: 5.756e-05\n  Newton Iteration 4, Residual Norm: 1.222e-06\n  Newton Iteration 5, Residual Norm: 3.576e-07\n  Newton Iteration 6, Residual Norm: 9.956e-09\n   Iter 0: Res_d=9.41e-09, Res_u=9.96e-09\n--- Time Step 89 ---\n  Newton Iteration 1, Residual Norm: 9.976e-09\n  Newton Iteration 1, Residual Norm: 9.094e-09\n  Newton Iteration 1, Residual Norm: 6.209e-01\n  Newton Iteration 2, Residual Norm: 2.342e-04\n  Newton Iteration 3, Residual Norm: 6.151e-05\n  Newton Iteration 4, Residual Norm: 1.442e-06\n  Newton Iteration 5, Residual Norm: 3.984e-07\n  Newton Iteration 6, Residual Norm: 9.956e-09\n   Iter 0: Res_d=9.09e-09, Res_u=9.96e-09\n--- Time Step 90 ---\n  Newton Iteration 1, Residual Norm: 1.001e-08\n  Newton Iteration 1, Residual Norm: 9.918e-09\n  Newton Iteration 1, Residual Norm: 6.252e-01\n  Newton Iteration 2, Residual Norm: 3.770e-04\n  Newton Iteration 3, Residual Norm: 7.678e-05\n  Newton Iteration 4, Residual Norm: 2.545e-06\n  Newton Iteration 5, Residual Norm: 8.502e-07\n  Newton Iteration 6, Residual Norm: 2.011e-08\n  Newton Iteration 7, Residual Norm: 9.962e-09\n   Iter 0: Res_d=9.92e-09, Res_u=9.96e-09\n--- Time Step 91 ---\n  Newton Iteration 1, Residual Norm: 9.886e-09\n  Newton Iteration 1, Residual Norm: 8.928e-09\n  Newton Iteration 1, Residual Norm: 6.321e-01\n  Newton Iteration 2, Residual Norm: 6.175e-04\n  Newton Iteration 3, Residual Norm: 8.292e-05\n  Newton Iteration 4, Residual Norm: 4.354e-06\n  Newton Iteration 5, Residual Norm: 7.630e-07\n  Newton Iteration 6, Residual Norm: 6.861e-08\n  Newton Iteration 7, Residual Norm: 9.986e-09\n   Iter 0: Res_d=8.93e-09, Res_u=9.99e-09\n--- Time Step 92 ---\n  Newton Iteration 1, Residual Norm: 9.863e-09\n  Newton Iteration 1, Residual Norm: 9.796e-09\n  Newton Iteration 1, Residual Norm: 6.401e-01\n  Newton Iteration 2, Residual Norm: 1.265e-03\n  Newton Iteration 3, Residual Norm: 8.140e-05\n  Newton Iteration 4, Residual Norm: 5.866e-06\n  Newton Iteration 5, Residual Norm: 9.714e-07\n  Newton Iteration 6, Residual Norm: 6.059e-08\n  Newton Iteration 7, Residual Norm: 9.997e-09\n   Iter 0: Res_d=9.80e-09, Res_u=1.00e-08\n--- Time Step 93 ---\n  Newton Iteration 1, Residual Norm: 9.807e-09\n  Newton Iteration 1, Residual Norm: 9.108e-09\n  Newton Iteration 1, Residual Norm: 6.511e-01\n  Newton Iteration 2, Residual Norm: 1.888e-03\n  Newton Iteration 3, Residual Norm: 8.757e-05\n  Newton Iteration 4, Residual Norm: 6.482e-06\n  Newton Iteration 5, Residual Norm: 7.943e-07\n  Newton Iteration 6, Residual Norm: 8.341e-08\n  Newton Iteration 7, Residual Norm: 9.983e-09\n   Iter 0: Res_d=9.11e-09, Res_u=9.98e-09\n--- Time Step 94 ---\n  Newton Iteration 1, Residual Norm: 9.789e-09\n  Newton Iteration 1, Residual Norm: 9.105e-09\n  Newton Iteration 1, Residual Norm: 6.566e-01\n  Newton Iteration 2, Residual Norm: 2.440e-03\n  Newton Iteration 3, Residual Norm: 1.008e-04\n  Newton Iteration 4, Residual Norm: 9.686e-06\n  Newton Iteration 5, Residual Norm: 1.036e-06\n  Newton Iteration 6, Residual Norm: 1.164e-07\n  Newton Iteration 7, Residual Norm: 1.305e-08\n  Newton Iteration 8, Residual Norm: 9.993e-09\n   Iter 0: Res_d=9.11e-09, Res_u=9.99e-09\n--- Time Step 95 ---\n  Newton Iteration 1, Residual Norm: 9.795e-09\n  Newton Iteration 1, Residual Norm: 9.576e-09\n  Newton Iteration 1, Residual Norm: 6.661e-01\n  Newton Iteration 2, Residual Norm: 2.903e-03\n  Newton Iteration 3, Residual Norm: 1.119e-04\n  Newton Iteration 4, Residual Norm: 1.085e-05\n  Newton Iteration 5, Residual Norm: 1.332e-06\n  Newton Iteration 6, Residual Norm: 1.463e-07\n  Newton Iteration 7, Residual Norm: 1.952e-08\n  Newton Iteration 8, Residual Norm: 9.964e-09\n   Iter 0: Res_d=9.58e-09, Res_u=9.96e-09\n--- Time Step 96 ---\n  Newton Iteration 1, Residual Norm: 9.727e-09\n  Newton Iteration 1, Residual Norm: 9.118e-09\n  Newton Iteration 1, Residual Norm: 6.760e-01\n  Newton Iteration 2, Residual Norm: 3.403e-03\n  Newton Iteration 3, Residual Norm: 1.174e-04\n  Newton Iteration 4, Residual Norm: 1.189e-05\n  Newton Iteration 5, Residual Norm: 1.676e-06\n  Newton Iteration 6, Residual Norm: 1.344e-07\n  Newton Iteration 7, Residual Norm: 3.248e-08\n  Newton Iteration 8, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.12e-09, Res_u=9.98e-09\n--- Time Step 97 ---\n  Newton Iteration 1, Residual Norm: 9.719e-09\n  Newton Iteration 1, Residual Norm: 8.948e-09\n  Newton Iteration 1, Residual Norm: 6.967e-01\n  Newton Iteration 2, Residual Norm: 3.692e-03\n  Newton Iteration 3, Residual Norm: 1.138e-04\n  Newton Iteration 4, Residual Norm: 1.154e-05\n  Newton Iteration 5, Residual Norm: 1.545e-06\n  Newton Iteration 6, Residual Norm: 1.526e-07\n  Newton Iteration 7, Residual Norm: 2.288e-08\n  Newton Iteration 8, Residual Norm: 9.978e-09\n   Iter 0: Res_d=8.95e-09, Res_u=9.98e-09\n--- Time Step 98 ---\n  Newton Iteration 1, Residual Norm: 9.665e-09\n  Newton Iteration 1, Residual Norm: 8.685e-09\n  Newton Iteration 1, Residual Norm: 7.026e-01\n  Newton Iteration 2, Residual Norm: 4.375e-03\n  Newton Iteration 3, Residual Norm: 1.121e-04\n  Newton Iteration 4, Residual Norm: 1.128e-05\n  Newton Iteration 5, Residual Norm: 1.428e-06\n  Newton Iteration 6, Residual Norm: 1.600e-07\n  Newton Iteration 7, Residual Norm: 2.190e-08\n  Newton Iteration 8, Residual Norm: 9.930e-09\n   Iter 0: Res_d=8.69e-09, Res_u=9.93e-09\n--- Time Step 99 ---\n  Newton Iteration 1, Residual Norm: 9.670e-09\n  Newton Iteration 1, Residual Norm: 9.050e-09\n  Newton Iteration 1, Residual Norm: 7.069e-01\n  Newton Iteration 2, Residual Norm: 4.933e-04\n  Newton Iteration 3, Residual Norm: 1.316e-04\n  Newton Iteration 4, Residual Norm: 6.457e-06\n  Newton Iteration 5, Residual Norm: 1.743e-06\n  Newton Iteration 6, Residual Norm: 1.214e-07\n  Newton Iteration 7, Residual Norm: 2.136e-08\n  Newton Iteration 8, Residual Norm: 9.916e-09\n   Iter 0: Res_d=9.05e-09, Res_u=9.92e-09\n--- Time Step 100 ---\n  Newton Iteration 1, Residual Norm: 9.733e-09\n  Newton Iteration 1, Residual Norm: 9.959e-09\n  Newton Iteration 1, Residual Norm: 7.144e-01\n  Newton Iteration 2, Residual Norm: 4.663e-04\n  Newton Iteration 3, Residual Norm: 1.263e-04\n  Newton Iteration 4, Residual Norm: 5.969e-06\n  Newton Iteration 5, Residual Norm: 1.647e-06\n  Newton Iteration 6, Residual Norm: 7.220e-08\n  Newton Iteration 7, Residual Norm: 4.132e-08\n  Newton Iteration 8, Residual Norm: 1.000e-08\n   Iter 0: Res_d=9.96e-09, Res_u=1.00e-08\n--- Time Step 101 ---\n  Newton Iteration 1, Residual Norm: 9.735e-09\n  Newton Iteration 1, Residual Norm: 9.743e-09\n  Newton Iteration 1, Residual Norm: 7.181e-01\n  Newton Iteration 2, Residual Norm: 4.840e-04\n  Newton Iteration 3, Residual Norm: 1.258e-04\n  Newton Iteration 4, Residual Norm: 5.867e-06\n  Newton Iteration 5, Residual Norm: 1.383e-06\n  Newton Iteration 6, Residual Norm: 1.159e-07\n  Newton Iteration 7, Residual Norm: 2.372e-08\n  Newton Iteration 8, Residual Norm: 9.975e-09\n   Iter 0: Res_d=9.74e-09, Res_u=9.97e-09\n--- Time Step 102 ---\n  Newton Iteration 1, Residual Norm: 9.777e-09\n  Newton Iteration 1, Residual Norm: 8.828e-09\n  Newton Iteration 1, Residual Norm: 7.207e-01\n  Newton Iteration 2, Residual Norm: 4.318e-04\n  Newton Iteration 3, Residual Norm: 1.243e-04\n  Newton Iteration 4, Residual Norm: 7.259e-06\n  Newton Iteration 5, Residual Norm: 1.377e-06\n  Newton Iteration 6, Residual Norm: 1.353e-07\n  Newton Iteration 7, Residual Norm: 1.458e-08\n  Newton Iteration 8, Residual Norm: 9.979e-09\n   Iter 0: Res_d=8.83e-09, Res_u=9.98e-09\n--- Time Step 103 ---\n  Newton Iteration 1, Residual Norm: 9.787e-09\n  Newton Iteration 1, Residual Norm: 9.775e-09\n  Newton Iteration 1, Residual Norm: 7.218e-01\n  Newton Iteration 2, Residual Norm: 4.148e-04\n  Newton Iteration 3, Residual Norm: 1.244e-04\n  Newton Iteration 4, Residual Norm: 5.157e-06\n  Newton Iteration 5, Residual Norm: 2.027e-06\n  Newton Iteration 6, Residual Norm: 6.697e-08\n  Newton Iteration 7, Residual Norm: 2.805e-08\n  Newton Iteration 8, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.77e-09, Res_u=9.98e-09\n--- Time Step 104 ---\n  Newton Iteration 1, Residual Norm: 9.899e-09\n  Newton Iteration 1, Residual Norm: 9.073e-09\n  Newton Iteration 1, Residual Norm: 7.230e-01\n  Newton Iteration 2, Residual Norm: 6.244e-03\n  Newton Iteration 3, Residual Norm: 1.216e-04\n  Newton Iteration 4, Residual Norm: 5.746e-06\n  Newton Iteration 5, Residual Norm: 1.625e-06\n  Newton Iteration 6, Residual Norm: 8.489e-08\n  Newton Iteration 7, Residual Norm: 2.489e-08\n  Newton Iteration 8, Residual Norm: 9.955e-09\n   Iter 0: Res_d=9.07e-09, Res_u=9.95e-09\n--- Time Step 105 ---\n  Newton Iteration 1, Residual Norm: 1.002e-08\n  Newton Iteration 1, Residual Norm: 8.853e-09\n  Newton Iteration 1, Residual Norm: 7.266e-01\n  Newton Iteration 2, Residual Norm: 1.262e-02\n  Newton Iteration 3, Residual Norm: 1.141e-04\n  Newton Iteration 4, Residual Norm: 6.762e-06\n  Newton Iteration 5, Residual Norm: 1.358e-06\n  Newton Iteration 6, Residual Norm: 1.322e-07\n  Newton Iteration 7, Residual Norm: 2.068e-08\n  Newton Iteration 8, Residual Norm: 9.960e-09\n   Iter 0: Res_d=8.85e-09, Res_u=9.96e-09\n--- Time Step 106 ---\n  Newton Iteration 1, Residual Norm: 1.029e-08\n  Newton Iteration 1, Residual Norm: 9.587e-09\n  Newton Iteration 1, Residual Norm: 7.291e-01\n  Newton Iteration 2, Residual Norm: 1.878e-02\n  Newton Iteration 3, Residual Norm: 1.093e-04\n  Newton Iteration 4, Residual Norm: 8.854e-06\n  Newton Iteration 5, Residual Norm: 1.482e-06\n  Newton Iteration 6, Residual Norm: 1.447e-07\n  Newton Iteration 7, Residual Norm: 3.055e-08\n  Newton Iteration 8, Residual Norm: 9.986e-09\n   Iter 0: Res_d=9.59e-09, Res_u=9.99e-09\n--- Time Step 107 ---\n  Newton Iteration 1, Residual Norm: 1.054e-08\n  Newton Iteration 1, Residual Norm: 7.370e-09\n  Newton Iteration 1, Residual Norm: 7.353e-01\n  Newton Iteration 2, Residual Norm: 5.286e-04\n  Newton Iteration 3, Residual Norm: 1.320e-04\n  Newton Iteration 4, Residual Norm: 7.962e-06\n  Newton Iteration 5, Residual Norm: 1.512e-06\n  Newton Iteration 6, Residual Norm: 1.516e-07\n  Newton Iteration 7, Residual Norm: 2.317e-08\n  Newton Iteration 8, Residual Norm: 9.931e-09\n   Iter 0: Res_d=7.37e-09, Res_u=9.93e-09\n--- Time Step 108 ---\n  Newton Iteration 1, Residual Norm: 1.093e-08\n  Newton Iteration 1, Residual Norm: 8.883e-09\n  Newton Iteration 1, Residual Norm: 7.360e-01\n  Newton Iteration 2, Residual Norm: 5.582e-04\n  Newton Iteration 3, Residual Norm: 1.383e-04\n  Newton Iteration 4, Residual Norm: 7.341e-06\n  Newton Iteration 5, Residual Norm: 2.061e-06\n  Newton Iteration 6, Residual Norm: 1.202e-07\n  Newton Iteration 7, Residual Norm: 3.609e-08\n  Newton Iteration 8, Residual Norm: 9.984e-09\n   Iter 0: Res_d=8.88e-09, Res_u=9.98e-09\n--- Time Step 109 ---\n  Newton Iteration 1, Residual Norm: 1.142e-08\n  Newton Iteration 1, Residual Norm: 9.751e-09\n  Newton Iteration 1, Residual Norm: 7.401e-01\n  Newton Iteration 2, Residual Norm: 1.257e-03\n  Newton Iteration 3, Residual Norm: 1.319e-04\n  Newton Iteration 4, Residual Norm: 1.008e-05\n  Newton Iteration 5, Residual Norm: 1.916e-06\n  Newton Iteration 6, Residual Norm: 1.734e-07\n  Newton Iteration 7, Residual Norm: 3.139e-08\n  Newton Iteration 8, Residual Norm: 9.966e-09\n   Iter 0: Res_d=9.75e-09, Res_u=9.97e-09\n--- Time Step 110 ---\n  Newton Iteration 1, Residual Norm: 1.197e-08\n  Newton Iteration 1, Residual Norm: 8.645e-09\n  Newton Iteration 1, Residual Norm: 7.459e-01\n  Newton Iteration 2, Residual Norm: 1.867e-03\n  Newton Iteration 3, Residual Norm: 1.331e-04\n  Newton Iteration 4, Residual Norm: 1.142e-05\n  Newton Iteration 5, Residual Norm: 2.689e-06\n  Newton Iteration 6, Residual Norm: 1.754e-07\n  Newton Iteration 7, Residual Norm: 4.817e-08\n  Newton Iteration 8, Residual Norm: 9.978e-09\n   Iter 0: Res_d=8.64e-09, Res_u=9.98e-09\n--- Time Step 111 ---\n  Newton Iteration 1, Residual Norm: 9.178e-09\n  Newton Iteration 1, Residual Norm: 9.465e-09\n  Newton Iteration 1, Residual Norm: 7.512e-01\n  Newton Iteration 2, Residual Norm: 2.616e-03\n  Newton Iteration 3, Residual Norm: 1.319e-04\n  Newton Iteration 4, Residual Norm: 1.305e-05\n  Newton Iteration 5, Residual Norm: 2.137e-06\n  Newton Iteration 6, Residual Norm: 2.445e-07\n  Newton Iteration 7, Residual Norm: 4.320e-08\n  Newton Iteration 8, Residual Norm: 9.957e-09\n   Iter 0: Res_d=9.47e-09, Res_u=9.96e-09\n--- Time Step 112 ---\n  Newton Iteration 1, Residual Norm: 9.427e-09\n  Newton Iteration 1, Residual Norm: 9.458e-09\n  Newton Iteration 1, Residual Norm: 7.535e-01\n  Newton Iteration 2, Residual Norm: 3.375e-03\n  Newton Iteration 3, Residual Norm: 1.312e-04\n  Newton Iteration 4, Residual Norm: 1.472e-05\n  Newton Iteration 5, Residual Norm: 2.241e-06\n  Newton Iteration 6, Residual Norm: 3.239e-07\n  Newton Iteration 7, Residual Norm: 4.450e-08\n  Newton Iteration 8, Residual Norm: 9.982e-09\n   Iter 0: Res_d=9.46e-09, Res_u=9.98e-09\n--- Time Step 113 ---\n  Newton Iteration 1, Residual Norm: 9.603e-09\n  Newton Iteration 1, Residual Norm: 9.023e-09\n  Newton Iteration 1, Residual Norm: 7.614e-01\n  Newton Iteration 2, Residual Norm: 1.909e-03\n  Newton Iteration 3, Residual Norm: 1.454e-04\n  Newton Iteration 4, Residual Norm: 1.453e-05\n  Newton Iteration 5, Residual Norm: 2.203e-06\n  Newton Iteration 6, Residual Norm: 3.007e-07\n  Newton Iteration 7, Residual Norm: 5.064e-08\n  Newton Iteration 8, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.02e-09, Res_u=9.98e-09\n--- Time Step 114 ---\n  Newton Iteration 1, Residual Norm: 9.838e-09\n  Newton Iteration 1, Residual Norm: 8.843e-09\n  Newton Iteration 1, Residual Norm: 7.669e-01\n  Newton Iteration 2, Residual Norm: 2.352e-03\n  Newton Iteration 3, Residual Norm: 1.405e-04\n  Newton Iteration 4, Residual Norm: 1.451e-05\n  Newton Iteration 5, Residual Norm: 2.240e-06\n  Newton Iteration 6, Residual Norm: 3.777e-07\n  Newton Iteration 7, Residual Norm: 4.351e-08\n  Newton Iteration 8, Residual Norm: 9.965e-09\n   Iter 0: Res_d=8.84e-09, Res_u=9.97e-09\n--- Time Step 115 ---\n  Newton Iteration 1, Residual Norm: 9.954e-09\n  Newton Iteration 1, Residual Norm: 9.051e-09\n  Newton Iteration 1, Residual Norm: 7.681e-01\n  Newton Iteration 2, Residual Norm: 2.845e-03\n  Newton Iteration 3, Residual Norm: 1.354e-04\n  Newton Iteration 4, Residual Norm: 1.471e-05\n  Newton Iteration 5, Residual Norm: 2.134e-06\n  Newton Iteration 6, Residual Norm: 2.766e-07\n  Newton Iteration 7, Residual Norm: 8.136e-08\n  Newton Iteration 8, Residual Norm: 9.963e-09\n   Iter 0: Res_d=9.05e-09, Res_u=9.96e-09\n--- Time Step 116 ---\n  Newton Iteration 1, Residual Norm: 1.006e-08\n  Newton Iteration 1, Residual Norm: 9.065e-09\n  Newton Iteration 1, Residual Norm: 7.697e-01\n  Newton Iteration 2, Residual Norm: 3.301e-03\n  Newton Iteration 3, Residual Norm: 1.301e-04\n  Newton Iteration 4, Residual Norm: 1.471e-05\n  Newton Iteration 5, Residual Norm: 2.276e-06\n  Newton Iteration 6, Residual Norm: 3.073e-07\n  Newton Iteration 7, Residual Norm: 4.520e-08\n  Newton Iteration 8, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.06e-09, Res_u=9.98e-09\n--- Time Step 117 ---\n  Newton Iteration 1, Residual Norm: 1.013e-08\n  Newton Iteration 1, Residual Norm: 9.625e-09\n  Newton Iteration 1, Residual Norm: 7.701e-01\n  Newton Iteration 2, Residual Norm: 1.038e-03\n  Newton Iteration 3, Residual Norm: 1.453e-04\n  Newton Iteration 4, Residual Norm: 1.012e-05\n  Newton Iteration 5, Residual Norm: 3.089e-06\n  Newton Iteration 6, Residual Norm: 1.632e-07\n  Newton Iteration 7, Residual Norm: 5.932e-08\n  Newton Iteration 8, Residual Norm: 9.967e-09\n   Iter 0: Res_d=9.62e-09, Res_u=9.97e-09\n--- Time Step 118 ---\n  Newton Iteration 1, Residual Norm: 1.027e-08\n  Newton Iteration 1, Residual Norm: 9.959e-09\n  Newton Iteration 1, Residual Norm: 7.752e-01\n  Newton Iteration 2, Residual Norm: 1.484e-03\n  Newton Iteration 3, Residual Norm: 1.321e-04\n  Newton Iteration 4, Residual Norm: 1.110e-05\n  Newton Iteration 5, Residual Norm: 1.993e-06\n  Newton Iteration 6, Residual Norm: 2.963e-07\n  Newton Iteration 7, Residual Norm: 3.773e-08\n  Newton Iteration 8, Residual Norm: 9.949e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.95e-09\n--- Time Step 119 ---\n  Newton Iteration 1, Residual Norm: 1.032e-08\n  Newton Iteration 1, Residual Norm: 9.486e-09\n  Newton Iteration 1, Residual Norm: 7.818e-01\n  Newton Iteration 2, Residual Norm: 1.960e-03\n  Newton Iteration 3, Residual Norm: 1.257e-04\n  Newton Iteration 4, Residual Norm: 1.125e-05\n  Newton Iteration 5, Residual Norm: 2.089e-06\n  Newton Iteration 6, Residual Norm: 2.180e-07\n  Newton Iteration 7, Residual Norm: 3.810e-08\n  Newton Iteration 8, Residual Norm: 9.969e-09\n   Iter 0: Res_d=9.49e-09, Res_u=9.97e-09\n--- Time Step 120 ---\n  Newton Iteration 1, Residual Norm: 1.033e-08\n  Newton Iteration 1, Residual Norm: 9.393e-09\n  Newton Iteration 1, Residual Norm: 7.884e-01\n  Newton Iteration 2, Residual Norm: 2.455e-03\n  Newton Iteration 3, Residual Norm: 1.205e-04\n  Newton Iteration 4, Residual Norm: 1.163e-05\n  Newton Iteration 5, Residual Norm: 2.038e-06\n  Newton Iteration 6, Residual Norm: 2.593e-07\n  Newton Iteration 7, Residual Norm: 3.389e-08\n  Newton Iteration 8, Residual Norm: 9.996e-09\n   Iter 0: Res_d=9.39e-09, Res_u=1.00e-08\n--- Time Step 121 ---\n  Newton Iteration 1, Residual Norm: 1.030e-08\n  Newton Iteration 1, Residual Norm: 9.672e-09\n  Newton Iteration 1, Residual Norm: 7.917e-01\n  Newton Iteration 2, Residual Norm: 2.941e-03\n  Newton Iteration 3, Residual Norm: 1.165e-04\n  Newton Iteration 4, Residual Norm: 1.215e-05\n  Newton Iteration 5, Residual Norm: 2.048e-06\n  Newton Iteration 6, Residual Norm: 2.108e-07\n  Newton Iteration 7, Residual Norm: 5.966e-08\n  Newton Iteration 8, Residual Norm: 9.966e-09\n   Iter 0: Res_d=9.67e-09, Res_u=9.97e-09\n--- Time Step 122 ---\n  Newton Iteration 1, Residual Norm: 1.033e-08\n  Newton Iteration 1, Residual Norm: 8.217e-09\n  Newton Iteration 1, Residual Norm: 7.936e-01\n  Newton Iteration 2, Residual Norm: 3.419e-03\n  Newton Iteration 3, Residual Norm: 1.142e-04\n  Newton Iteration 4, Residual Norm: 1.199e-05\n  Newton Iteration 5, Residual Norm: 2.597e-06\n  Newton Iteration 6, Residual Norm: 1.762e-07\n  Newton Iteration 7, Residual Norm: 7.098e-08\n  Newton Iteration 8, Residual Norm: 9.935e-09\n   Iter 0: Res_d=8.22e-09, Res_u=9.94e-09\n--- Time Step 123 ---\n  Newton Iteration 1, Residual Norm: 1.031e-08\n  Newton Iteration 1, Residual Norm: 9.652e-09\n  Newton Iteration 1, Residual Norm: 7.940e-01\n  Newton Iteration 2, Residual Norm: 4.135e-04\n  Newton Iteration 3, Residual Norm: 1.474e-04\n  Newton Iteration 4, Residual Norm: 7.061e-06\n  Newton Iteration 5, Residual Norm: 2.650e-06\n  Newton Iteration 6, Residual Norm: 1.412e-07\n  Newton Iteration 7, Residual Norm: 5.515e-08\n  Newton Iteration 8, Residual Norm: 9.974e-09\n   Iter 0: Res_d=9.65e-09, Res_u=9.97e-09\n--- Time Step 124 ---\n  Newton Iteration 1, Residual Norm: 1.032e-08\n  Newton Iteration 1, Residual Norm: 9.622e-09\n  Newton Iteration 1, Residual Norm: 7.953e-01\n  Newton Iteration 2, Residual Norm: 4.173e-04\n  Newton Iteration 3, Residual Norm: 1.478e-04\n  Newton Iteration 4, Residual Norm: 7.028e-06\n  Newton Iteration 5, Residual Norm: 2.403e-06\n  Newton Iteration 6, Residual Norm: 1.731e-07\n  Newton Iteration 7, Residual Norm: 5.411e-08\n  Newton Iteration 8, Residual Norm: 9.944e-09\n   Iter 0: Res_d=9.62e-09, Res_u=9.94e-09\n--- Time Step 125 ---\n  Newton Iteration 1, Residual Norm: 1.035e-08\n  Newton Iteration 1, Residual Norm: 9.706e-09\n  Newton Iteration 1, Residual Norm: 7.988e-01\n  Newton Iteration 2, Residual Norm: 4.211e-04\n  Newton Iteration 3, Residual Norm: 1.495e-04\n  Newton Iteration 4, Residual Norm: 7.279e-06\n  Newton Iteration 5, Residual Norm: 2.631e-06\n  Newton Iteration 6, Residual Norm: 1.420e-07\n  Newton Iteration 7, Residual Norm: 6.538e-08\n  Newton Iteration 8, Residual Norm: 9.949e-09\n   Iter 0: Res_d=9.71e-09, Res_u=9.95e-09\n--- Time Step 126 ---\n  Newton Iteration 1, Residual Norm: 1.034e-08\n  Newton Iteration 1, Residual Norm: 9.387e-09\n  Newton Iteration 1, Residual Norm: 8.019e-01\n  Newton Iteration 2, Residual Norm: 4.341e-04\n  Newton Iteration 3, Residual Norm: 1.552e-04\n  Newton Iteration 4, Residual Norm: 6.923e-06\n  Newton Iteration 5, Residual Norm: 3.405e-06\n  Newton Iteration 6, Residual Norm: 1.323e-07\n  Newton Iteration 7, Residual Norm: 6.012e-08\n  Newton Iteration 8, Residual Norm: 9.969e-09\n   Iter 0: Res_d=9.39e-09, Res_u=9.97e-09\n--- Time Step 127 ---\n  Newton Iteration 1, Residual Norm: 1.028e-08\n  Newton Iteration 1, Residual Norm: 8.304e-09\n  Newton Iteration 1, Residual Norm: 8.044e-01\n  Newton Iteration 2, Residual Norm: 4.704e-04\n  Newton Iteration 3, Residual Norm: 1.599e-04\n  Newton Iteration 4, Residual Norm: 8.367e-06\n  Newton Iteration 5, Residual Norm: 3.044e-06\n  Newton Iteration 6, Residual Norm: 1.728e-07\n  Newton Iteration 7, Residual Norm: 6.549e-08\n  Newton Iteration 8, Residual Norm: 9.926e-09\n   Iter 0: Res_d=8.30e-09, Res_u=9.93e-09\n--- Time Step 128 ---\n  Newton Iteration 1, Residual Norm: 1.026e-08\n  Newton Iteration 1, Residual Norm: 9.905e-09\n  Newton Iteration 1, Residual Norm: 8.081e-01\n  Newton Iteration 2, Residual Norm: 5.281e-04\n  Newton Iteration 3, Residual Norm: 1.669e-04\n  Newton Iteration 4, Residual Norm: 9.177e-06\n  Newton Iteration 5, Residual Norm: 2.655e-06\n  Newton Iteration 6, Residual Norm: 1.752e-07\n  Newton Iteration 7, Residual Norm: 8.838e-08\n  Newton Iteration 8, Residual Norm: 9.984e-09\n   Iter 0: Res_d=9.91e-09, Res_u=9.98e-09\n--- Time Step 129 ---\n  Newton Iteration 1, Residual Norm: 1.022e-08\n  Newton Iteration 1, Residual Norm: 9.311e-09\n  Newton Iteration 1, Residual Norm: 8.127e-01\n  Newton Iteration 2, Residual Norm: 5.760e-04\n  Newton Iteration 3, Residual Norm: 1.715e-04\n  Newton Iteration 4, Residual Norm: 8.763e-06\n  Newton Iteration 5, Residual Norm: 3.132e-06\n  Newton Iteration 6, Residual Norm: 2.677e-07\n  Newton Iteration 7, Residual Norm: 6.036e-08\n  Newton Iteration 8, Residual Norm: 9.991e-09\n   Iter 0: Res_d=9.31e-09, Res_u=9.99e-09\n--- Time Step 130 ---\n  Newton Iteration 1, Residual Norm: 1.015e-08\n  Newton Iteration 1, Residual Norm: 7.998e-09\n  Newton Iteration 1, Residual Norm: 8.195e-01\n  Newton Iteration 2, Residual Norm: 6.305e-04\n  Newton Iteration 3, Residual Norm: 1.725e-04\n  Newton Iteration 4, Residual Norm: 9.044e-06\n  Newton Iteration 5, Residual Norm: 4.071e-06\n  Newton Iteration 6, Residual Norm: 1.682e-07\n  Newton Iteration 7, Residual Norm: 8.496e-08\n  Newton Iteration 8, Residual Norm: 9.979e-09\n   Iter 0: Res_d=8.00e-09, Res_u=9.98e-09\n--- Time Step 131 ---\n  Newton Iteration 1, Residual Norm: 1.015e-08\n  Newton Iteration 1, Residual Norm: 9.933e-09\n  Newton Iteration 1, Residual Norm: 8.226e-01\n  Newton Iteration 2, Residual Norm: 7.034e-04\n  Newton Iteration 3, Residual Norm: 1.762e-04\n  Newton Iteration 4, Residual Norm: 1.046e-05\n  Newton Iteration 5, Residual Norm: 4.766e-06\n  Newton Iteration 6, Residual Norm: 1.364e-07\n  Newton Iteration 7, Residual Norm: 1.060e-07\n  Newton Iteration 8, Residual Norm: 9.994e-09\n   Iter 0: Res_d=9.93e-09, Res_u=9.99e-09\n--- Time Step 132 ---\n  Newton Iteration 1, Residual Norm: 1.009e-08\n  Newton Iteration 1, Residual Norm: 9.059e-09\n  Newton Iteration 1, Residual Norm: 8.249e-01\n  Newton Iteration 2, Residual Norm: 9.527e-04\n  Newton Iteration 3, Residual Norm: 1.697e-04\n  Newton Iteration 4, Residual Norm: 1.051e-05\n  Newton Iteration 5, Residual Norm: 4.113e-06\n  Newton Iteration 6, Residual Norm: 1.694e-07\n  Newton Iteration 7, Residual Norm: 1.261e-07\n  Newton Iteration 8, Residual Norm: 9.925e-09\n   Iter 0: Res_d=9.06e-09, Res_u=9.93e-09\n--- Time Step 133 ---\n  Newton Iteration 1, Residual Norm: 1.007e-08\n  Newton Iteration 1, Residual Norm: 9.949e-09\n  Newton Iteration 1, Residual Norm: 8.284e-01\n  Newton Iteration 2, Residual Norm: 1.354e-03\n  Newton Iteration 3, Residual Norm: 1.564e-04\n  Newton Iteration 4, Residual Norm: 1.324e-05\n  Newton Iteration 5, Residual Norm: 2.690e-06\n  Newton Iteration 6, Residual Norm: 2.439e-07\n  Newton Iteration 7, Residual Norm: 7.127e-08\n  Newton Iteration 8, Residual Norm: 9.973e-09\n   Iter 0: Res_d=9.95e-09, Res_u=9.97e-09\n--- Time Step 134 ---\n  Newton Iteration 1, Residual Norm: 1.009e-08\n  Newton Iteration 1, Residual Norm: 8.692e-09\n  Newton Iteration 1, Residual Norm: 8.295e-01\n  Newton Iteration 2, Residual Norm: 1.718e-03\n  Newton Iteration 3, Residual Norm: 1.422e-04\n  Newton Iteration 4, Residual Norm: 1.229e-05\n  Newton Iteration 5, Residual Norm: 3.339e-06\n  Newton Iteration 6, Residual Norm: 2.357e-07\n  Newton Iteration 7, Residual Norm: 6.106e-08\n  Newton Iteration 8, Residual Norm: 9.999e-09\n   Iter 0: Res_d=8.69e-09, Res_u=1.00e-08\n--- Time Step 135 ---\n  Newton Iteration 1, Residual Norm: 1.006e-08\n  Newton Iteration 1, Residual Norm: 9.511e-09\n  Newton Iteration 1, Residual Norm: 8.285e-01\n  Newton Iteration 2, Residual Norm: 8.807e-04\n  Newton Iteration 3, Residual Norm: 1.544e-04\n  Newton Iteration 4, Residual Norm: 8.826e-06\n  Newton Iteration 5, Residual Norm: 3.012e-06\n  Newton Iteration 6, Residual Norm: 2.407e-07\n  Newton Iteration 7, Residual Norm: 4.714e-08\n  Newton Iteration 8, Residual Norm: 9.986e-09\n   Iter 0: Res_d=9.51e-09, Res_u=9.99e-09\n--- Time Step 136 ---\n  Newton Iteration 1, Residual Norm: 1.000e-08\n  Newton Iteration 1, Residual Norm: 9.902e-09\n  Newton Iteration 1, Residual Norm: 8.285e-01\n  Newton Iteration 2, Residual Norm: 1.075e-03\n  Newton Iteration 3, Residual Norm: 1.364e-04\n  Newton Iteration 4, Residual Norm: 9.597e-06\n  Newton Iteration 5, Residual Norm: 2.872e-06\n  Newton Iteration 6, Residual Norm: 1.555e-07\n  Newton Iteration 7, Residual Norm: 4.598e-08\n  Newton Iteration 8, Residual Norm: 9.991e-09\n   Iter 0: Res_d=9.90e-09, Res_u=9.99e-09\n--- Time Step 137 ---\n  Newton Iteration 1, Residual Norm: 9.969e-09\n  Newton Iteration 1, Residual Norm: 7.934e-09\n  Newton Iteration 1, Residual Norm: 8.288e-01\n  Newton Iteration 2, Residual Norm: 1.015e-03\n  Newton Iteration 3, Residual Norm: 1.291e-04\n  Newton Iteration 4, Residual Norm: 8.230e-06\n  Newton Iteration 5, Residual Norm: 1.951e-06\n  Newton Iteration 6, Residual Norm: 2.045e-07\n  Newton Iteration 7, Residual Norm: 3.643e-08\n  Newton Iteration 8, Residual Norm: 9.977e-09\n   Iter 0: Res_d=7.93e-09, Res_u=9.98e-09\n--- Time Step 138 ---\n  Newton Iteration 1, Residual Norm: 9.910e-09\n  Newton Iteration 1, Residual Norm: 9.963e-09\n  Newton Iteration 1, Residual Norm: 8.322e-01\n  Newton Iteration 2, Residual Norm: 1.424e-03\n  Newton Iteration 3, Residual Norm: 1.138e-04\n  Newton Iteration 4, Residual Norm: 8.610e-06\n  Newton Iteration 5, Residual Norm: 1.973e-06\n  Newton Iteration 6, Residual Norm: 1.267e-07\n  Newton Iteration 7, Residual Norm: 3.723e-08\n  Newton Iteration 8, Residual Norm: 9.970e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.97e-09\n--- Time Step 139 ---\n  Newton Iteration 1, Residual Norm: 9.874e-09\n  Newton Iteration 1, Residual Norm: 9.313e-09\n  Newton Iteration 1, Residual Norm: 8.376e-01\n  Newton Iteration 2, Residual Norm: 1.950e-03\n  Newton Iteration 3, Residual Norm: 1.069e-04\n  Newton Iteration 4, Residual Norm: 9.156e-06\n  Newton Iteration 5, Residual Norm: 1.891e-06\n  Newton Iteration 6, Residual Norm: 1.446e-07\n  Newton Iteration 7, Residual Norm: 3.457e-08\n  Newton Iteration 8, Residual Norm: 9.987e-09\n   Iter 0: Res_d=9.31e-09, Res_u=9.99e-09\n--- Time Step 140 ---\n  Newton Iteration 1, Residual Norm: 9.918e-09\n  Newton Iteration 1, Residual Norm: 8.308e-09\n  Newton Iteration 1, Residual Norm: 8.412e-01\n  Newton Iteration 2, Residual Norm: 3.595e-04\n  Newton Iteration 3, Residual Norm: 1.355e-04\n  Newton Iteration 4, Residual Norm: 5.147e-06\n  Newton Iteration 5, Residual Norm: 2.814e-06\n  Newton Iteration 6, Residual Norm: 8.631e-08\n  Newton Iteration 7, Residual Norm: 4.916e-08\n  Newton Iteration 8, Residual Norm: 9.918e-09\n   Iter 0: Res_d=8.31e-09, Res_u=9.92e-09\n--- Time Step 141 ---\n  Newton Iteration 1, Residual Norm: 9.838e-09\n  Newton Iteration 1, Residual Norm: 9.755e-09\n  Newton Iteration 1, Residual Norm: 8.462e-01\n  Newton Iteration 2, Residual Norm: 3.320e-04\n  Newton Iteration 3, Residual Norm: 1.401e-04\n  Newton Iteration 4, Residual Norm: 6.408e-06\n  Newton Iteration 5, Residual Norm: 2.489e-06\n  Newton Iteration 6, Residual Norm: 1.061e-07\n  Newton Iteration 7, Residual Norm: 8.769e-08\n  Newton Iteration 8, Residual Norm: 9.921e-09\n   Iter 0: Res_d=9.75e-09, Res_u=9.92e-09\n--- Time Step 142 ---\n  Newton Iteration 1, Residual Norm: 9.828e-09\n  Newton Iteration 1, Residual Norm: 9.357e-09\n  Newton Iteration 1, Residual Norm: 8.529e-01\n  Newton Iteration 2, Residual Norm: 3.388e-04\n  Newton Iteration 3, Residual Norm: 1.454e-04\n  Newton Iteration 4, Residual Norm: 6.596e-06\n  Newton Iteration 5, Residual Norm: 2.402e-06\n  Newton Iteration 6, Residual Norm: 1.285e-07\n  Newton Iteration 7, Residual Norm: 4.438e-08\n  Newton Iteration 8, Residual Norm: 9.941e-09\n   Iter 0: Res_d=9.36e-09, Res_u=9.94e-09\n--- Time Step 143 ---\n  Newton Iteration 1, Residual Norm: 9.897e-09\n  Newton Iteration 1, Residual Norm: 9.493e-09\n  Newton Iteration 1, Residual Norm: 8.582e-01\n  Newton Iteration 2, Residual Norm: 3.508e-04\n  Newton Iteration 3, Residual Norm: 1.495e-04\n  Newton Iteration 4, Residual Norm: 9.076e-06\n  Newton Iteration 5, Residual Norm: 2.283e-06\n  Newton Iteration 6, Residual Norm: 1.496e-07\n  Newton Iteration 7, Residual Norm: 5.789e-08\n  Newton Iteration 8, Residual Norm: 9.953e-09\n   Iter 0: Res_d=9.49e-09, Res_u=9.95e-09\n--- Time Step 144 ---\n  Newton Iteration 1, Residual Norm: 9.754e-09\n  Newton Iteration 1, Residual Norm: 9.232e-09\n  Newton Iteration 1, Residual Norm: 8.626e-01\n  Newton Iteration 2, Residual Norm: 5.793e-04\n  Newton Iteration 3, Residual Norm: 1.464e-04\n  Newton Iteration 4, Residual Norm: 8.840e-06\n  Newton Iteration 5, Residual Norm: 3.221e-06\n  Newton Iteration 6, Residual Norm: 1.543e-07\n  Newton Iteration 7, Residual Norm: 5.636e-08\n  Newton Iteration 8, Residual Norm: 9.976e-09\n   Iter 0: Res_d=9.23e-09, Res_u=9.98e-09\n--- Time Step 145 ---\n  Newton Iteration 1, Residual Norm: 9.738e-09\n  Newton Iteration 1, Residual Norm: 9.096e-09\n  Newton Iteration 1, Residual Norm: 8.669e-01\n  Newton Iteration 2, Residual Norm: 9.072e-04\n  Newton Iteration 3, Residual Norm: 1.390e-04\n  Newton Iteration 4, Residual Norm: 9.982e-06\n  Newton Iteration 5, Residual Norm: 2.736e-06\n  Newton Iteration 6, Residual Norm: 1.977e-07\n  Newton Iteration 7, Residual Norm: 6.794e-08\n  Newton Iteration 8, Residual Norm: 9.847e-09\n   Iter 0: Res_d=9.10e-09, Res_u=9.85e-09\n--- Time Step 146 ---\n  Newton Iteration 1, Residual Norm: 9.714e-09\n  Newton Iteration 1, Residual Norm: 9.203e-09\n  Newton Iteration 1, Residual Norm: 8.707e-01\n  Newton Iteration 2, Residual Norm: 1.297e-03\n  Newton Iteration 3, Residual Norm: 1.359e-04\n  Newton Iteration 4, Residual Norm: 1.234e-05\n  Newton Iteration 5, Residual Norm: 2.534e-06\n  Newton Iteration 6, Residual Norm: 2.474e-07\n  Newton Iteration 7, Residual Norm: 5.177e-08\n  Newton Iteration 8, Residual Norm: 9.979e-09\n   Iter 0: Res_d=9.20e-09, Res_u=9.98e-09\n--- Time Step 147 ---\n  Newton Iteration 1, Residual Norm: 9.697e-09\n  Newton Iteration 1, Residual Norm: 8.194e-09\n  Newton Iteration 1, Residual Norm: 8.742e-01\n  Newton Iteration 2, Residual Norm: 1.074e-03\n  Newton Iteration 3, Residual Norm: 1.462e-04\n  Newton Iteration 4, Residual Norm: 1.208e-05\n  Newton Iteration 5, Residual Norm: 2.518e-06\n  Newton Iteration 6, Residual Norm: 3.442e-07\n  Newton Iteration 7, Residual Norm: 5.395e-08\n  Newton Iteration 8, Residual Norm: 9.982e-09\n   Iter 0: Res_d=8.19e-09, Res_u=9.98e-09\n--- Time Step 148 ---\n  Newton Iteration 1, Residual Norm: 9.618e-09\n  Newton Iteration 1, Residual Norm: 9.278e-09\n  Newton Iteration 1, Residual Norm: 8.771e-01\n  Newton Iteration 2, Residual Norm: 8.879e-04\n  Newton Iteration 3, Residual Norm: 1.581e-04\n  Newton Iteration 4, Residual Norm: 1.160e-05\n  Newton Iteration 5, Residual Norm: 3.116e-06\n  Newton Iteration 6, Residual Norm: 2.961e-07\n  Newton Iteration 7, Residual Norm: 1.231e-07\n  Newton Iteration 8, Residual Norm: 9.990e-09\n   Iter 0: Res_d=9.28e-09, Res_u=9.99e-09\n--- Time Step 149 ---\n  Newton Iteration 1, Residual Norm: 9.653e-09\n  Newton Iteration 1, Residual Norm: 9.050e-09\n  Newton Iteration 1, Residual Norm: 8.773e-01\n  Newton Iteration 2, Residual Norm: 7.528e-04\n  Newton Iteration 3, Residual Norm: 1.721e-04\n  Newton Iteration 4, Residual Norm: 1.627e-05\n  Newton Iteration 5, Residual Norm: 3.429e-06\n  Newton Iteration 6, Residual Norm: 3.348e-07\n  Newton Iteration 7, Residual Norm: 9.184e-08\n  Newton Iteration 8, Residual Norm: 9.981e-09\n   Iter 0: Res_d=9.05e-09, Res_u=9.98e-09\n--- Time Step 150 ---\n  Newton Iteration 1, Residual Norm: 9.594e-09\n  Newton Iteration 1, Residual Norm: 9.195e-09\n  Newton Iteration 1, Residual Norm: 8.809e-01\n  Newton Iteration 2, Residual Norm: 6.866e-04\n  Newton Iteration 3, Residual Norm: 1.798e-04\n  Newton Iteration 4, Residual Norm: 1.421e-05\n  Newton Iteration 5, Residual Norm: 6.461e-06\n  Newton Iteration 6, Residual Norm: 2.902e-07\n  Newton Iteration 7, Residual Norm: 1.672e-07\n  Newton Iteration 8, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.20e-09, Res_u=9.99e-09\n--- Time Step 151 ---\n  Newton Iteration 1, Residual Norm: 9.588e-09\n  Newton Iteration 1, Residual Norm: 8.730e-09\n  Newton Iteration 1, Residual Norm: 8.840e-01\n  Newton Iteration 2, Residual Norm: 6.015e-04\n  Newton Iteration 3, Residual Norm: 1.885e-04\n  Newton Iteration 4, Residual Norm: 1.573e-05\n  Newton Iteration 5, Residual Norm: 4.533e-06\n  Newton Iteration 6, Residual Norm: 4.698e-07\n  Newton Iteration 7, Residual Norm: 1.267e-07\n  Newton Iteration 8, Residual Norm: 9.937e-09\n   Iter 0: Res_d=8.73e-09, Res_u=9.94e-09\n--- Time Step 152 ---\n  Newton Iteration 1, Residual Norm: 9.517e-09\n  Newton Iteration 1, Residual Norm: 9.877e-09\n  Newton Iteration 1, Residual Norm: 8.866e-01\n  Newton Iteration 2, Residual Norm: 6.156e-04\n  Newton Iteration 3, Residual Norm: 1.934e-04\n  Newton Iteration 4, Residual Norm: 1.592e-05\n  Newton Iteration 5, Residual Norm: 6.691e-06\n  Newton Iteration 6, Residual Norm: 4.185e-07\n  Newton Iteration 7, Residual Norm: 1.732e-07\n  Newton Iteration 8, Residual Norm: 1.358e-08\n  Newton Iteration 9, Residual Norm: 9.968e-09\n   Iter 0: Res_d=9.88e-09, Res_u=9.97e-09\n--- Time Step 153 ---\n  Newton Iteration 1, Residual Norm: 9.454e-09\n  Newton Iteration 1, Residual Norm: 9.824e-09\n  Newton Iteration 1, Residual Norm: 8.892e-01\n  Newton Iteration 2, Residual Norm: 6.051e-04\n  Newton Iteration 3, Residual Norm: 1.881e-04\n  Newton Iteration 4, Residual Norm: 2.125e-05\n  Newton Iteration 5, Residual Norm: 5.241e-06\n  Newton Iteration 6, Residual Norm: 7.500e-07\n  Newton Iteration 7, Residual Norm: 1.518e-07\n  Newton Iteration 8, Residual Norm: 2.202e-08\n  Newton Iteration 9, Residual Norm: 9.960e-09\n   Iter 0: Res_d=9.82e-09, Res_u=9.96e-09\n--- Time Step 154 ---\n  Newton Iteration 1, Residual Norm: 9.500e-09\n  Newton Iteration 1, Residual Norm: 8.285e-09\n  Newton Iteration 1, Residual Norm: 8.909e-01\n  Newton Iteration 2, Residual Norm: 6.169e-04\n  Newton Iteration 3, Residual Norm: 1.648e-03\n  Newton Iteration 4, Residual Norm: 1.927e-05\n  Newton Iteration 5, Residual Norm: 6.169e-06\n  Newton Iteration 6, Residual Norm: 4.640e-07\n  Newton Iteration 7, Residual Norm: 2.543e-07\n  Newton Iteration 8, Residual Norm: 1.433e-08\n  Newton Iteration 9, Residual Norm: 9.971e-09\n   Iter 0: Res_d=8.29e-09, Res_u=9.97e-09\n--- Time Step 155 ---\n  Newton Iteration 1, Residual Norm: 9.480e-09\n  Newton Iteration 1, Residual Norm: 9.834e-09\n  Newton Iteration 1, Residual Norm: 8.935e-01\n  Newton Iteration 2, Residual Norm: 6.899e-04\n  Newton Iteration 3, Residual Norm: 1.962e-04\n  Newton Iteration 4, Residual Norm: 1.552e-05\n  Newton Iteration 5, Residual Norm: 8.044e-06\n  Newton Iteration 6, Residual Norm: 4.600e-07\n  Newton Iteration 7, Residual Norm: 1.928e-07\n  Newton Iteration 8, Residual Norm: 1.919e-08\n  Newton Iteration 9, Residual Norm: 9.936e-09\n   Iter 0: Res_d=9.83e-09, Res_u=9.94e-09\n--- Time Step 156 ---\n  Newton Iteration 1, Residual Norm: 9.484e-09\n  Newton Iteration 1, Residual Norm: 9.291e-09\n  Newton Iteration 1, Residual Norm: 8.966e-01\n  Newton Iteration 2, Residual Norm: 2.593e-03\n  Newton Iteration 3, Residual Norm: 1.867e-04\n  Newton Iteration 4, Residual Norm: 2.045e-05\n  Newton Iteration 5, Residual Norm: 5.430e-06\n  Newton Iteration 6, Residual Norm: 9.692e-07\n  Newton Iteration 7, Residual Norm: 1.722e-07\n  Newton Iteration 8, Residual Norm: 2.918e-08\n  Newton Iteration 9, Residual Norm: 9.963e-09\n   Iter 0: Res_d=9.29e-09, Res_u=9.96e-09\n--- Time Step 157 ---\n  Newton Iteration 1, Residual Norm: 9.395e-09\n  Newton Iteration 1, Residual Norm: 8.142e-09\n  Newton Iteration 1, Residual Norm: 9.028e-01\n  Newton Iteration 2, Residual Norm: 4.518e-03\n  Newton Iteration 3, Residual Norm: 1.979e-04\n  Newton Iteration 4, Residual Norm: 2.148e-05\n  Newton Iteration 5, Residual Norm: 6.022e-06\n  Newton Iteration 6, Residual Norm: 5.391e-07\n  Newton Iteration 7, Residual Norm: 2.593e-07\n  Newton Iteration 8, Residual Norm: 1.942e-08\n  Newton Iteration 9, Residual Norm: 9.953e-09\n   Iter 0: Res_d=8.14e-09, Res_u=9.95e-09\n--- Time Step 158 ---\n  Newton Iteration 1, Residual Norm: 9.427e-09\n  Newton Iteration 1, Residual Norm: 9.723e-09\n  Newton Iteration 1, Residual Norm: 9.093e-01\n  Newton Iteration 2, Residual Norm: 6.661e-03\n  Newton Iteration 3, Residual Norm: 2.034e-04\n  Newton Iteration 4, Residual Norm: 1.937e-05\n  Newton Iteration 5, Residual Norm: 8.287e-06\n  Newton Iteration 6, Residual Norm: 5.460e-07\n  Newton Iteration 7, Residual Norm: 2.437e-07\n  Newton Iteration 8, Residual Norm: 1.687e-08\n  Newton Iteration 9, Residual Norm: 9.943e-09\n   Iter 0: Res_d=9.72e-09, Res_u=9.94e-09\n--- Time Step 159 ---\n  Newton Iteration 1, Residual Norm: 9.384e-09\n  Newton Iteration 1, Residual Norm: 9.815e-09\n  Newton Iteration 1, Residual Norm: 9.153e-01\n  Newton Iteration 2, Residual Norm: 8.750e-03\n  Newton Iteration 3, Residual Norm: 1.965e-04\n  Newton Iteration 4, Residual Norm: 2.120e-05\n  Newton Iteration 5, Residual Norm: 8.632e-06\n  Newton Iteration 6, Residual Norm: 4.732e-07\n  Newton Iteration 7, Residual Norm: 3.756e-07\n  Newton Iteration 8, Residual Norm: 1.461e-08\n  Newton Iteration 9, Residual Norm: 9.982e-09\n   Iter 0: Res_d=9.81e-09, Res_u=9.98e-09\n--- Time Step 160 ---\n  Newton Iteration 1, Residual Norm: 9.355e-09\n  Newton Iteration 1, Residual Norm: 9.534e-09\n  Newton Iteration 1, Residual Norm: 9.202e-01\n  Newton Iteration 2, Residual Norm: 1.081e-02\n  Newton Iteration 3, Residual Norm: 1.969e-04\n  Newton Iteration 4, Residual Norm: 2.143e-05\n  Newton Iteration 5, Residual Norm: 5.358e-06\n  Newton Iteration 6, Residual Norm: 7.058e-07\n  Newton Iteration 7, Residual Norm: 1.855e-07\n  Newton Iteration 8, Residual Norm: 4.622e-08\n  Newton Iteration 9, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.53e-09, Res_u=9.98e-09\n--- Time Step 161 ---\n  Newton Iteration 1, Residual Norm: 9.365e-09\n  Newton Iteration 1, Residual Norm: 9.729e-09\n  Newton Iteration 1, Residual Norm: 9.237e-01\n  Newton Iteration 2, Residual Norm: 1.280e-02\n  Newton Iteration 3, Residual Norm: 2.100e-04\n  Newton Iteration 4, Residual Norm: 2.123e-05\n  Newton Iteration 5, Residual Norm: 5.379e-06\n  Newton Iteration 6, Residual Norm: 8.823e-07\n  Newton Iteration 7, Residual Norm: 1.804e-07\n  Newton Iteration 8, Residual Norm: 4.879e-08\n  Newton Iteration 9, Residual Norm: 9.938e-09\n   Iter 0: Res_d=9.73e-09, Res_u=9.94e-09\n--- Time Step 162 ---\n  Newton Iteration 1, Residual Norm: 9.342e-09\n  Newton Iteration 1, Residual Norm: 8.848e-09\n  Newton Iteration 1, Residual Norm: 9.269e-01\n  Newton Iteration 2, Residual Norm: 1.477e-02\n  Newton Iteration 3, Residual Norm: 2.101e-04\n  Newton Iteration 4, Residual Norm: 1.945e-05\n  Newton Iteration 5, Residual Norm: 7.039e-06\n  Newton Iteration 6, Residual Norm: 6.214e-07\n  Newton Iteration 7, Residual Norm: 3.854e-07\n  Newton Iteration 8, Residual Norm: 1.810e-08\n  Newton Iteration 9, Residual Norm: 9.973e-09\n   Iter 0: Res_d=8.85e-09, Res_u=9.97e-09\n--- Time Step 163 ---\n  Newton Iteration 1, Residual Norm: 9.323e-09\n  Newton Iteration 1, Residual Norm: 9.993e-09\n  Newton Iteration 1, Residual Norm: 9.312e-01\n  Newton Iteration 2, Residual Norm: 1.671e-02\n  Newton Iteration 3, Residual Norm: 2.107e-04\n  Newton Iteration 4, Residual Norm: 2.817e-05\n  Newton Iteration 5, Residual Norm: 5.373e-06\n  Newton Iteration 6, Residual Norm: 8.399e-07\n  Newton Iteration 7, Residual Norm: 2.755e-07\n  Newton Iteration 8, Residual Norm: 2.390e-08\n  Newton Iteration 9, Residual Norm: 9.959e-09\n   Iter 0: Res_d=9.99e-09, Res_u=9.96e-09\n--- Time Step 164 ---\n  Newton Iteration 1, Residual Norm: 9.289e-09\n  Newton Iteration 1, Residual Norm: 9.591e-09\n  Newton Iteration 1, Residual Norm: 9.345e-01\n  Newton Iteration 2, Residual Norm: 1.859e-02\n  Newton Iteration 3, Residual Norm: 2.070e-04\n  Newton Iteration 4, Residual Norm: 2.990e-05\n  Newton Iteration 5, Residual Norm: 4.790e-06\n  Newton Iteration 6, Residual Norm: 1.339e-06\n  Newton Iteration 7, Residual Norm: 1.548e-07\n  Newton Iteration 8, Residual Norm: 5.884e-08\n  Newton Iteration 9, Residual Norm: 9.871e-09\n   Iter 0: Res_d=9.59e-09, Res_u=9.87e-09\n--- Time Step 165 ---\n  Newton Iteration 1, Residual Norm: 9.355e-09\n  Newton Iteration 1, Residual Norm: 8.400e-09\n  Newton Iteration 1, Residual Norm: 9.346e-01\n  Newton Iteration 2, Residual Norm: 2.042e-02\n  Newton Iteration 3, Residual Norm: 2.095e-04\n  Newton Iteration 4, Residual Norm: 2.843e-05\n  Newton Iteration 5, Residual Norm: 5.281e-06\n  Newton Iteration 6, Residual Norm: 1.291e-06\n  Newton Iteration 7, Residual Norm: 1.551e-07\n  Newton Iteration 8, Residual Norm: 5.960e-08\n  Newton Iteration 9, Residual Norm: 9.888e-09\n   Iter 0: Res_d=8.40e-09, Res_u=9.89e-09\n--- Time Step 166 ---\n  Newton Iteration 1, Residual Norm: 9.215e-09\n  Newton Iteration 1, Residual Norm: 8.991e-09\n  Newton Iteration 1, Residual Norm: 9.342e-01\n  Newton Iteration 2, Residual Norm: 2.221e-02\n  Newton Iteration 3, Residual Norm: 2.153e-04\n  Newton Iteration 4, Residual Norm: 2.276e-05\n  Newton Iteration 5, Residual Norm: 5.874e-06\n  Newton Iteration 6, Residual Norm: 7.839e-07\n  Newton Iteration 7, Residual Norm: 3.988e-07\n  Newton Iteration 8, Residual Norm: 2.193e-08\n  Newton Iteration 9, Residual Norm: 9.991e-09\n   Iter 0: Res_d=8.99e-09, Res_u=9.99e-09\n--- Time Step 167 ---\n  Newton Iteration 1, Residual Norm: 9.222e-09\n  Newton Iteration 1, Residual Norm: 8.785e-09\n  Newton Iteration 1, Residual Norm: 9.332e-01\n  Newton Iteration 2, Residual Norm: 2.401e-02\n  Newton Iteration 3, Residual Norm: 2.060e-04\n  Newton Iteration 4, Residual Norm: 2.362e-05\n  Newton Iteration 5, Residual Norm: 5.458e-06\n  Newton Iteration 6, Residual Norm: 7.935e-07\n  Newton Iteration 7, Residual Norm: 1.934e-07\n  Newton Iteration 8, Residual Norm: 5.783e-08\n  Newton Iteration 9, Residual Norm: 9.981e-09\n   Iter 0: Res_d=8.79e-09, Res_u=9.98e-09\n--- Time Step 168 ---\n  Newton Iteration 1, Residual Norm: 9.233e-09\n  Newton Iteration 1, Residual Norm: 9.001e-09\n  Newton Iteration 1, Residual Norm: 9.325e-01\n  Newton Iteration 2, Residual Norm: 2.572e-02\n  Newton Iteration 3, Residual Norm: 2.061e-04\n  Newton Iteration 4, Residual Norm: 2.276e-05\n  Newton Iteration 5, Residual Norm: 6.293e-06\n  Newton Iteration 6, Residual Norm: 7.967e-07\n  Newton Iteration 7, Residual Norm: 3.172e-07\n  Newton Iteration 8, Residual Norm: 2.465e-08\n  Newton Iteration 9, Residual Norm: 9.953e-09\n   Iter 0: Res_d=9.00e-09, Res_u=9.95e-09\n--- Time Step 169 ---\n  Newton Iteration 1, Residual Norm: 9.146e-09\n  Newton Iteration 1, Residual Norm: 9.645e-09\n  Newton Iteration 1, Residual Norm: 9.349e-01\n  Newton Iteration 2, Residual Norm: 7.290e-04\n  Newton Iteration 3, Residual Norm: 2.432e-04\n  Newton Iteration 4, Residual Norm: 2.082e-05\n  Newton Iteration 5, Residual Norm: 6.279e-06\n  Newton Iteration 6, Residual Norm: 9.438e-07\n  Newton Iteration 7, Residual Norm: 2.007e-07\n  Newton Iteration 8, Residual Norm: 2.832e-08\n  Newton Iteration 9, Residual Norm: 9.991e-09\n   Iter 0: Res_d=9.64e-09, Res_u=9.99e-09\n--- Time Step 170 ---\n  Newton Iteration 1, Residual Norm: 9.135e-09\n  Newton Iteration 1, Residual Norm: 9.644e-09\n  Newton Iteration 1, Residual Norm: 9.384e-01\n  Newton Iteration 2, Residual Norm: 7.255e-04\n  Newton Iteration 3, Residual Norm: 2.431e-04\n  Newton Iteration 4, Residual Norm: 1.788e-05\n  Newton Iteration 5, Residual Norm: 1.039e-05\n  Newton Iteration 6, Residual Norm: 4.876e-07\n  Newton Iteration 7, Residual Norm: 4.309e-07\n  Newton Iteration 8, Residual Norm: 1.565e-08\n  Newton Iteration 9, Residual Norm: 9.974e-09\n   Iter 0: Res_d=9.64e-09, Res_u=9.97e-09\n--- Time Step 171 ---\n  Newton Iteration 1, Residual Norm: 9.151e-09\n  Newton Iteration 1, Residual Norm: 9.962e-09\n  Newton Iteration 1, Residual Norm: 9.423e-01\n  Newton Iteration 2, Residual Norm: 7.730e-04\n  Newton Iteration 3, Residual Norm: 2.372e-04\n  Newton Iteration 4, Residual Norm: 1.834e-05\n  Newton Iteration 5, Residual Norm: 6.975e-06\n  Newton Iteration 6, Residual Norm: 7.078e-07\n  Newton Iteration 7, Residual Norm: 2.178e-07\n  Newton Iteration 8, Residual Norm: 5.404e-08\n  Newton Iteration 9, Residual Norm: 9.980e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.98e-09\n--- Time Step 172 ---\n  Newton Iteration 1, Residual Norm: 9.100e-09\n  Newton Iteration 1, Residual Norm: 9.721e-09\n  Newton Iteration 1, Residual Norm: 9.441e-01\n  Newton Iteration 2, Residual Norm: 7.494e-04\n  Newton Iteration 3, Residual Norm: 2.442e-04\n  Newton Iteration 4, Residual Norm: 1.971e-05\n  Newton Iteration 5, Residual Norm: 6.541e-06\n  Newton Iteration 6, Residual Norm: 7.426e-07\n  Newton Iteration 7, Residual Norm: 2.306e-07\n  Newton Iteration 8, Residual Norm: 2.698e-08\n  Newton Iteration 9, Residual Norm: 9.969e-09\n   Iter 0: Res_d=9.72e-09, Res_u=9.97e-09\n--- Time Step 173 ---\n  Newton Iteration 1, Residual Norm: 9.113e-09\n  Newton Iteration 1, Residual Norm: 9.957e-09\n  Newton Iteration 1, Residual Norm: 9.464e-01\n  Newton Iteration 2, Residual Norm: 7.666e-04\n  Newton Iteration 3, Residual Norm: 2.497e-04\n  Newton Iteration 4, Residual Norm: 2.484e-05\n  Newton Iteration 5, Residual Norm: 7.448e-06\n  Newton Iteration 6, Residual Norm: 6.648e-07\n  Newton Iteration 7, Residual Norm: 3.912e-07\n  Newton Iteration 8, Residual Norm: 2.053e-08\n  Newton Iteration 9, Residual Norm: 9.964e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.96e-09\n--- Time Step 174 ---\n  Newton Iteration 1, Residual Norm: 9.033e-09\n  Newton Iteration 1, Residual Norm: 9.049e-09\n  Newton Iteration 1, Residual Norm: 9.547e-01\n  Newton Iteration 2, Residual Norm: 7.692e-04\n  Newton Iteration 3, Residual Norm: 2.509e-04\n  Newton Iteration 4, Residual Norm: 2.048e-05\n  Newton Iteration 5, Residual Norm: 7.546e-06\n  Newton Iteration 6, Residual Norm: 1.295e-06\n  Newton Iteration 7, Residual Norm: 2.132e-07\n  Newton Iteration 8, Residual Norm: 3.157e-08\n  Newton Iteration 9, Residual Norm: 9.950e-09\n   Iter 0: Res_d=9.05e-09, Res_u=9.95e-09\n--- Time Step 175 ---\n  Newton Iteration 1, Residual Norm: 9.076e-09\n  Newton Iteration 1, Residual Norm: 8.650e-09\n  Newton Iteration 1, Residual Norm: 9.608e-01\n  Newton Iteration 2, Residual Norm: 7.737e-04\n  Newton Iteration 3, Residual Norm: 2.605e-04\n  Newton Iteration 4, Residual Norm: 2.376e-05\n  Newton Iteration 5, Residual Norm: 7.834e-06\n  Newton Iteration 6, Residual Norm: 7.915e-07\n  Newton Iteration 7, Residual Norm: 2.449e-07\n  Newton Iteration 8, Residual Norm: 2.972e-08\n  Newton Iteration 9, Residual Norm: 9.982e-09\n   Iter 0: Res_d=8.65e-09, Res_u=9.98e-09\n--- Time Step 176 ---\n  Newton Iteration 1, Residual Norm: 9.040e-09\n  Newton Iteration 1, Residual Norm: 7.819e-09\n  Newton Iteration 1, Residual Norm: 9.664e-01\n  Newton Iteration 2, Residual Norm: 7.956e-04\n  Newton Iteration 3, Residual Norm: 2.652e-04\n  Newton Iteration 4, Residual Norm: 2.260e-05\n  Newton Iteration 5, Residual Norm: 7.478e-06\n  Newton Iteration 6, Residual Norm: 7.925e-07\n  Newton Iteration 7, Residual Norm: 5.186e-07\n  Newton Iteration 8, Residual Norm: 2.387e-08\n  Newton Iteration 9, Residual Norm: 9.956e-09\n   Iter 0: Res_d=7.82e-09, Res_u=9.96e-09\n--- Time Step 177 ---\n  Newton Iteration 1, Residual Norm: 9.072e-09\n  Newton Iteration 1, Residual Norm: 9.449e-09\n  Newton Iteration 1, Residual Norm: 9.729e-01\n  Newton Iteration 2, Residual Norm: 8.075e-04\n  Newton Iteration 3, Residual Norm: 2.640e-04\n  Newton Iteration 4, Residual Norm: 2.120e-05\n  Newton Iteration 5, Residual Norm: 1.134e-05\n  Newton Iteration 6, Residual Norm: 6.602e-07\n  Newton Iteration 7, Residual Norm: 4.253e-07\n  Newton Iteration 8, Residual Norm: 2.277e-08\n  Newton Iteration 9, Residual Norm: 9.994e-09\n   Iter 0: Res_d=9.45e-09, Res_u=9.99e-09\n--- Time Step 178 ---\n  Newton Iteration 1, Residual Norm: 8.995e-09\n  Newton Iteration 1, Residual Norm: 9.373e-09\n  Newton Iteration 1, Residual Norm: 9.787e-01\n  Newton Iteration 2, Residual Norm: 8.502e-04\n  Newton Iteration 3, Residual Norm: 2.642e-04\n  Newton Iteration 4, Residual Norm: 2.362e-05\n  Newton Iteration 5, Residual Norm: 1.192e-05\n  Newton Iteration 6, Residual Norm: 5.990e-07\n  Newton Iteration 7, Residual Norm: 4.282e-07\n  Newton Iteration 8, Residual Norm: 2.195e-08\n  Newton Iteration 9, Residual Norm: 9.935e-09\n   Iter 0: Res_d=9.37e-09, Res_u=9.94e-09\n--- Time Step 179 ---\n  Newton Iteration 1, Residual Norm: 8.985e-09\n  Newton Iteration 1, Residual Norm: 9.725e-09\n  Newton Iteration 1, Residual Norm: 9.853e-01\n  Newton Iteration 2, Residual Norm: 9.574e-04\n  Newton Iteration 3, Residual Norm: 2.534e-04\n  Newton Iteration 4, Residual Norm: 2.291e-05\n  Newton Iteration 5, Residual Norm: 8.793e-06\n  Newton Iteration 6, Residual Norm: 9.364e-07\n  Newton Iteration 7, Residual Norm: 3.577e-07\n  Newton Iteration 8, Residual Norm: 2.828e-08\n  Newton Iteration 9, Residual Norm: 9.947e-09\n   Iter 0: Res_d=9.73e-09, Res_u=9.95e-09\n--- Time Step 180 ---\n  Newton Iteration 1, Residual Norm: 8.991e-09\n  Newton Iteration 1, Residual Norm: 9.778e-09\n  Newton Iteration 1, Residual Norm: 9.899e-01\n  Newton Iteration 2, Residual Norm: 1.079e-03\n  Newton Iteration 3, Residual Norm: 2.571e-04\n  Newton Iteration 4, Residual Norm: 2.511e-05\n  Newton Iteration 5, Residual Norm: 8.621e-06\n  Newton Iteration 6, Residual Norm: 8.170e-07\n  Newton Iteration 7, Residual Norm: 5.519e-07\n  Newton Iteration 8, Residual Norm: 2.511e-08\n  Newton Iteration 9, Residual Norm: 9.934e-09\n   Iter 0: Res_d=9.78e-09, Res_u=9.93e-09\n--- Time Step 181 ---\n  Newton Iteration 1, Residual Norm: 8.988e-09\n  Newton Iteration 1, Residual Norm: 9.894e-09\n  Newton Iteration 1, Residual Norm: 9.955e-01\n  Newton Iteration 2, Residual Norm: 1.235e-03\n  Newton Iteration 3, Residual Norm: 2.477e-04\n  Newton Iteration 4, Residual Norm: 2.948e-05\n  Newton Iteration 5, Residual Norm: 1.070e-05\n  Newton Iteration 6, Residual Norm: 8.628e-07\n  Newton Iteration 7, Residual Norm: 2.786e-07\n  Newton Iteration 8, Residual Norm: 5.484e-08\n  Newton Iteration 9, Residual Norm: 9.970e-09\n   Iter 0: Res_d=9.89e-09, Res_u=9.97e-09\n--- Time Step 182 ---\n  Newton Iteration 1, Residual Norm: 8.936e-09\n  Newton Iteration 1, Residual Norm: 8.119e-09\n  Newton Iteration 1, Residual Norm: 1.002e+00\n  Newton Iteration 2, Residual Norm: 1.418e-03\n  Newton Iteration 3, Residual Norm: 2.424e-04\n  Newton Iteration 4, Residual Norm: 3.896e-05\n  Newton Iteration 5, Residual Norm: 5.851e-06\n  Newton Iteration 6, Residual Norm: 1.845e-06\n  Newton Iteration 7, Residual Norm: 1.926e-07\n  Newton Iteration 8, Residual Norm: 5.078e-08\n  Newton Iteration 9, Residual Norm: 9.908e-09\n   Iter 0: Res_d=8.12e-09, Res_u=9.91e-09\n--- Time Step 183 ---\n  Newton Iteration 1, Residual Norm: 8.936e-09\n  Newton Iteration 1, Residual Norm: 9.225e-09\n  Newton Iteration 1, Residual Norm: 1.005e+00\n  Newton Iteration 2, Residual Norm: 1.581e-03\n  Newton Iteration 3, Residual Norm: 2.329e-04\n  Newton Iteration 4, Residual Norm: 3.670e-05\n  Newton Iteration 5, Residual Norm: 6.554e-06\n  Newton Iteration 6, Residual Norm: 1.122e-06\n  Newton Iteration 7, Residual Norm: 2.400e-07\n  Newton Iteration 8, Residual Norm: 8.600e-08\n  Newton Iteration 9, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.23e-09, Res_u=9.98e-09\n--- Time Step 184 ---\n  Newton Iteration 1, Residual Norm: 8.945e-09\n  Newton Iteration 1, Residual Norm: 9.938e-09\n  Newton Iteration 1, Residual Norm: 1.007e+00\n  Newton Iteration 2, Residual Norm: 1.773e-03\n  Newton Iteration 3, Residual Norm: 2.339e-04\n  Newton Iteration 4, Residual Norm: 3.448e-05\n  Newton Iteration 5, Residual Norm: 6.540e-06\n  Newton Iteration 6, Residual Norm: 1.501e-06\n  Newton Iteration 7, Residual Norm: 2.395e-07\n  Newton Iteration 8, Residual Norm: 4.320e-08\n  Newton Iteration 9, Residual Norm: 9.957e-09\n   Iter 0: Res_d=9.94e-09, Res_u=9.96e-09\n--- Time Step 185 ---\n  Newton Iteration 1, Residual Norm: 8.917e-09\n  Newton Iteration 1, Residual Norm: 9.929e-09\n  Newton Iteration 1, Residual Norm: 1.010e+00\n  Newton Iteration 2, Residual Norm: 1.989e-03\n  Newton Iteration 3, Residual Norm: 2.317e-04\n  Newton Iteration 4, Residual Norm: 3.799e-05\n  Newton Iteration 5, Residual Norm: 9.380e-06\n  Newton Iteration 6, Residual Norm: 8.947e-07\n  Newton Iteration 7, Residual Norm: 4.827e-07\n  Newton Iteration 8, Residual Norm: 2.626e-08\n  Newton Iteration 9, Residual Norm: 9.980e-09\n   Iter 0: Res_d=9.93e-09, Res_u=9.98e-09\n--- Time Step 186 ---\n  Newton Iteration 1, Residual Norm: 8.904e-09\n  Newton Iteration 1, Residual Norm: 7.824e-09\n  Newton Iteration 1, Residual Norm: 1.011e+00\n  Newton Iteration 2, Residual Norm: 1.075e-03\n  Newton Iteration 3, Residual Norm: 2.779e-04\n  Newton Iteration 4, Residual Norm: 2.786e-05\n  Newton Iteration 5, Residual Norm: 8.160e-06\n  Newton Iteration 6, Residual Norm: 9.368e-07\n  Newton Iteration 7, Residual Norm: 2.951e-07\n  Newton Iteration 8, Residual Norm: 3.608e-08\n  Newton Iteration 9, Residual Norm: 9.988e-09\n   Iter 0: Res_d=7.82e-09, Res_u=9.99e-09\n--- Time Step 187 ---\n  Newton Iteration 1, Residual Norm: 8.874e-09\n  Newton Iteration 1, Residual Norm: 8.845e-09\n  Newton Iteration 1, Residual Norm: 1.011e+00\n  Newton Iteration 2, Residual Norm: 1.123e-03\n  Newton Iteration 3, Residual Norm: 2.524e-04\n  Newton Iteration 4, Residual Norm: 4.197e-05\n  Newton Iteration 5, Residual Norm: 6.616e-06\n  Newton Iteration 6, Residual Norm: 1.332e-06\n  Newton Iteration 7, Residual Norm: 2.172e-07\n  Newton Iteration 8, Residual Norm: 4.725e-08\n  Newton Iteration 9, Residual Norm: 9.976e-09\n   Iter 0: Res_d=8.85e-09, Res_u=9.98e-09\n--- Time Step 188 ---\n  Newton Iteration 1, Residual Norm: 8.819e-09\n  Newton Iteration 1, Residual Norm: 9.162e-09\n  Newton Iteration 1, Residual Norm: 1.012e+00\n  Newton Iteration 2, Residual Norm: 1.174e-03\n  Newton Iteration 3, Residual Norm: 2.641e-04\n  Newton Iteration 4, Residual Norm: 2.867e-05\n  Newton Iteration 5, Residual Norm: 1.079e-05\n  Newton Iteration 6, Residual Norm: 8.333e-07\n  Newton Iteration 7, Residual Norm: 3.038e-07\n  Newton Iteration 8, Residual Norm: 3.354e-08\n  Newton Iteration 9, Residual Norm: 9.994e-09\n   Iter 0: Res_d=9.16e-09, Res_u=9.99e-09\n--- Time Step 189 ---\n  Newton Iteration 1, Residual Norm: 8.836e-09\n  Newton Iteration 1, Residual Norm: 9.786e-09\n  Newton Iteration 1, Residual Norm: 1.013e+00\n  Newton Iteration 2, Residual Norm: 1.242e-03\n  Newton Iteration 3, Residual Norm: 2.693e-04\n  Newton Iteration 4, Residual Norm: 3.342e-05\n  Newton Iteration 5, Residual Norm: 8.014e-06\n  Newton Iteration 6, Residual Norm: 9.727e-07\n  Newton Iteration 7, Residual Norm: 4.323e-07\n  Newton Iteration 8, Residual Norm: 3.041e-08\n  Newton Iteration 9, Residual Norm: 9.969e-09\n   Iter 0: Res_d=9.79e-09, Res_u=9.97e-09\n--- Time Step 190 ---\n  Newton Iteration 1, Residual Norm: 8.776e-09\n  Newton Iteration 1, Residual Norm: 9.130e-09\n  Newton Iteration 1, Residual Norm: 1.016e+00\n  Newton Iteration 2, Residual Norm: 1.303e-03\n  Newton Iteration 3, Residual Norm: 2.552e-04\n  Newton Iteration 4, Residual Norm: 3.352e-05\n  Newton Iteration 5, Residual Norm: 1.012e-05\n  Newton Iteration 6, Residual Norm: 1.005e-06\n  Newton Iteration 7, Residual Norm: 5.433e-07\n  Newton Iteration 8, Residual Norm: 2.551e-08\n  Newton Iteration 9, Residual Norm: 9.954e-09\n   Iter 0: Res_d=9.13e-09, Res_u=9.95e-09\n--- Time Step 191 ---\n  Newton Iteration 1, Residual Norm: 8.817e-09\n  Newton Iteration 1, Residual Norm: 9.301e-09\n  Newton Iteration 1, Residual Norm: 1.018e+00\n  Newton Iteration 2, Residual Norm: 1.389e-03\n  Newton Iteration 3, Residual Norm: 2.505e-04\n  Newton Iteration 4, Residual Norm: 4.426e-05\n  Newton Iteration 5, Residual Norm: 5.880e-06\n  Newton Iteration 6, Residual Norm: 2.032e-06\n  Newton Iteration 7, Residual Norm: 1.801e-07\n  Newton Iteration 8, Residual Norm: 6.684e-08\n  Newton Iteration 9, Residual Norm: 9.968e-09\n   Iter 0: Res_d=9.30e-09, Res_u=9.97e-09\n--- Time Step 192 ---\n  Newton Iteration 1, Residual Norm: 8.752e-09\n  Newton Iteration 1, Residual Norm: 9.324e-09\n  Newton Iteration 1, Residual Norm: 1.019e+00\n  Newton Iteration 2, Residual Norm: 1.488e-03\n  Newton Iteration 3, Residual Norm: 2.314e-04\n  Newton Iteration 4, Residual Norm: 4.821e-05\n  Newton Iteration 5, Residual Norm: 5.974e-06\n  Newton Iteration 6, Residual Norm: 1.190e-06\n  Newton Iteration 7, Residual Norm: 2.097e-07\n  Newton Iteration 8, Residual Norm: 6.776e-08\n  Newton Iteration 9, Residual Norm: 9.973e-09\n   Iter 0: Res_d=9.32e-09, Res_u=9.97e-09\n--- Time Step 193 ---\n  Newton Iteration 1, Residual Norm: 8.760e-09\n  Newton Iteration 1, Residual Norm: 9.252e-09\n  Newton Iteration 1, Residual Norm: 1.020e+00\n  Newton Iteration 2, Residual Norm: 1.613e-03\n  Newton Iteration 3, Residual Norm: 2.356e-04\n  Newton Iteration 4, Residual Norm: 3.514e-05\n  Newton Iteration 5, Residual Norm: 6.612e-06\n  Newton Iteration 6, Residual Norm: 1.159e-06\n  Newton Iteration 7, Residual Norm: 4.125e-07\n  Newton Iteration 8, Residual Norm: 3.007e-08\n  Newton Iteration 9, Residual Norm: 9.958e-09\n   Iter 0: Res_d=9.25e-09, Res_u=9.96e-09\n--- Time Step 194 ---\n  Newton Iteration 1, Residual Norm: 8.771e-09\n  Newton Iteration 1, Residual Norm: 9.430e-09\n  Newton Iteration 1, Residual Norm: 1.020e+00\n  Newton Iteration 2, Residual Norm: 1.200e-03\n  Newton Iteration 3, Residual Norm: 2.381e-04\n  Newton Iteration 4, Residual Norm: 3.294e-05\n  Newton Iteration 5, Residual Norm: 1.110e-05\n  Newton Iteration 6, Residual Norm: 8.735e-07\n  Newton Iteration 7, Residual Norm: 2.557e-07\n  Newton Iteration 8, Residual Norm: 3.830e-08\n  Newton Iteration 9, Residual Norm: 9.974e-09\n   Iter 0: Res_d=9.43e-09, Res_u=9.97e-09\n--- Time Step 195 ---\n  Newton Iteration 1, Residual Norm: 8.787e-09\n  Newton Iteration 1, Residual Norm: 8.869e-09\n  Newton Iteration 1, Residual Norm: 1.021e+00\n  Newton Iteration 2, Residual Norm: 1.228e-03\n  Newton Iteration 3, Residual Norm: 2.641e-04\n  Newton Iteration 4, Residual Norm: 2.983e-05\n  Newton Iteration 5, Residual Norm: 7.421e-06\n  Newton Iteration 6, Residual Norm: 1.087e-06\n  Newton Iteration 7, Residual Norm: 3.645e-07\n  Newton Iteration 8, Residual Norm: 2.899e-08\n  Newton Iteration 9, Residual Norm: 9.978e-09\n   Iter 0: Res_d=8.87e-09, Res_u=9.98e-09\n--- Time Step 196 ---\n  Newton Iteration 1, Residual Norm: 8.735e-09\n  Newton Iteration 1, Residual Norm: 8.466e-09\n  Newton Iteration 1, Residual Norm: 1.022e+00\n  Newton Iteration 2, Residual Norm: 1.243e-03\n  Newton Iteration 3, Residual Norm: 2.636e-04\n  Newton Iteration 4, Residual Norm: 4.546e-05\n  Newton Iteration 5, Residual Norm: 5.693e-06\n  Newton Iteration 6, Residual Norm: 1.289e-06\n  Newton Iteration 7, Residual Norm: 1.758e-07\n  Newton Iteration 8, Residual Norm: 5.387e-08\n  Newton Iteration 9, Residual Norm: 9.956e-09\n   Iter 0: Res_d=8.47e-09, Res_u=9.96e-09\n--- Time Step 197 ---\n  Newton Iteration 1, Residual Norm: 8.706e-09\n  Newton Iteration 1, Residual Norm: 9.149e-09\n  Newton Iteration 1, Residual Norm: 1.024e+00\n  Newton Iteration 2, Residual Norm: 1.267e-03\n  Newton Iteration 3, Residual Norm: 2.483e-04\n  Newton Iteration 4, Residual Norm: 4.344e-05\n  Newton Iteration 5, Residual Norm: 7.186e-06\n  Newton Iteration 6, Residual Norm: 9.754e-07\n  Newton Iteration 7, Residual Norm: 4.015e-07\n  Newton Iteration 8, Residual Norm: 2.700e-08\n  Newton Iteration 9, Residual Norm: 9.929e-09\n   Iter 0: Res_d=9.15e-09, Res_u=9.93e-09\n--- Time Step 198 ---\n  Newton Iteration 1, Residual Norm: 8.684e-09\n  Newton Iteration 1, Residual Norm: 9.276e-09\n  Newton Iteration 1, Residual Norm: 1.025e+00\n  Newton Iteration 2, Residual Norm: 1.279e-03\n  Newton Iteration 3, Residual Norm: 2.293e-04\n  Newton Iteration 4, Residual Norm: 3.355e-05\n  Newton Iteration 5, Residual Norm: 6.713e-06\n  Newton Iteration 6, Residual Norm: 1.976e-06\n  Newton Iteration 7, Residual Norm: 1.523e-07\n  Newton Iteration 8, Residual Norm: 5.135e-08\n  Newton Iteration 9, Residual Norm: 9.931e-09\n   Iter 0: Res_d=9.28e-09, Res_u=9.93e-09\n--- Time Step 199 ---\n  Newton Iteration 1, Residual Norm: 8.686e-09\n  Newton Iteration 1, Residual Norm: 9.876e-09\n  Newton Iteration 1, Residual Norm: 1.027e+00\n  Newton Iteration 2, Residual Norm: 1.336e-03\n  Newton Iteration 3, Residual Norm: 2.401e-04\n  Newton Iteration 4, Residual Norm: 3.153e-05\n  Newton Iteration 5, Residual Norm: 6.898e-06\n  Newton Iteration 6, Residual Norm: 1.014e-06\n  Newton Iteration 7, Residual Norm: 4.663e-07\n  Newton Iteration 8, Residual Norm: 2.618e-08\n  Newton Iteration 9, Residual Norm: 9.937e-09\n   Iter 0: Res_d=9.88e-09, Res_u=9.94e-09\n--- Time Step 200 ---\n  Newton Iteration 1, Residual Norm: 8.687e-09\n  Newton Iteration 1, Residual Norm: 9.633e-09\n  Newton Iteration 1, Residual Norm: 1.029e+00\n  Newton Iteration 2, Residual Norm: 1.320e-03\n  Newton Iteration 3, Residual Norm: 2.329e-04\n  Newton Iteration 4, Residual Norm: 3.217e-05\n  Newton Iteration 5, Residual Norm: 6.733e-06\n  Newton Iteration 6, Residual Norm: 1.063e-06\n  Newton Iteration 7, Residual Norm: 3.171e-07\n  Newton Iteration 8, Residual Norm: 3.263e-08\n  Newton Iteration 9, Residual Norm: 9.976e-09\n   Iter 0: Res_d=9.63e-09, Res_u=9.98e-09\n--- Time Step 201 ---\n  Newton Iteration 1, Residual Norm: 8.672e-09\n  Newton Iteration 1, Residual Norm: 9.226e-09\n  Newton Iteration 1, Residual Norm: 1.032e+00\n  Newton Iteration 2, Residual Norm: 1.385e-03\n  Newton Iteration 3, Residual Norm: 2.310e-04\n  Newton Iteration 4, Residual Norm: 4.450e-05\n  Newton Iteration 5, Residual Norm: 5.319e-06\n  Newton Iteration 6, Residual Norm: 1.210e-06\n  Newton Iteration 7, Residual Norm: 2.601e-07\n  Newton Iteration 8, Residual Norm: 3.427e-08\n  Newton Iteration 9, Residual Norm: 9.971e-09\n   Iter 0: Res_d=9.23e-09, Res_u=9.97e-09\n--- Time Step 202 ---\n  Newton Iteration 1, Residual Norm: 8.608e-09\n  Newton Iteration 1, Residual Norm: 9.513e-09\n  Newton Iteration 1, Residual Norm: 1.035e+00\n  Newton Iteration 2, Residual Norm: 1.415e-03\n  Newton Iteration 3, Residual Norm: 2.456e-04\n  Newton Iteration 4, Residual Norm: 3.624e-05\n  Newton Iteration 5, Residual Norm: 7.060e-06\n  Newton Iteration 6, Residual Norm: 1.042e-06\n  Newton Iteration 7, Residual Norm: 2.520e-07\n  Newton Iteration 8, Residual Norm: 3.969e-08\n  Newton Iteration 9, Residual Norm: 9.951e-09\n   Iter 0: Res_d=9.51e-09, Res_u=9.95e-09\n--- Time Step 203 ---\n  Newton Iteration 1, Residual Norm: 8.640e-09\n  Newton Iteration 1, Residual Norm: 9.913e-09\n  Newton Iteration 1, Residual Norm: 1.037e+00\n  Newton Iteration 2, Residual Norm: 1.504e-03\n  Newton Iteration 3, Residual Norm: 2.435e-04\n  Newton Iteration 4, Residual Norm: 3.529e-05\n  Newton Iteration 5, Residual Norm: 7.016e-06\n  Newton Iteration 6, Residual Norm: 1.044e-06\n  Newton Iteration 7, Residual Norm: 3.146e-07\n  Newton Iteration 8, Residual Norm: 3.382e-08\n  Newton Iteration 9, Residual Norm: 9.935e-09\n   Iter 0: Res_d=9.91e-09, Res_u=9.93e-09\n--- Time Step 204 ---\n  Newton Iteration 1, Residual Norm: 8.622e-09\n  Newton Iteration 1, Residual Norm: 8.466e-09\n  Newton Iteration 1, Residual Norm: 1.039e+00\n  Newton Iteration 2, Residual Norm: 1.613e-03\n  Newton Iteration 3, Residual Norm: 2.380e-04\n  Newton Iteration 4, Residual Norm: 3.499e-05\n  Newton Iteration 5, Residual Norm: 1.040e-05\n  Newton Iteration 6, Residual Norm: 1.059e-06\n  Newton Iteration 7, Residual Norm: 2.278e-07\n  Newton Iteration 8, Residual Norm: 3.829e-08\n  Newton Iteration 9, Residual Norm: 9.997e-09\n   Iter 0: Res_d=8.47e-09, Res_u=1.00e-08\n--- Time Step 205 ---\n  Newton Iteration 1, Residual Norm: 8.619e-09\n  Newton Iteration 1, Residual Norm: 9.072e-09\n  Newton Iteration 1, Residual Norm: 1.042e+00\n  Newton Iteration 2, Residual Norm: 1.369e-03\n  Newton Iteration 3, Residual Norm: 2.346e-04\n  Newton Iteration 4, Residual Norm: 3.360e-05\n  Newton Iteration 5, Residual Norm: 7.509e-06\n  Newton Iteration 6, Residual Norm: 1.821e-06\n  Newton Iteration 7, Residual Norm: 2.114e-07\n  Newton Iteration 8, Residual Norm: 4.295e-08\n  Newton Iteration 9, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.07e-09, Res_u=9.98e-09\n--- Time Step 206 ---\n  Newton Iteration 1, Residual Norm: 8.609e-09\n  Newton Iteration 1, Residual Norm: 9.471e-09\n  Newton Iteration 1, Residual Norm: 1.045e+00\n  Newton Iteration 2, Residual Norm: 1.380e-03\n  Newton Iteration 3, Residual Norm: 2.354e-04\n  Newton Iteration 4, Residual Norm: 3.353e-05\n  Newton Iteration 5, Residual Norm: 8.114e-06\n  Newton Iteration 6, Residual Norm: 1.072e-06\n  Newton Iteration 7, Residual Norm: 5.024e-07\n  Newton Iteration 8, Residual Norm: 2.785e-08\n  Newton Iteration 9, Residual Norm: 9.996e-09\n   Iter 0: Res_d=9.47e-09, Res_u=1.00e-08\n--- Time Step 207 ---\n  Newton Iteration 1, Residual Norm: 8.603e-09\n  Newton Iteration 1, Residual Norm: 8.768e-09\n  Newton Iteration 1, Residual Norm: 1.048e+00\n  Newton Iteration 2, Residual Norm: 1.420e-03\n  Newton Iteration 3, Residual Norm: 2.266e-04\n  Newton Iteration 4, Residual Norm: 4.639e-05\n  Newton Iteration 5, Residual Norm: 5.295e-06\n  Newton Iteration 6, Residual Norm: 1.384e-06\n  Newton Iteration 7, Residual Norm: 1.862e-07\n  Newton Iteration 8, Residual Norm: 5.971e-08\n  Newton Iteration 9, Residual Norm: 9.960e-09\n   Iter 0: Res_d=8.77e-09, Res_u=9.96e-09\n--- Time Step 208 ---\n  Newton Iteration 1, Residual Norm: 8.626e-09\n  Newton Iteration 1, Residual Norm: 9.700e-09\n  Newton Iteration 1, Residual Norm: 1.052e+00\n  Newton Iteration 2, Residual Norm: 1.428e-03\n  Newton Iteration 3, Residual Norm: 2.344e-04\n  Newton Iteration 4, Residual Norm: 3.770e-05\n  Newton Iteration 5, Residual Norm: 1.064e-05\n  Newton Iteration 6, Residual Norm: 9.177e-07\n  Newton Iteration 7, Residual Norm: 3.213e-07\n  Newton Iteration 8, Residual Norm: 3.357e-08\n  Newton Iteration 9, Residual Norm: 9.974e-09\n   Iter 0: Res_d=9.70e-09, Res_u=9.97e-09\n--- Time Step 209 ---\n  Newton Iteration 1, Residual Norm: 8.575e-09\n  Newton Iteration 1, Residual Norm: 9.485e-09\n  Newton Iteration 1, Residual Norm: 1.055e+00\n  Newton Iteration 2, Residual Norm: 1.469e-03\n  Newton Iteration 3, Residual Norm: 2.396e-04\n  Newton Iteration 4, Residual Norm: 3.642e-05\n  Newton Iteration 5, Residual Norm: 7.393e-06\n  Newton Iteration 6, Residual Norm: 1.457e-06\n  Newton Iteration 7, Residual Norm: 2.152e-07\n  Newton Iteration 8, Residual Norm: 5.764e-08\n  Newton Iteration 9, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.49e-09, Res_u=9.98e-09\n--- Time Step 210 ---\n  Newton Iteration 1, Residual Norm: 8.598e-09\n  Newton Iteration 1, Residual Norm: 9.931e-09\n  Newton Iteration 1, Residual Norm: 1.058e+00\n  Newton Iteration 2, Residual Norm: 1.455e-03\n  Newton Iteration 3, Residual Norm: 2.470e-04\n  Newton Iteration 4, Residual Norm: 3.296e-05\n  Newton Iteration 5, Residual Norm: 7.332e-06\n  Newton Iteration 6, Residual Norm: 1.091e-06\n  Newton Iteration 7, Residual Norm: 2.889e-07\n  Newton Iteration 8, Residual Norm: 3.594e-08\n  Newton Iteration 9, Residual Norm: 9.993e-09\n   Iter 0: Res_d=9.93e-09, Res_u=9.99e-09\n--- Time Step 211 ---\n  Newton Iteration 1, Residual Norm: 8.536e-09\n  Newton Iteration 1, Residual Norm: 8.399e-09\n  Newton Iteration 1, Residual Norm: 1.059e+00\n  Newton Iteration 2, Residual Norm: 1.469e-03\n  Newton Iteration 3, Residual Norm: 2.419e-04\n  Newton Iteration 4, Residual Norm: 4.015e-05\n  Newton Iteration 5, Residual Norm: 7.025e-06\n  Newton Iteration 6, Residual Norm: 1.095e-06\n  Newton Iteration 7, Residual Norm: 2.409e-07\n  Newton Iteration 8, Residual Norm: 8.702e-08\n  Newton Iteration 9, Residual Norm: 9.988e-09\n   Iter 0: Res_d=8.40e-09, Res_u=9.99e-09\n--- Time Step 212 ---\n  Newton Iteration 1, Residual Norm: 8.510e-09\n  Newton Iteration 1, Residual Norm: 8.457e-09\n  Newton Iteration 1, Residual Norm: 1.061e+00\n  Newton Iteration 2, Residual Norm: 1.486e-03\n  Newton Iteration 3, Residual Norm: 2.408e-04\n  Newton Iteration 4, Residual Norm: 3.235e-05\n  Newton Iteration 5, Residual Norm: 1.084e-05\n  Newton Iteration 6, Residual Norm: 8.872e-07\n  Newton Iteration 7, Residual Norm: 2.686e-07\n  Newton Iteration 8, Residual Norm: 3.630e-08\n  Newton Iteration 9, Residual Norm: 9.937e-09\n   Iter 0: Res_d=8.46e-09, Res_u=9.94e-09\n--- Time Step 213 ---\n  Newton Iteration 1, Residual Norm: 8.521e-09\n  Newton Iteration 1, Residual Norm: 8.720e-09\n  Newton Iteration 1, Residual Norm: 1.064e+00\n  Newton Iteration 2, Residual Norm: 1.529e-03\n  Newton Iteration 3, Residual Norm: 2.402e-04\n  Newton Iteration 4, Residual Norm: 3.211e-05\n  Newton Iteration 5, Residual Norm: 9.476e-06\n  Newton Iteration 6, Residual Norm: 9.364e-07\n  Newton Iteration 7, Residual Norm: 2.358e-07\n  Newton Iteration 8, Residual Norm: 4.230e-08\n  Newton Iteration 9, Residual Norm: 9.945e-09\n   Iter 0: Res_d=8.72e-09, Res_u=9.94e-09\n--- Time Step 214 ---\n  Newton Iteration 1, Residual Norm: 8.498e-09\n  Newton Iteration 1, Residual Norm: 9.578e-09\n  Newton Iteration 1, Residual Norm: 1.068e+00\n  Newton Iteration 2, Residual Norm: 1.555e-03\n  Newton Iteration 3, Residual Norm: 2.410e-04\n  Newton Iteration 4, Residual Norm: 3.640e-05\n  Newton Iteration 5, Residual Norm: 1.101e-05\n  Newton Iteration 6, Residual Norm: 8.114e-07\n  Newton Iteration 7, Residual Norm: 2.783e-07\n  Newton Iteration 8, Residual Norm: 2.727e-08\n  Newton Iteration 9, Residual Norm: 9.983e-09\n   Iter 0: Res_d=9.58e-09, Res_u=9.98e-09\n--- Time Step 215 ---\n  Newton Iteration 1, Residual Norm: 8.502e-09\n  Newton Iteration 1, Residual Norm: 9.197e-09\n  Newton Iteration 1, Residual Norm: 1.070e+00\n  Newton Iteration 2, Residual Norm: 1.608e-03\n  Newton Iteration 3, Residual Norm: 2.425e-04\n  Newton Iteration 4, Residual Norm: 3.807e-05\n  Newton Iteration 5, Residual Norm: 6.608e-06\n  Newton Iteration 6, Residual Norm: 1.115e-06\n  Newton Iteration 7, Residual Norm: 2.484e-07\n  Newton Iteration 8, Residual Norm: 4.649e-08\n  Newton Iteration 9, Residual Norm: 9.993e-09\n   Iter 0: Res_d=9.20e-09, Res_u=9.99e-09\n--- Time Step 216 ---\n  Newton Iteration 1, Residual Norm: 8.535e-09\n  Newton Iteration 1, Residual Norm: 9.485e-09\n  Newton Iteration 1, Residual Norm: 1.071e+00\n  Newton Iteration 2, Residual Norm: 2.371e-03\n  Newton Iteration 3, Residual Norm: 2.467e-04\n  Newton Iteration 4, Residual Norm: 3.922e-05\n  Newton Iteration 5, Residual Norm: 6.236e-06\n  Newton Iteration 6, Residual Norm: 1.180e-06\n  Newton Iteration 7, Residual Norm: 2.279e-07\n  Newton Iteration 8, Residual Norm: 4.199e-08\n  Newton Iteration 9, Residual Norm: 9.963e-09\n   Iter 0: Res_d=9.48e-09, Res_u=9.96e-09\n--- Time Step 217 ---\n  Newton Iteration 1, Residual Norm: 8.516e-09\n  Newton Iteration 1, Residual Norm: 7.941e-09\n  Newton Iteration 1, Residual Norm: 1.072e+00\n  Newton Iteration 2, Residual Norm: 4.340e-03\n  Newton Iteration 3, Residual Norm: 2.481e-04\n  Newton Iteration 4, Residual Norm: 4.343e-05\n  Newton Iteration 5, Residual Norm: 6.635e-06\n  Newton Iteration 6, Residual Norm: 2.111e-06\n  Newton Iteration 7, Residual Norm: 1.751e-07\n  Newton Iteration 8, Residual Norm: 5.109e-08\n  Newton Iteration 9, Residual Norm: 9.998e-09\n   Iter 0: Res_d=7.94e-09, Res_u=1.00e-08\n--- Time Step 218 ---\n  Newton Iteration 1, Residual Norm: 8.452e-09\n  Newton Iteration 1, Residual Norm: 9.874e-09\n  Newton Iteration 1, Residual Norm: 1.075e+00\n  Newton Iteration 2, Residual Norm: 6.448e-03\n  Newton Iteration 3, Residual Norm: 2.540e-04\n  Newton Iteration 4, Residual Norm: 5.499e-05\n  Newton Iteration 5, Residual Norm: 5.089e-06\n  Newton Iteration 6, Residual Norm: 1.512e-06\n  Newton Iteration 7, Residual Norm: 2.416e-07\n  Newton Iteration 8, Residual Norm: 3.896e-08\n  Newton Iteration 9, Residual Norm: 9.983e-09\n   Iter 0: Res_d=9.87e-09, Res_u=9.98e-09\n--- Time Step 219 ---\n  Newton Iteration 1, Residual Norm: 8.428e-09\n  Newton Iteration 1, Residual Norm: 9.482e-09\n  Newton Iteration 1, Residual Norm: 1.079e+00\n  Newton Iteration 2, Residual Norm: 8.530e-03\n  Newton Iteration 3, Residual Norm: 2.654e-04\n  Newton Iteration 4, Residual Norm: 3.760e-05\n  Newton Iteration 5, Residual Norm: 6.823e-06\n  Newton Iteration 6, Residual Norm: 1.299e-06\n  Newton Iteration 7, Residual Norm: 2.240e-07\n  Newton Iteration 8, Residual Norm: 4.970e-08\n  Newton Iteration 9, Residual Norm: 9.987e-09\n   Iter 0: Res_d=9.48e-09, Res_u=9.99e-09\n--- Time Step 220 ---\n  Newton Iteration 1, Residual Norm: 8.449e-09\n  Newton Iteration 1, Residual Norm: 9.200e-09\n  Newton Iteration 1, Residual Norm: 1.082e+00\n  Newton Iteration 2, Residual Norm: 1.060e-02\n  Newton Iteration 3, Residual Norm: 2.667e-04\n  Newton Iteration 4, Residual Norm: 3.840e-05\n  Newton Iteration 5, Residual Norm: 6.635e-06\n  Newton Iteration 6, Residual Norm: 1.663e-06\n  Newton Iteration 7, Residual Norm: 1.894e-07\n  Newton Iteration 8, Residual Norm: 5.088e-08\n  Newton Iteration 9, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.20e-09, Res_u=1.00e-08\n--- Time Step 221 ---\n  Newton Iteration 1, Residual Norm: 8.399e-09\n  Newton Iteration 1, Residual Norm: 9.730e-09\n  Newton Iteration 1, Residual Norm: 1.087e+00\n  Newton Iteration 2, Residual Norm: 1.272e-02\n  Newton Iteration 3, Residual Norm: 2.560e-04\n  Newton Iteration 4, Residual Norm: 3.470e-05\n  Newton Iteration 5, Residual Norm: 9.944e-06\n  Newton Iteration 6, Residual Norm: 1.047e-06\n  Newton Iteration 7, Residual Norm: 2.587e-07\n  Newton Iteration 8, Residual Norm: 3.536e-08\n  Newton Iteration 9, Residual Norm: 9.996e-09\n   Iter 0: Res_d=9.73e-09, Res_u=1.00e-08\n--- Time Step 222 ---\n  Newton Iteration 1, Residual Norm: 8.443e-09\n  Newton Iteration 1, Residual Norm: 9.474e-09\n  Newton Iteration 1, Residual Norm: 1.092e+00\n  Newton Iteration 2, Residual Norm: 1.486e-02\n  Newton Iteration 3, Residual Norm: 2.401e-04\n  Newton Iteration 4, Residual Norm: 4.621e-05\n  Newton Iteration 5, Residual Norm: 6.113e-06\n  Newton Iteration 6, Residual Norm: 1.484e-06\n  Newton Iteration 7, Residual Norm: 3.074e-07\n  Newton Iteration 8, Residual Norm: 3.830e-08\n  Newton Iteration 9, Residual Norm: 9.949e-09\n   Iter 0: Res_d=9.47e-09, Res_u=9.95e-09\n--- Time Step 223 ---\n  Newton Iteration 1, Residual Norm: 8.416e-09\n  Newton Iteration 1, Residual Norm: 8.558e-09\n  Newton Iteration 1, Residual Norm: 1.095e+00\n  Newton Iteration 2, Residual Norm: 1.712e-02\n  Newton Iteration 3, Residual Norm: 2.415e-04\n  Newton Iteration 4, Residual Norm: 4.787e-05\n  Newton Iteration 5, Residual Norm: 9.419e-06\n  Newton Iteration 6, Residual Norm: 1.316e-06\n  Newton Iteration 7, Residual Norm: 2.998e-07\n  Newton Iteration 8, Residual Norm: 3.881e-08\n  Newton Iteration 9, Residual Norm: 9.972e-09\n   Iter 0: Res_d=8.56e-09, Res_u=9.97e-09\n--- Time Step 224 ---\n  Newton Iteration 1, Residual Norm: 8.382e-09\n  Newton Iteration 1, Residual Norm: 9.133e-09\n  Newton Iteration 1, Residual Norm: 1.099e+00\n  Newton Iteration 2, Residual Norm: 1.916e-02\n  Newton Iteration 3, Residual Norm: 2.482e-04\n  Newton Iteration 4, Residual Norm: 4.268e-05\n  Newton Iteration 5, Residual Norm: 7.017e-06\n  Newton Iteration 6, Residual Norm: 1.361e-06\n  Newton Iteration 7, Residual Norm: 2.738e-07\n  Newton Iteration 8, Residual Norm: 4.332e-08\n  Newton Iteration 9, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.13e-09, Res_u=9.98e-09\n--- Time Step 225 ---\n  Newton Iteration 1, Residual Norm: 8.395e-09\n  Newton Iteration 1, Residual Norm: 9.266e-09\n  Newton Iteration 1, Residual Norm: 1.104e+00\n  Newton Iteration 2, Residual Norm: 2.106e-02\n  Newton Iteration 3, Residual Norm: 2.731e-04\n  Newton Iteration 4, Residual Norm: 3.606e-05\n  Newton Iteration 5, Residual Norm: 8.121e-06\n  Newton Iteration 6, Residual Norm: 1.348e-06\n  Newton Iteration 7, Residual Norm: 2.754e-07\n  Newton Iteration 8, Residual Norm: 4.208e-08\n  Newton Iteration 9, Residual Norm: 9.994e-09\n   Iter 0: Res_d=9.27e-09, Res_u=9.99e-09\n--- Time Step 226 ---\n  Newton Iteration 1, Residual Norm: 8.359e-09\n  Newton Iteration 1, Residual Norm: 8.609e-09\n  Newton Iteration 1, Residual Norm: 1.109e+00\n  Newton Iteration 2, Residual Norm: 2.302e-02\n  Newton Iteration 3, Residual Norm: 2.502e-04\n  Newton Iteration 4, Residual Norm: 4.787e-05\n  Newton Iteration 5, Residual Norm: 6.316e-06\n  Newton Iteration 6, Residual Norm: 2.209e-06\n  Newton Iteration 7, Residual Norm: 1.789e-07\n  Newton Iteration 8, Residual Norm: 6.529e-08\n  Newton Iteration 9, Residual Norm: 9.972e-09\n   Iter 0: Res_d=8.61e-09, Res_u=9.97e-09\n--- Time Step 227 ---\n  Newton Iteration 1, Residual Norm: 8.362e-09\n  Newton Iteration 1, Residual Norm: 8.797e-09\n  Newton Iteration 1, Residual Norm: 1.114e+00\n  Newton Iteration 2, Residual Norm: 2.497e-02\n  Newton Iteration 3, Residual Norm: 2.749e-04\n  Newton Iteration 4, Residual Norm: 3.724e-05\n  Newton Iteration 5, Residual Norm: 9.096e-06\n  Newton Iteration 6, Residual Norm: 1.325e-06\n  Newton Iteration 7, Residual Norm: 3.017e-07\n  Newton Iteration 8, Residual Norm: 9.015e-08\n  Newton Iteration 9, Residual Norm: 9.987e-09\n   Iter 0: Res_d=8.80e-09, Res_u=9.99e-09\n--- Time Step 228 ---\n  Newton Iteration 1, Residual Norm: 8.382e-09\n  Newton Iteration 1, Residual Norm: 9.863e-09\n  Newton Iteration 1, Residual Norm: 1.119e+00\n  Newton Iteration 2, Residual Norm: 2.689e-02\n  Newton Iteration 3, Residual Norm: 2.599e-04\n  Newton Iteration 4, Residual Norm: 5.711e-05\n  Newton Iteration 5, Residual Norm: 6.021e-06\n  Newton Iteration 6, Residual Norm: 1.988e-06\n  Newton Iteration 7, Residual Norm: 1.876e-07\n  Newton Iteration 8, Residual Norm: 8.803e-08\n  Newton Iteration 9, Residual Norm: 9.981e-09\n   Iter 0: Res_d=9.86e-09, Res_u=9.98e-09\n--- Time Step 229 ---\n  Newton Iteration 1, Residual Norm: 8.403e-09\n  Newton Iteration 1, Residual Norm: 8.919e-09\n  Newton Iteration 1, Residual Norm: 1.125e+00\n  Newton Iteration 2, Residual Norm: 2.878e-02\n  Newton Iteration 3, Residual Norm: 2.569e-04\n  Newton Iteration 4, Residual Norm: 5.810e-05\n  Newton Iteration 5, Residual Norm: 5.861e-06\n  Newton Iteration 6, Residual Norm: 1.782e-06\n  Newton Iteration 7, Residual Norm: 2.084e-07\n  Newton Iteration 8, Residual Norm: 6.486e-08\n  Newton Iteration 9, Residual Norm: 9.947e-09\n   Iter 0: Res_d=8.92e-09, Res_u=9.95e-09\n--- Time Step 230 ---\n  Newton Iteration 1, Residual Norm: 8.332e-09\n  Newton Iteration 1, Residual Norm: 8.377e-09\n  Newton Iteration 1, Residual Norm: 1.130e+00\n  Newton Iteration 2, Residual Norm: 3.064e-02\n  Newton Iteration 3, Residual Norm: 2.597e-04\n  Newton Iteration 4, Residual Norm: 3.781e-05\n  Newton Iteration 5, Residual Norm: 1.017e-05\n  Newton Iteration 6, Residual Norm: 1.172e-06\n  Newton Iteration 7, Residual Norm: 2.986e-07\n  Newton Iteration 8, Residual Norm: 4.512e-08\n  Newton Iteration 9, Residual Norm: 9.998e-09\n   Iter 0: Res_d=8.38e-09, Res_u=1.00e-08\n--- Time Step 231 ---\n  Newton Iteration 1, Residual Norm: 8.360e-09\n  Newton Iteration 1, Residual Norm: 9.086e-09\n  Newton Iteration 1, Residual Norm: 1.136e+00\n  Newton Iteration 2, Residual Norm: 3.239e-02\n  Newton Iteration 3, Residual Norm: 2.792e-04\n  Newton Iteration 4, Residual Norm: 4.400e-05\n  Newton Iteration 5, Residual Norm: 7.286e-06\n  Newton Iteration 6, Residual Norm: 1.464e-06\n  Newton Iteration 7, Residual Norm: 2.671e-07\n  Newton Iteration 8, Residual Norm: 5.526e-08\n  Newton Iteration 9, Residual Norm: 9.964e-09\n   Iter 0: Res_d=9.09e-09, Res_u=9.96e-09\n--- Time Step 232 ---\n  Newton Iteration 1, Residual Norm: 8.347e-09\n  Newton Iteration 1, Residual Norm: 9.218e-09\n  Newton Iteration 1, Residual Norm: 1.141e+00\n  Newton Iteration 2, Residual Norm: 1.912e-03\n  Newton Iteration 3, Residual Norm: 2.574e-04\n  Newton Iteration 4, Residual Norm: 4.231e-05\n  Newton Iteration 5, Residual Norm: 7.585e-06\n  Newton Iteration 6, Residual Norm: 1.498e-06\n  Newton Iteration 7, Residual Norm: 3.486e-07\n  Newton Iteration 8, Residual Norm: 5.473e-08\n  Newton Iteration 9, Residual Norm: 9.952e-09\n   Iter 0: Res_d=9.22e-09, Res_u=9.95e-09\n--- Time Step 233 ---\n  Newton Iteration 1, Residual Norm: 8.350e-09\n  Newton Iteration 1, Residual Norm: 9.228e-09\n  Newton Iteration 1, Residual Norm: 1.147e+00\n  Newton Iteration 2, Residual Norm: 1.932e-03\n  Newton Iteration 3, Residual Norm: 2.622e-04\n  Newton Iteration 4, Residual Norm: 4.127e-05\n  Newton Iteration 5, Residual Norm: 7.836e-06\n  Newton Iteration 6, Residual Norm: 2.272e-06\n  Newton Iteration 7, Residual Norm: 2.528e-07\n  Newton Iteration 8, Residual Norm: 7.740e-08\n  Newton Iteration 9, Residual Norm: 9.939e-09\n   Iter 0: Res_d=9.23e-09, Res_u=9.94e-09\n--- Time Step 234 ---\n  Newton Iteration 1, Residual Norm: 8.320e-09\n  Newton Iteration 1, Residual Norm: 9.899e-09\n  Newton Iteration 1, Residual Norm: 1.153e+00\n  Newton Iteration 2, Residual Norm: 1.939e-03\n  Newton Iteration 3, Residual Norm: 2.876e-04\n  Newton Iteration 4, Residual Norm: 4.147e-05\n  Newton Iteration 5, Residual Norm: 1.423e-05\n  Newton Iteration 6, Residual Norm: 1.219e-06\n  Newton Iteration 7, Residual Norm: 3.785e-07\n  Newton Iteration 8, Residual Norm: 6.517e-08\n  Newton Iteration 9, Residual Norm: 9.931e-09\n   Iter 0: Res_d=9.90e-09, Res_u=9.93e-09\n--- Time Step 235 ---\n  Newton Iteration 1, Residual Norm: 8.273e-09\n  Newton Iteration 1, Residual Norm: 8.599e-09\n  Newton Iteration 1, Residual Norm: 1.159e+00\n  Newton Iteration 2, Residual Norm: 1.963e-03\n  Newton Iteration 3, Residual Norm: 3.163e-04\n  Newton Iteration 4, Residual Norm: 3.758e-05\n  Newton Iteration 5, Residual Norm: 9.602e-06\n  Newton Iteration 6, Residual Norm: 1.526e-06\n  Newton Iteration 7, Residual Norm: 3.226e-07\n  Newton Iteration 8, Residual Norm: 5.411e-08\n  Newton Iteration 9, Residual Norm: 9.999e-09\n   Iter 0: Res_d=8.60e-09, Res_u=1.00e-08\n--- Time Step 236 ---\n  Newton Iteration 1, Residual Norm: 8.234e-09\n  Newton Iteration 1, Residual Norm: 9.278e-09\n  Newton Iteration 1, Residual Norm: 1.163e+00\n  Newton Iteration 2, Residual Norm: 1.988e-03\n  Newton Iteration 3, Residual Norm: 2.984e-04\n  Newton Iteration 4, Residual Norm: 4.210e-05\n  Newton Iteration 5, Residual Norm: 1.286e-05\n  Newton Iteration 6, Residual Norm: 1.253e-06\n  Newton Iteration 7, Residual Norm: 5.157e-07\n  Newton Iteration 8, Residual Norm: 4.733e-08\n  Newton Iteration 9, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.28e-09, Res_u=9.99e-09\n--- Time Step 237 ---\n  Newton Iteration 1, Residual Norm: 8.292e-09\n  Newton Iteration 1, Residual Norm: 8.909e-09\n  Newton Iteration 1, Residual Norm: 1.167e+00\n  Newton Iteration 2, Residual Norm: 2.016e-03\n  Newton Iteration 3, Residual Norm: 3.059e-04\n  Newton Iteration 4, Residual Norm: 4.228e-05\n  Newton Iteration 5, Residual Norm: 9.895e-06\n  Newton Iteration 6, Residual Norm: 1.563e-06\n  Newton Iteration 7, Residual Norm: 3.987e-07\n  Newton Iteration 8, Residual Norm: 5.423e-08\n  Newton Iteration 9, Residual Norm: 9.992e-09\n   Iter 0: Res_d=8.91e-09, Res_u=9.99e-09\n--- Time Step 238 ---\n  Newton Iteration 1, Residual Norm: 8.235e-09\n  Newton Iteration 1, Residual Norm: 7.853e-09\n  Newton Iteration 1, Residual Norm: 1.169e+00\n  Newton Iteration 2, Residual Norm: 2.036e-03\n  Newton Iteration 3, Residual Norm: 3.091e-04\n  Newton Iteration 4, Residual Norm: 4.296e-05\n  Newton Iteration 5, Residual Norm: 1.518e-05\n  Newton Iteration 6, Residual Norm: 1.210e-06\n  Newton Iteration 7, Residual Norm: 4.730e-07\n  Newton Iteration 8, Residual Norm: 4.872e-08\n  Newton Iteration 9, Residual Norm: 9.990e-09\n   Iter 0: Res_d=7.85e-09, Res_u=9.99e-09\n--- Time Step 239 ---\n  Newton Iteration 1, Residual Norm: 8.256e-09\n  Newton Iteration 1, Residual Norm: 9.960e-09\n  Newton Iteration 1, Residual Norm: 1.170e+00\n  Newton Iteration 2, Residual Norm: 2.046e-03\n  Newton Iteration 3, Residual Norm: 3.109e-04\n  Newton Iteration 4, Residual Norm: 5.890e-05\n  Newton Iteration 5, Residual Norm: 7.854e-06\n  Newton Iteration 6, Residual Norm: 1.949e-06\n  Newton Iteration 7, Residual Norm: 3.088e-07\n  Newton Iteration 8, Residual Norm: 7.861e-08\n  Newton Iteration 9, Residual Norm: 9.992e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.99e-09\n--- Time Step 240 ---\n  Newton Iteration 1, Residual Norm: 8.238e-09\n  Newton Iteration 1, Residual Norm: 9.955e-09\n  Newton Iteration 1, Residual Norm: 1.170e+00\n  Newton Iteration 2, Residual Norm: 2.058e-03\n  Newton Iteration 3, Residual Norm: 3.145e-04\n  Newton Iteration 4, Residual Norm: 4.322e-05\n  Newton Iteration 5, Residual Norm: 1.027e-05\n  Newton Iteration 6, Residual Norm: 1.807e-06\n  Newton Iteration 7, Residual Norm: 3.475e-07\n  Newton Iteration 8, Residual Norm: 9.783e-08\n  Newton Iteration 9, Residual Norm: 9.928e-09\n   Iter 0: Res_d=9.95e-09, Res_u=9.93e-09\n--- Time Step 241 ---\n  Newton Iteration 1, Residual Norm: 8.168e-09\n  Newton Iteration 1, Residual Norm: 9.223e-09\n  Newton Iteration 1, Residual Norm: 1.172e+00\n  Newton Iteration 2, Residual Norm: 2.075e-03\n  Newton Iteration 3, Residual Norm: 3.453e-04\n  Newton Iteration 4, Residual Norm: 3.908e-05\n  Newton Iteration 5, Residual Norm: 1.054e-05\n  Newton Iteration 6, Residual Norm: 1.486e-06\n  Newton Iteration 7, Residual Norm: 7.702e-07\n  Newton Iteration 8, Residual Norm: 4.383e-08\n  Newton Iteration 9, Residual Norm: 9.975e-09\n   Iter 0: Res_d=9.22e-09, Res_u=9.98e-09\n--- Time Step 242 ---\n  Newton Iteration 1, Residual Norm: 8.269e-09\n  Newton Iteration 1, Residual Norm: 9.484e-09\n  Newton Iteration 1, Residual Norm: 1.172e+00\n  Newton Iteration 2, Residual Norm: 2.120e-03\n  Newton Iteration 3, Residual Norm: 3.130e-04\n  Newton Iteration 4, Residual Norm: 4.462e-05\n  Newton Iteration 5, Residual Norm: 1.021e-05\n  Newton Iteration 6, Residual Norm: 1.674e-06\n  Newton Iteration 7, Residual Norm: 3.469e-07\n  Newton Iteration 8, Residual Norm: 1.041e-07\n  Newton Iteration 9, Residual Norm: 9.954e-09\n   Iter 0: Res_d=9.48e-09, Res_u=9.95e-09\n--- Time Step 243 ---\n  Newton Iteration 1, Residual Norm: 8.241e-09\n  Newton Iteration 1, Residual Norm: 8.864e-09\n  Newton Iteration 1, Residual Norm: 1.170e+00\n  Newton Iteration 2, Residual Norm: 2.236e-03\n  Newton Iteration 3, Residual Norm: 2.923e-04\n  Newton Iteration 4, Residual Norm: 4.872e-05\n  Newton Iteration 5, Residual Norm: 1.427e-05\n  Newton Iteration 6, Residual Norm: 1.751e-06\n  Newton Iteration 7, Residual Norm: 4.206e-07\n  Newton Iteration 8, Residual Norm: 1.029e-07\n  Newton Iteration 9, Residual Norm: 9.996e-09\n   Iter 0: Res_d=8.86e-09, Res_u=1.00e-08\n--- Time Step 244 ---\n  Newton Iteration 1, Residual Norm: 8.160e-09\n  Newton Iteration 1, Residual Norm: 9.510e-09\n  Newton Iteration 1, Residual Norm: 1.168e+00\n  Newton Iteration 2, Residual Norm: 2.158e-03\n  Newton Iteration 3, Residual Norm: 3.171e-04\n  Newton Iteration 4, Residual Norm: 4.498e-05\n  Newton Iteration 5, Residual Norm: 1.034e-05\n  Newton Iteration 6, Residual Norm: 3.002e-06\n  Newton Iteration 7, Residual Norm: 3.105e-07\n  Newton Iteration 8, Residual Norm: 6.774e-08\n  Newton Iteration 9, Residual Norm: 9.989e-09\n   Iter 0: Res_d=9.51e-09, Res_u=9.99e-09\n--- Time Step 245 ---\n  Newton Iteration 1, Residual Norm: 8.210e-09\n  Newton Iteration 1, Residual Norm: 9.248e-09\n  Newton Iteration 1, Residual Norm: 1.165e+00\n  Newton Iteration 2, Residual Norm: 2.301e-03\n  Newton Iteration 3, Residual Norm: 3.095e-04\n  Newton Iteration 4, Residual Norm: 6.200e-05\n  Newton Iteration 5, Residual Norm: 7.789e-06\n  Newton Iteration 6, Residual Norm: 3.117e-06\n  Newton Iteration 7, Residual Norm: 2.458e-07\n  Newton Iteration 8, Residual Norm: 1.587e-07\n  Newton Iteration 9, Residual Norm: 9.962e-09\n   Iter 0: Res_d=9.25e-09, Res_u=9.96e-09\n--- Time Step 246 ---\n  Newton Iteration 1, Residual Norm: 8.245e-09\n  Newton Iteration 1, Residual Norm: 9.827e-09\n  Newton Iteration 1, Residual Norm: 1.162e+00\n  Newton Iteration 2, Residual Norm: 2.387e-03\n  Newton Iteration 3, Residual Norm: 3.117e-04\n  Newton Iteration 4, Residual Norm: 5.874e-05\n  Newton Iteration 5, Residual Norm: 1.151e-05\n  Newton Iteration 6, Residual Norm: 1.589e-06\n  Newton Iteration 7, Residual Norm: 5.906e-07\n  Newton Iteration 8, Residual Norm: 5.782e-08\n  Newton Iteration 9, Residual Norm: 9.965e-09\n   Iter 0: Res_d=9.83e-09, Res_u=9.97e-09\n--- Time Step 247 ---\n  Newton Iteration 1, Residual Norm: 8.238e-09\n  Newton Iteration 1, Residual Norm: 8.435e-09\n  Newton Iteration 1, Residual Norm: 1.158e+00\n  Newton Iteration 2, Residual Norm: 2.148e-03\n  Newton Iteration 3, Residual Norm: 3.462e-04\n  Newton Iteration 4, Residual Norm: 4.242e-05\n  Newton Iteration 5, Residual Norm: 1.543e-05\n  Newton Iteration 6, Residual Norm: 1.278e-06\n  Newton Iteration 7, Residual Norm: 5.014e-07\n  Newton Iteration 8, Residual Norm: 5.254e-08\n  Newton Iteration 9, Residual Norm: 9.985e-09\n   Iter 0: Res_d=8.43e-09, Res_u=9.99e-09\n--- Time Step 248 ---\n  Newton Iteration 1, Residual Norm: 8.155e-09\n  Newton Iteration 1, Residual Norm: 8.544e-09\n  Newton Iteration 1, Residual Norm: 1.154e+00\n  Newton Iteration 2, Residual Norm: 2.154e-03\n  Newton Iteration 3, Residual Norm: 3.453e-04\n  Newton Iteration 4, Residual Norm: 4.397e-05\n  Newton Iteration 5, Residual Norm: 1.543e-05\n  Newton Iteration 6, Residual Norm: 1.295e-06\n  Newton Iteration 7, Residual Norm: 4.652e-07\n  Newton Iteration 8, Residual Norm: 5.709e-08\n  Newton Iteration 9, Residual Norm: 9.995e-09\n   Iter 0: Res_d=8.54e-09, Res_u=1.00e-08\n--- Time Step 249 ---\n  Newton Iteration 1, Residual Norm: 8.147e-09\n  Newton Iteration 1, Residual Norm: 8.837e-09\n  Newton Iteration 1, Residual Norm: 1.154e+00\n  Newton Iteration 2, Residual Norm: 2.157e-03\n  Newton Iteration 3, Residual Norm: 3.227e-04\n  Newton Iteration 4, Residual Norm: 6.077e-05\n  Newton Iteration 5, Residual Norm: 8.185e-06\n  Newton Iteration 6, Residual Norm: 2.049e-06\n  Newton Iteration 7, Residual Norm: 3.357e-07\n  Newton Iteration 8, Residual Norm: 8.494e-08\n  Newton Iteration 9, Residual Norm: 9.987e-09\n   Iter 0: Res_d=8.84e-09, Res_u=9.99e-09\n--- Time Step 250 ---\n  Newton Iteration 1, Residual Norm: 8.191e-09\n  Newton Iteration 1, Residual Norm: 9.508e-09\n  Newton Iteration 1, Residual Norm: 1.153e+00\n  Newton Iteration 2, Residual Norm: 2.148e-03\n  Newton Iteration 3, Residual Norm: 3.216e-04\n  Newton Iteration 4, Residual Norm: 6.006e-05\n  Newton Iteration 5, Residual Norm: 8.308e-06\n  Newton Iteration 6, Residual Norm: 2.093e-06\n  Newton Iteration 7, Residual Norm: 3.362e-07\n  Newton Iteration 8, Residual Norm: 9.096e-08\n  Newton Iteration 9, Residual Norm: 9.990e-09\n   Iter 0: Res_d=9.51e-09, Res_u=9.99e-09\n--- Time Step 251 ---\n  Newton Iteration 1, Residual Norm: 8.181e-09\n  Newton Iteration 1, Residual Norm: 8.835e-09\n  Newton Iteration 1, Residual Norm: 1.152e+00\n  Newton Iteration 2, Residual Norm: 2.177e-03\n  Newton Iteration 3, Residual Norm: 3.227e-04\n  Newton Iteration 4, Residual Norm: 5.325e-05\n  Newton Iteration 5, Residual Norm: 9.661e-06\n  Newton Iteration 6, Residual Norm: 1.674e-06\n  Newton Iteration 7, Residual Norm: 3.973e-07\n  Newton Iteration 8, Residual Norm: 1.351e-07\n  Newton Iteration 9, Residual Norm: 1.225e-08\n  Newton Iteration 10, Residual Norm: 9.899e-09\n   Iter 0: Res_d=8.83e-09, Res_u=9.90e-09\n--- Time Step 252 ---\n  Newton Iteration 1, Residual Norm: 8.165e-09\n  Newton Iteration 1, Residual Norm: 9.678e-09\n  Newton Iteration 1, Residual Norm: 1.152e+00\n  Newton Iteration 2, Residual Norm: 2.198e-03\n  Newton Iteration 3, Residual Norm: 3.223e-04\n  Newton Iteration 4, Residual Norm: 4.277e-05\n  Newton Iteration 5, Residual Norm: 1.080e-05\n  Newton Iteration 6, Residual Norm: 2.990e-06\n  Newton Iteration 7, Residual Norm: 2.901e-07\n  Newton Iteration 8, Residual Norm: 1.033e-07\n  Newton Iteration 9, Residual Norm: 1.348e-08\n  Newton Iteration 10, Residual Norm: 9.914e-09\n   Iter 0: Res_d=9.68e-09, Res_u=9.91e-09\n--- Time Step 253 ---\n  Newton Iteration 1, Residual Norm: 8.108e-09\n  Newton Iteration 1, Residual Norm: 8.318e-09\n  Newton Iteration 1, Residual Norm: 1.153e+00\n  Newton Iteration 2, Residual Norm: 2.234e-03\n  Newton Iteration 3, Residual Norm: 3.198e-04\n  Newton Iteration 4, Residual Norm: 4.407e-05\n  Newton Iteration 5, Residual Norm: 1.072e-05\n  Newton Iteration 6, Residual Norm: 3.270e-06\n  Newton Iteration 7, Residual Norm: 2.630e-07\n  Newton Iteration 8, Residual Norm: 1.195e-07\n  Newton Iteration 9, Residual Norm: 1.149e-08\n  Newton Iteration 10, Residual Norm: 9.957e-09\n   Iter 0: Res_d=8.32e-09, Res_u=9.96e-09\n--- Time Step 254 ---\n  Newton Iteration 1, Residual Norm: 8.111e-09\n  Newton Iteration 1, Residual Norm: 8.737e-09\n  Newton Iteration 1, Residual Norm: 1.151e+00\n  Newton Iteration 2, Residual Norm: 2.241e-03\n  Newton Iteration 3, Residual Norm: 3.289e-04\n  Newton Iteration 4, Residual Norm: 4.424e-05\n  Newton Iteration 5, Residual Norm: 1.074e-05\n  Newton Iteration 6, Residual Norm: 1.761e-06\n  Newton Iteration 7, Residual Norm: 4.768e-07\n  Newton Iteration 8, Residual Norm: 6.718e-08\n  Newton Iteration 9, Residual Norm: 2.212e-08\n  Newton Iteration 10, Residual Norm: 9.950e-09\n   Iter 0: Res_d=8.74e-09, Res_u=9.95e-09\n--- Time Step 255 ---\n  Newton Iteration 1, Residual Norm: 8.157e-09\n  Newton Iteration 1, Residual Norm: 9.567e-09\n  Newton Iteration 1, Residual Norm: 1.149e+00\n  Newton Iteration 2, Residual Norm: 2.303e-03\n  Newton Iteration 3, Residual Norm: 3.017e-04\n  Newton Iteration 4, Residual Norm: 5.556e-05\n  Newton Iteration 5, Residual Norm: 8.521e-06\n  Newton Iteration 6, Residual Norm: 2.687e-06\n  Newton Iteration 7, Residual Norm: 3.317e-07\n  Newton Iteration 8, Residual Norm: 1.110e-07\n  Newton Iteration 9, Residual Norm: 1.321e-08\n  Newton Iteration 10, Residual Norm: 9.986e-09\n   Iter 0: Res_d=9.57e-09, Res_u=9.99e-09\n--- Time Step 256 ---\n  Newton Iteration 1, Residual Norm: 8.165e-09\n  Newton Iteration 1, Residual Norm: 9.942e-09\n  Newton Iteration 1, Residual Norm: 1.146e+00\n  Newton Iteration 2, Residual Norm: 2.285e-03\n  Newton Iteration 3, Residual Norm: 3.204e-04\n  Newton Iteration 4, Residual Norm: 4.890e-05\n  Newton Iteration 5, Residual Norm: 9.435e-06\n  Newton Iteration 6, Residual Norm: 2.416e-06\n  Newton Iteration 7, Residual Norm: 4.528e-07\n  Newton Iteration 8, Residual Norm: 7.120e-08\n  Newton Iteration 9, Residual Norm: 2.140e-08\n  Newton Iteration 10, Residual Norm: 9.958e-09\n   Iter 0: Res_d=9.94e-09, Res_u=9.96e-09\n--- Time Step 257 ---\n  Newton Iteration 1, Residual Norm: 8.121e-09\n  Newton Iteration 1, Residual Norm: 9.961e-09\n  Newton Iteration 1, Residual Norm: 1.144e+00\n  Newton Iteration 2, Residual Norm: 2.303e-03\n  Newton Iteration 3, Residual Norm: 3.212e-04\n  Newton Iteration 4, Residual Norm: 4.163e-05\n  Newton Iteration 5, Residual Norm: 1.162e-05\n  Newton Iteration 6, Residual Norm: 1.596e-06\n  Newton Iteration 7, Residual Norm: 4.182e-07\n  Newton Iteration 8, Residual Norm: 1.029e-07\n  Newton Iteration 9, Residual Norm: 1.771e-08\n  Newton Iteration 10, Residual Norm: 9.980e-09\n   Iter 0: Res_d=9.96e-09, Res_u=9.98e-09\n--- Time Step 258 ---\n  Newton Iteration 1, Residual Norm: 8.101e-09\n  Newton Iteration 1, Residual Norm: 8.715e-09\n  Newton Iteration 1, Residual Norm: 1.141e+00\n  Newton Iteration 2, Residual Norm: 2.359e-03\n  Newton Iteration 3, Residual Norm: 3.114e-04\n  Newton Iteration 4, Residual Norm: 5.170e-05\n  Newton Iteration 5, Residual Norm: 9.914e-06\n  Newton Iteration 6, Residual Norm: 3.440e-06\n  Newton Iteration 7, Residual Norm: 2.648e-07\n  Newton Iteration 8, Residual Norm: 1.501e-07\n  Newton Iteration 9, Residual Norm: 1.118e-08\n  Newton Iteration 10, Residual Norm: 9.969e-09\n   Iter 0: Res_d=8.71e-09, Res_u=9.97e-09\n--- Time Step 259 ---\n  Newton Iteration 1, Residual Norm: 8.145e-09\n  Newton Iteration 1, Residual Norm: 9.790e-09\n  Newton Iteration 1, Residual Norm: 1.139e+00\n  Newton Iteration 2, Residual Norm: 2.357e-03\n  Newton Iteration 3, Residual Norm: 3.433e-04\n  Newton Iteration 4, Residual Norm: 4.208e-05\n  Newton Iteration 5, Residual Norm: 1.165e-05\n  Newton Iteration 6, Residual Norm: 1.683e-06\n  Newton Iteration 7, Residual Norm: 5.092e-07\n  Newton Iteration 8, Residual Norm: 7.335e-08\n  Newton Iteration 9, Residual Norm: 2.513e-08\n  Newton Iteration 10, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.79e-09, Res_u=1.00e-08\n--- Time Step 260 ---\n  Newton Iteration 1, Residual Norm: 8.034e-09\n  Newton Iteration 1, Residual Norm: 9.712e-09\n  Newton Iteration 1, Residual Norm: 1.137e+00\n  Newton Iteration 2, Residual Norm: 2.347e-03\n  Newton Iteration 3, Residual Norm: 3.412e-04\n  Newton Iteration 4, Residual Norm: 3.717e-05\n  Newton Iteration 5, Residual Norm: 9.707e-06\n  Newton Iteration 6, Residual Norm: 1.971e-06\n  Newton Iteration 7, Residual Norm: 3.715e-07\n  Newton Iteration 8, Residual Norm: 1.206e-07\n  Newton Iteration 9, Residual Norm: 1.649e-08\n  Newton Iteration 10, Residual Norm: 9.951e-09\n   Iter 0: Res_d=9.71e-09, Res_u=9.95e-09\n--- Time Step 261 ---\n  Newton Iteration 1, Residual Norm: 8.010e-09\n  Newton Iteration 1, Residual Norm: 8.879e-09\n  Newton Iteration 1, Residual Norm: 1.134e+00\n  Newton Iteration 2, Residual Norm: 2.397e-03\n  Newton Iteration 3, Residual Norm: 2.889e-04\n  Newton Iteration 4, Residual Norm: 4.388e-05\n  Newton Iteration 5, Residual Norm: 1.430e-05\n  Newton Iteration 6, Residual Norm: 1.445e-06\n  Newton Iteration 7, Residual Norm: 7.922e-07\n  Newton Iteration 8, Residual Norm: 6.048e-08\n  Newton Iteration 9, Residual Norm: 3.139e-08\n  Newton Iteration 10, Residual Norm: 9.953e-09\n   Iter 0: Res_d=8.88e-09, Res_u=9.95e-09\n--- Time Step 262 ---\n  Newton Iteration 1, Residual Norm: 8.101e-09\n  Newton Iteration 1, Residual Norm: 9.791e-09\n  Newton Iteration 1, Residual Norm: 1.131e+00\n  Newton Iteration 2, Residual Norm: 2.389e-03\n  Newton Iteration 3, Residual Norm: 3.372e-04\n  Newton Iteration 4, Residual Norm: 4.118e-05\n  Newton Iteration 5, Residual Norm: 1.242e-05\n  Newton Iteration 6, Residual Norm: 1.644e-06\n  Newton Iteration 7, Residual Norm: 5.298e-07\n  Newton Iteration 8, Residual Norm: 7.838e-08\n  Newton Iteration 9, Residual Norm: 2.417e-08\n  Newton Iteration 10, Residual Norm: 9.947e-09\n   Iter 0: Res_d=9.79e-09, Res_u=9.95e-09\n--- Time Step 263 ---\n  Newton Iteration 1, Residual Norm: 8.019e-09\n  Newton Iteration 1, Residual Norm: 8.788e-09\n  Newton Iteration 1, Residual Norm: 1.128e+00\n  Newton Iteration 2, Residual Norm: 2.406e-03\n  Newton Iteration 3, Residual Norm: 3.072e-04\n  Newton Iteration 4, Residual Norm: 4.111e-05\n  Newton Iteration 5, Residual Norm: 1.133e-05\n  Newton Iteration 6, Residual Norm: 1.667e-06\n  Newton Iteration 7, Residual Norm: 5.058e-07\n  Newton Iteration 8, Residual Norm: 7.987e-08\n  Newton Iteration 9, Residual Norm: 2.404e-08\n  Newton Iteration 10, Residual Norm: 9.937e-09\n   Iter 0: Res_d=8.79e-09, Res_u=9.94e-09\n--- Time Step 264 ---\n  Newton Iteration 1, Residual Norm: 8.047e-09\n  Newton Iteration 1, Residual Norm: 9.644e-09\n  Newton Iteration 1, Residual Norm: 1.125e+00\n  Newton Iteration 2, Residual Norm: 2.414e-03\n  Newton Iteration 3, Residual Norm: 3.066e-04\n  Newton Iteration 4, Residual Norm: 4.056e-05\n  Newton Iteration 5, Residual Norm: 1.296e-05\n  Newton Iteration 6, Residual Norm: 1.456e-06\n  Newton Iteration 7, Residual Norm: 7.242e-07\n  Newton Iteration 8, Residual Norm: 6.390e-08\n  Newton Iteration 9, Residual Norm: 3.198e-08\n  Newton Iteration 10, Residual Norm: 9.921e-09\n   Iter 0: Res_d=9.64e-09, Res_u=9.92e-09\n--- Time Step 265 ---\n  Newton Iteration 1, Residual Norm: 8.002e-09\n  Newton Iteration 1, Residual Norm: 9.829e-09\n  Newton Iteration 1, Residual Norm: 1.122e+00\n  Newton Iteration 2, Residual Norm: 2.465e-03\n  Newton Iteration 3, Residual Norm: 3.046e-04\n  Newton Iteration 4, Residual Norm: 4.028e-05\n  Newton Iteration 5, Residual Norm: 1.105e-05\n  Newton Iteration 6, Residual Norm: 1.833e-06\n  Newton Iteration 7, Residual Norm: 4.865e-07\n  Newton Iteration 8, Residual Norm: 8.646e-08\n  Newton Iteration 9, Residual Norm: 4.889e-08\n  Newton Iteration 10, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.83e-09, Res_u=1.00e-08\n--- Time Step 266 ---\n  Newton Iteration 1, Residual Norm: 8.046e-09\n  Newton Iteration 1, Residual Norm: 9.774e-09\n  Newton Iteration 1, Residual Norm: 1.119e+00\n  Newton Iteration 2, Residual Norm: 2.442e-03\n  Newton Iteration 3, Residual Norm: 3.093e-04\n  Newton Iteration 4, Residual Norm: 3.921e-05\n  Newton Iteration 5, Residual Norm: 1.147e-05\n  Newton Iteration 6, Residual Norm: 1.672e-06\n  Newton Iteration 7, Residual Norm: 5.248e-07\n  Newton Iteration 8, Residual Norm: 8.260e-08\n  Newton Iteration 9, Residual Norm: 2.589e-08\n  Newton Iteration 10, Residual Norm: 9.967e-09\n   Iter 0: Res_d=9.77e-09, Res_u=9.97e-09\n--- Time Step 267 ---\n  Newton Iteration 1, Residual Norm: 8.041e-09\n  Newton Iteration 1, Residual Norm: 9.384e-09\n  Newton Iteration 1, Residual Norm: 1.117e+00\n  Newton Iteration 2, Residual Norm: 2.464e-03\n  Newton Iteration 3, Residual Norm: 3.054e-04\n  Newton Iteration 4, Residual Norm: 5.465e-05\n  Newton Iteration 5, Residual Norm: 9.853e-06\n  Newton Iteration 6, Residual Norm: 2.302e-06\n  Newton Iteration 7, Residual Norm: 4.385e-07\n  Newton Iteration 8, Residual Norm: 1.081e-07\n  Newton Iteration 9, Residual Norm: 2.173e-08\n  Newton Iteration 10, Residual Norm: 9.985e-09\n   Iter 0: Res_d=9.38e-09, Res_u=9.99e-09\n--- Time Step 268 ---\n  Newton Iteration 1, Residual Norm: 8.001e-09\n  Newton Iteration 1, Residual Norm: 8.302e-09\n  Newton Iteration 1, Residual Norm: 1.115e+00\n  Newton Iteration 2, Residual Norm: 2.476e-03\n  Newton Iteration 3, Residual Norm: 3.263e-04\n  Newton Iteration 4, Residual Norm: 3.855e-05\n  Newton Iteration 5, Residual Norm: 1.615e-05\n  Newton Iteration 6, Residual Norm: 1.464e-06\n  Newton Iteration 7, Residual Norm: 7.020e-07\n  Newton Iteration 8, Residual Norm: 6.952e-08\n  Newton Iteration 9, Residual Norm: 7.003e-08\n  Newton Iteration 10, Residual Norm: 9.876e-09\n   Iter 0: Res_d=8.30e-09, Res_u=9.88e-09\n--- Time Step 269 ---\n  Newton Iteration 1, Residual Norm: 8.055e-09\n  Newton Iteration 1, Residual Norm: 9.467e-09\n  Newton Iteration 1, Residual Norm: 1.114e+00\n  Newton Iteration 2, Residual Norm: 2.494e-03\n  Newton Iteration 3, Residual Norm: 3.080e-04\n  Newton Iteration 4, Residual Norm: 3.472e-05\n  Newton Iteration 5, Residual Norm: 2.041e-05\n  Newton Iteration 6, Residual Norm: 1.093e-06\n  Newton Iteration 7, Residual Norm: 9.734e-07\n  Newton Iteration 8, Residual Norm: 4.996e-08\n  Newton Iteration 9, Residual Norm: 3.320e-08\n  Newton Iteration 10, Residual Norm: 9.924e-09\n   Iter 0: Res_d=9.47e-09, Res_u=9.92e-09\n--- Time Step 270 ---\n  Newton Iteration 1, Residual Norm: 8.015e-09\n  Newton Iteration 1, Residual Norm: 9.674e-09\n  Newton Iteration 1, Residual Norm: 1.113e+00\n  Newton Iteration 2, Residual Norm: 2.499e-03\n  Newton Iteration 3, Residual Norm: 3.020e-04\n  Newton Iteration 4, Residual Norm: 3.812e-05\n  Newton Iteration 5, Residual Norm: 1.168e-05\n  Newton Iteration 6, Residual Norm: 1.555e-06\n  Newton Iteration 7, Residual Norm: 5.516e-07\n  Newton Iteration 8, Residual Norm: 9.705e-08\n  Newton Iteration 9, Residual Norm: 4.181e-08\n  Newton Iteration 10, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.67e-09, Res_u=1.00e-08\n--- Time Step 271 ---\n  Newton Iteration 1, Residual Norm: 7.988e-09\n  Newton Iteration 1, Residual Norm: 9.702e-09\n  Newton Iteration 1, Residual Norm: 1.113e+00\n  Newton Iteration 2, Residual Norm: 2.546e-03\n  Newton Iteration 3, Residual Norm: 3.303e-04\n  Newton Iteration 4, Residual Norm: 3.803e-05\n  Newton Iteration 5, Residual Norm: 1.258e-05\n  Newton Iteration 6, Residual Norm: 1.644e-06\n  Newton Iteration 7, Residual Norm: 5.942e-07\n  Newton Iteration 8, Residual Norm: 8.057e-08\n  Newton Iteration 9, Residual Norm: 2.764e-08\n  Newton Iteration 10, Residual Norm: 9.998e-09\n   Iter 0: Res_d=9.70e-09, Res_u=1.00e-08\n--- Time Step 272 ---\n  Newton Iteration 1, Residual Norm: 7.967e-09\n  Newton Iteration 1, Residual Norm: 9.399e-09\n  Newton Iteration 1, Residual Norm: 1.111e+00\n  Newton Iteration 2, Residual Norm: 2.546e-03\n  Newton Iteration 3, Residual Norm: 3.036e-04\n  Newton Iteration 4, Residual Norm: 3.749e-05\n  Newton Iteration 5, Residual Norm: 1.187e-05\n  Newton Iteration 6, Residual Norm: 1.672e-06\n  Newton Iteration 7, Residual Norm: 1.078e-06\n  Newton Iteration 8, Residual Norm: 5.580e-08\n  Newton Iteration 9, Residual Norm: 4.517e-08\n  Newton Iteration 10, Residual Norm: 9.997e-09\n   Iter 0: Res_d=9.40e-09, Res_u=1.00e-08\n--- Time Step 273 ---\n  Newton Iteration 1, Residual Norm: 8.004e-09\n  Newton Iteration 1, Residual Norm: 9.483e-09\n  Newton Iteration 1, Residual Norm: 1.110e+00\n  Newton Iteration 2, Residual Norm: 2.552e-03\n  Newton Iteration 3, Residual Norm: 3.064e-04\n  Newton Iteration 4, Residual Norm: 3.722e-05\n  Newton Iteration 5, Residual Norm: 1.198e-05\n  Newton Iteration 6, Residual Norm: 1.659e-06\n  Newton Iteration 7, Residual Norm: 5.798e-07\n  Newton Iteration 8, Residual Norm: 8.334e-08\n  Newton Iteration 9, Residual Norm: 2.911e-08\n  Newton Iteration 10, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.48e-09, Res_u=9.98e-09\n--- Time Step 274 ---\n  Newton Iteration 1, Residual Norm: 7.961e-09\n  Newton Iteration 1, Residual Norm: 9.603e-09\n  Newton Iteration 1, Residual Norm: 1.108e+00\n  Newton Iteration 2, Residual Norm: 2.615e-03\n  Newton Iteration 3, Residual Norm: 3.019e-04\n  Newton Iteration 4, Residual Norm: 5.623e-05\n  Newton Iteration 5, Residual Norm: 9.181e-06\n  Newton Iteration 6, Residual Norm: 2.094e-06\n  Newton Iteration 7, Residual Norm: 4.433e-07\n  Newton Iteration 8, Residual Norm: 1.145e-07\n  Newton Iteration 9, Residual Norm: 2.015e-08\n  Newton Iteration 10, Residual Norm: 9.964e-09\n   Iter 0: Res_d=9.60e-09, Res_u=9.96e-09\n--- Time Step 275 ---\n  Newton Iteration 1, Residual Norm: 8.000e-09\n  Newton Iteration 1, Residual Norm: 9.737e-09\n  Newton Iteration 1, Residual Norm: 1.107e+00\n  Newton Iteration 2, Residual Norm: 2.609e-03\n  Newton Iteration 3, Residual Norm: 3.087e-04\n  Newton Iteration 4, Residual Norm: 3.726e-05\n  Newton Iteration 5, Residual Norm: 1.200e-05\n  Newton Iteration 6, Residual Norm: 1.745e-06\n  Newton Iteration 7, Residual Norm: 5.673e-07\n  Newton Iteration 8, Residual Norm: 8.946e-08\n  Newton Iteration 9, Residual Norm: 2.858e-08\n  Newton Iteration 10, Residual Norm: 9.976e-09\n   Iter 0: Res_d=9.74e-09, Res_u=9.98e-09\n--- Time Step 276 ---\n  Newton Iteration 1, Residual Norm: 7.999e-09\n  Newton Iteration 1, Residual Norm: 9.904e-09\n  Newton Iteration 1, Residual Norm: 1.108e+00\n  Newton Iteration 2, Residual Norm: 2.658e-03\n  Newton Iteration 3, Residual Norm: 2.913e-04\n  Newton Iteration 4, Residual Norm: 5.668e-05\n  Newton Iteration 5, Residual Norm: 9.545e-06\n  Newton Iteration 6, Residual Norm: 2.080e-06\n  Newton Iteration 7, Residual Norm: 4.533e-07\n  Newton Iteration 8, Residual Norm: 2.057e-07\n  Newton Iteration 9, Residual Norm: 1.660e-08\n  Newton Iteration 10, Residual Norm: 9.950e-09\n   Iter 0: Res_d=9.90e-09, Res_u=9.95e-09\n--- Time Step 277 ---\n  Newton Iteration 1, Residual Norm: 8.022e-09\n  Newton Iteration 1, Residual Norm: 9.170e-09\n  Newton Iteration 1, Residual Norm: 1.110e+00\n  Newton Iteration 2, Residual Norm: 2.634e-03\n  Newton Iteration 3, Residual Norm: 3.189e-04\n  Newton Iteration 4, Residual Norm: 3.312e-05\n  Newton Iteration 5, Residual Norm: 1.687e-05\n  Newton Iteration 6, Residual Norm: 1.340e-06\n  Newton Iteration 7, Residual Norm: 1.343e-06\n  Newton Iteration 8, Residual Norm: 4.655e-08\n  Newton Iteration 9, Residual Norm: 4.976e-08\n  Newton Iteration 10, Residual Norm: 9.974e-09\n   Iter 0: Res_d=9.17e-09, Res_u=9.97e-09\n--- Time Step 278 ---\n  Newton Iteration 1, Residual Norm: 8.008e-09\n  Newton Iteration 1, Residual Norm: 9.379e-09\n  Newton Iteration 1, Residual Norm: 1.112e+00\n  Newton Iteration 2, Residual Norm: 2.653e-03\n  Newton Iteration 3, Residual Norm: 3.245e-04\n  Newton Iteration 4, Residual Norm: 3.738e-05\n  Newton Iteration 5, Residual Norm: 1.211e-05\n  Newton Iteration 6, Residual Norm: 1.646e-06\n  Newton Iteration 7, Residual Norm: 5.347e-07\n  Newton Iteration 8, Residual Norm: 1.333e-07\n  Newton Iteration 9, Residual Norm: 2.215e-08\n  Newton Iteration 10, Residual Norm: 9.977e-09\n   Iter 0: Res_d=9.38e-09, Res_u=9.98e-09\n--- Time Step 279 ---\n  Newton Iteration 1, Residual Norm: 7.983e-09\n  Newton Iteration 1, Residual Norm: 8.223e-09\n  Newton Iteration 1, Residual Norm: 1.115e+00\n  Newton Iteration 2, Residual Norm: 2.656e-03\n  Newton Iteration 3, Residual Norm: 3.555e-04\n  Newton Iteration 4, Residual Norm: 3.306e-05\n  Newton Iteration 5, Residual Norm: 1.318e-05\n  Newton Iteration 6, Residual Norm: 1.471e-06\n  Newton Iteration 7, Residual Norm: 1.157e-06\n  Newton Iteration 8, Residual Norm: 5.224e-08\n  Newton Iteration 9, Residual Norm: 3.542e-08\n  Newton Iteration 10, Residual Norm: 9.964e-09\n   Iter 0: Res_d=8.22e-09, Res_u=9.96e-09\n--- Time Step 280 ---\n  Newton Iteration 1, Residual Norm: 7.929e-09\n  Newton Iteration 1, Residual Norm: 9.986e-09\n  Newton Iteration 1, Residual Norm: 1.119e+00\n  Newton Iteration 2, Residual Norm: 2.660e-03\n  Newton Iteration 3, Residual Norm: 3.413e-04\n  Newton Iteration 4, Residual Norm: 3.685e-05\n  Newton Iteration 5, Residual Norm: 5.690e-05\n  Newton Iteration 6, Residual Norm: 1.631e-06\n  Newton Iteration 7, Residual Norm: 6.069e-07\n  Newton Iteration 8, Residual Norm: 7.679e-08\n  Newton Iteration 9, Residual Norm: 3.131e-08\n  Newton Iteration 10, Residual Norm: 1.000e-08\n   Iter 0: Res_d=9.99e-09, Res_u=1.00e-08\n--- Time Step 281 ---\n  Newton Iteration 1, Residual Norm: 7.977e-09\n  Newton Iteration 1, Residual Norm: 9.038e-09\n  Newton Iteration 1, Residual Norm: 1.122e+00\n  Newton Iteration 2, Residual Norm: 2.666e-03\n  Newton Iteration 3, Residual Norm: 3.395e-04\n  Newton Iteration 4, Residual Norm: 5.437e-04\n  Newton Iteration 5, Residual Norm: 1.216e-05\n  Newton Iteration 6, Residual Norm: 2.790e-06\n  Newton Iteration 7, Residual Norm: 3.984e-07\n  Newton Iteration 8, Residual Norm: 8.458e-08\n  Newton Iteration 9, Residual Norm: 2.025e-08\n  Newton Iteration 10, Residual Norm: 9.993e-09\n   Iter 0: Res_d=9.04e-09, Res_u=9.99e-09\n--- Time Step 282 ---\n  Newton Iteration 1, Residual Norm: 7.920e-09\n  Newton Iteration 1, Residual Norm: 9.744e-09\n  Newton Iteration 1, Residual Norm: 1.125e+00\n  Newton Iteration 2, Residual Norm: 2.694e-03\n  Newton Iteration 3, Residual Norm: 3.585e-04\n  Newton Iteration 4, Residual Norm: 3.716e-05\n  Newton Iteration 5, Residual Norm: 1.198e-05\n  Newton Iteration 6, Residual Norm: 2.832e-06\n  Newton Iteration 7, Residual Norm: 3.838e-07\n  Newton Iteration 8, Residual Norm: 1.118e-07\n  Newton Iteration 9, Residual Norm: 1.920e-08\n  Newton Iteration 10, Residual Norm: 9.977e-09\n   Iter 0: Res_d=9.74e-09, Res_u=9.98e-09\n--- Time Step 283 ---\n  Newton Iteration 1, Residual Norm: 7.982e-09\n  Newton Iteration 1, Residual Norm: 9.821e-09\n  Newton Iteration 1, Residual Norm: 1.126e+00\n  Newton Iteration 2, Residual Norm: 2.688e-03\n  Newton Iteration 3, Residual Norm: 9.234e-04\n  Newton Iteration 4, Residual Norm: 3.635e-05\n  Newton Iteration 5, Residual Norm: 1.825e-05\n  Newton Iteration 6, Residual Norm: 1.158e-06\n  Newton Iteration 7, Residual Norm: 9.416e-07\n  Newton Iteration 8, Residual Norm: 5.055e-08\n  Newton Iteration 9, Residual Norm: 4.180e-08\n  Newton Iteration 10, Residual Norm: 9.976e-09\n   Iter 0: Res_d=9.82e-09, Res_u=9.98e-09\n--- Time Step 284 ---\n  Newton Iteration 1, Residual Norm: 7.903e-09\n  Newton Iteration 1, Residual Norm: 8.799e-09\n  Newton Iteration 1, Residual Norm: 1.128e+00\n  Newton Iteration 2, Residual Norm: 2.692e-03\n  Newton Iteration 3, Residual Norm: 1.595e-03\n  Newton Iteration 4, Residual Norm: 3.277e-05\n  Newton Iteration 5, Residual Norm: 1.342e-05\n  Newton Iteration 6, Residual Norm: 1.306e-06\n  Newton Iteration 7, Residual Norm: 1.046e-06\n  Newton Iteration 8, Residual Norm: 5.166e-08\n  Newton Iteration 9, Residual Norm: 4.400e-08\n  Newton Iteration 10, Residual Norm: 9.891e-09\n   Iter 0: Res_d=8.80e-09, Res_u=9.89e-09\n--- Time Step 285 ---\n  Newton Iteration 1, Residual Norm: 7.941e-09\n  Newton Iteration 1, Residual Norm: 8.873e-09\n  Newton Iteration 1, Residual Norm: 1.129e+00\n  Newton Iteration 2, Residual Norm: 2.695e-03\n  Newton Iteration 3, Residual Norm: 2.263e-03\n  Newton Iteration 4, Residual Norm: 3.552e-05\n  Newton Iteration 5, Residual Norm: 1.191e-05\n  Newton Iteration 6, Residual Norm: 1.471e-06\n  Newton Iteration 7, Residual Norm: 4.964e-07\n  Newton Iteration 8, Residual Norm: 1.182e-07\n  Newton Iteration 9, Residual Norm: 1.896e-08\n  Newton Iteration 10, Residual Norm: 9.997e-09\n   Iter 0: Res_d=8.87e-09, Res_u=1.00e-08\n--- Time Step 286 ---\n  Newton Iteration 1, Residual Norm: 7.897e-09\n  Newton Iteration 1, Residual Norm: 8.750e-09\n  Newton Iteration 1, Residual Norm: 1.130e+00\n  Newton Iteration 2, Residual Norm: 2.709e-03\n  Newton Iteration 3, Residual Norm: 2.929e-03\n  Newton Iteration 4, Residual Norm: 4.670e-05\n  Newton Iteration 5, Residual Norm: 1.039e-05\n  Newton Iteration 6, Residual Norm: 2.381e-06\n  Newton Iteration 7, Residual Norm: 4.241e-07\n  Newton Iteration 8, Residual Norm: 9.963e-08\n  Newton Iteration 9, Residual Norm: 1.825e-08\n  Newton Iteration 10, Residual Norm: 9.980e-09\n   Iter 0: Res_d=8.75e-09, Res_u=9.98e-09\n--- Time Step 287 ---\n  Newton Iteration 1, Residual Norm: 7.950e-09\n  Newton Iteration 1, Residual Norm: 9.591e-09\n  Newton Iteration 1, Residual Norm: 1.131e+00\n  Newton Iteration 2, Residual Norm: 2.696e-03\n  Newton Iteration 3, Residual Norm: 3.616e-03\n  Newton Iteration 4, Residual Norm: 3.142e-05\n  Newton Iteration 5, Residual Norm: 1.158e-05\n  Newton Iteration 6, Residual Norm: 2.195e-06\n  Newton Iteration 7, Residual Norm: 4.132e-07\n  Newton Iteration 8, Residual Norm: 8.012e-08\n  Newton Iteration 9, Residual Norm: 2.010e-08\n  Newton Iteration 10, Residual Norm: 9.986e-09\n   Iter 0: Res_d=9.59e-09, Res_u=9.99e-09\n--- Time Step 288 ---\n  Newton Iteration 1, Residual Norm: 7.866e-09\n  Newton Iteration 1, Residual Norm: 9.561e-09\n  Newton Iteration 1, Residual Norm: 1.133e+00\n  Newton Iteration 2, Residual Norm: 2.722e-03\n  Newton Iteration 3, Residual Norm: 4.289e-03\n  Newton Iteration 4, Residual Norm: 3.601e-05\n  Newton Iteration 5, Residual Norm: 1.881e-05\n  Newton Iteration 6, Residual Norm: 1.118e-06\n  Newton Iteration 7, Residual Norm: 8.034e-07\n  Newton Iteration 8, Residual Norm: 4.844e-08\n  Newton Iteration 9, Residual Norm: 2.842e-08\n  Newton Iteration 10, Residual Norm: 9.933e-09\n   Iter 0: Res_d=9.56e-09, Res_u=9.93e-09\n--- Time Step 289 ---\n  Newton Iteration 1, Residual Norm: 7.891e-09\n  Newton Iteration 1, Residual Norm: 9.400e-09\n  Newton Iteration 1, Residual Norm: 1.135e+00\n  Newton Iteration 2, Residual Norm: 2.734e-03\n  Newton Iteration 3, Residual Norm: 4.955e-03\n  Newton Iteration 4, Residual Norm: 3.497e-05\n  Newton Iteration 5, Residual Norm: 1.255e-05\n  Newton Iteration 6, Residual Norm: 1.469e-06\n  Newton Iteration 7, Residual Norm: 5.310e-07\n  Newton Iteration 8, Residual Norm: 6.231e-08\n  Newton Iteration 9, Residual Norm: 2.065e-08\n  Newton Iteration 10, Residual Norm: 9.940e-09\n   Iter 0: Res_d=9.40e-09, Res_u=9.94e-09\n--- Time Step 290 ---\n  Newton Iteration 1, Residual Norm: 7.863e-09\n  Newton Iteration 1, Residual Norm: 9.176e-09\n  Newton Iteration 1, Residual Norm: 1.138e+00\n  Newton Iteration 2, Residual Norm: 2.754e-03\n  Newton Iteration 3, Residual Norm: 5.591e-03\n  Newton Iteration 4, Residual Norm: 3.205e-05\n  Newton Iteration 5, Residual Norm: 1.426e-05\n  Newton Iteration 6, Residual Norm: 1.194e-06\n  Newton Iteration 7, Residual Norm: 8.077e-07\n  Newton Iteration 8, Residual Norm: 4.750e-08\n  Newton Iteration 9, Residual Norm: 5.493e-08\n  Newton Iteration 10, Residual Norm: 9.877e-09\n   Iter 0: Res_d=9.18e-09, Res_u=9.88e-09\n--- Time Step 291 ---\n  Newton Iteration 1, Residual Norm: 7.868e-09\n  Newton Iteration 1, Residual Norm: 8.600e-09\n  Newton Iteration 1, Residual Norm: 1.140e+00\n  Newton Iteration 2, Residual Norm: 2.753e-03\n  Newton Iteration 3, Residual Norm: 6.210e-03\n  Newton Iteration 4, Residual Norm: 3.615e-05\n  Newton Iteration 5, Residual Norm: 1.248e-05\n  Newton Iteration 6, Residual Norm: 1.545e-06\n  Newton Iteration 7, Residual Norm: 4.750e-07\n  Newton Iteration 8, Residual Norm: 7.036e-08\n  Newton Iteration 9, Residual Norm: 2.039e-08\n  Newton Iteration 10, Residual Norm: 9.924e-09\n   Iter 0: Res_d=8.60e-09, Res_u=9.92e-09\n--- Time Step 292 ---\n  Newton Iteration 1, Residual Norm: 7.908e-09\n  Newton Iteration 1, Residual Norm: 9.855e-09\n  Newton Iteration 1, Residual Norm: 1.143e+00\n  Newton Iteration 2, Residual Norm: 2.770e-03\n  Newton Iteration 3, Residual Norm: 6.841e-03\n  Newton Iteration 4, Residual Norm: 3.556e-05\n  Newton Iteration 5, Residual Norm: 1.311e-05\n  Newton Iteration 6, Residual Norm: 1.256e-06\n  Newton Iteration 7, Residual Norm: 5.291e-07\n  Newton Iteration 8, Residual Norm: 5.350e-08\n  Newton Iteration 9, Residual Norm: 4.534e-08\n  Newton Iteration 10, Residual Norm: 9.988e-09\n   Iter 0: Res_d=9.86e-09, Res_u=9.99e-09\n--- Time Step 293 ---\n  Newton Iteration 1, Residual Norm: 7.886e-09\n  Newton Iteration 1, Residual Norm: 9.619e-09\n  Newton Iteration 1, Residual Norm: 1.145e+00\n  Newton Iteration 2, Residual Norm: 2.797e-03\n  Newton Iteration 3, Residual Norm: 7.424e-03\n  Newton Iteration 4, Residual Norm: 3.671e-05\n  Newton Iteration 5, Residual Norm: 1.261e-05\n  Newton Iteration 6, Residual Norm: 1.324e-06\n  Newton Iteration 7, Residual Norm: 5.170e-07\n  Newton Iteration 8, Residual Norm: 5.641e-08\n  Newton Iteration 9, Residual Norm: 2.215e-08\n  Newton Iteration 10, Residual Norm: 9.938e-09\n   Iter 0: Res_d=9.62e-09, Res_u=9.94e-09\n--- Time Step 294 ---\n  Newton Iteration 1, Residual Norm: 7.901e-09\n  Newton Iteration 1, Residual Norm: 9.681e-09\n  Newton Iteration 1, Residual Norm: 1.146e+00\n  Newton Iteration 2, Residual Norm: 2.803e-03\n  Newton Iteration 3, Residual Norm: 8.023e-03\n  Newton Iteration 4, Residual Norm: 5.300e-05\n  Newton Iteration 5, Residual Norm: 8.607e-06\n  Newton Iteration 6, Residual Norm: 2.304e-06\n  Newton Iteration 7, Residual Norm: 3.254e-07\n  Newton Iteration 8, Residual Norm: 8.788e-08\n  Newton Iteration 9, Residual Norm: 1.276e-08\n  Newton Iteration 10, Residual Norm: 9.989e-09\n   Iter 0: Res_d=9.68e-09, Res_u=9.99e-09\n--- Time Step 295 ---\n  Newton Iteration 1, Residual Norm: 7.840e-09\n  Newton Iteration 1, Residual Norm: 9.806e-09\n  Newton Iteration 1, Residual Norm: 1.146e+00\n  Newton Iteration 2, Residual Norm: 2.816e-03\n  Newton Iteration 3, Residual Norm: 8.599e-03\n  Newton Iteration 4, Residual Norm: 3.648e-05\n  Newton Iteration 5, Residual Norm: 1.230e-05\n  Newton Iteration 6, Residual Norm: 1.359e-06\n  Newton Iteration 7, Residual Norm: 5.484e-07\n  Newton Iteration 8, Residual Norm: 1.207e-07\n  Newton Iteration 9, Residual Norm: 1.363e-08\n  Newton Iteration 10, Residual Norm: 9.972e-09\n   Iter 0: Res_d=9.81e-09, Res_u=9.97e-09\n--- Time Step 296 ---\n  Newton Iteration 1, Residual Norm: 7.834e-09\n  Newton Iteration 1, Residual Norm: 8.353e-09\n  Newton Iteration 1, Residual Norm: 1.146e+00\n  Newton Iteration 2, Residual Norm: 2.839e-03\n  Newton Iteration 3, Residual Norm: 9.182e-03\n  Newton Iteration 4, Residual Norm: 3.304e-05\n  Newton Iteration 5, Residual Norm: 1.834e-05\n  Newton Iteration 6, Residual Norm: 1.082e-06\n  Newton Iteration 7, Residual Norm: 6.623e-07\n  Newton Iteration 8, Residual Norm: 4.591e-08\n  Newton Iteration 9, Residual Norm: 2.854e-08\n  Newton Iteration 10, Residual Norm: 9.981e-09\n   Iter 0: Res_d=8.35e-09, Res_u=9.98e-09\n--- Time Step 297 ---\n  Newton Iteration 1, Residual Norm: 7.860e-09\n  Newton Iteration 1, Residual Norm: 9.346e-09\n  Newton Iteration 1, Residual Norm: 1.144e+00\n  Newton Iteration 2, Residual Norm: 2.855e-03\n  Newton Iteration 3, Residual Norm: 9.718e-03\n  Newton Iteration 4, Residual Norm: 3.653e-05\n  Newton Iteration 5, Residual Norm: 1.738e-05\n  Newton Iteration 6, Residual Norm: 1.053e-06\n  Newton Iteration 7, Residual Norm: 6.303e-07\n  Newton Iteration 8, Residual Norm: 4.253e-08\n  Newton Iteration 9, Residual Norm: 3.694e-08\n  Newton Iteration 10, Residual Norm: 9.931e-09\n   Iter 0: Res_d=9.35e-09, Res_u=9.93e-09\n--- Time Step 298 ---\n  Newton Iteration 1, Residual Norm: 7.825e-09\n  Newton Iteration 1, Residual Norm: 9.621e-09\n  Newton Iteration 1, Residual Norm: 1.141e+00\n  Newton Iteration 2, Residual Norm: 2.847e-03\n  Newton Iteration 3, Residual Norm: 1.026e-02\n  Newton Iteration 4, Residual Norm: 3.675e-05\n  Newton Iteration 5, Residual Norm: 1.362e-05\n  Newton Iteration 6, Residual Norm: 1.202e-06\n  Newton Iteration 7, Residual Norm: 7.652e-07\n  Newton Iteration 8, Residual Norm: 5.020e-08\n  Newton Iteration 9, Residual Norm: 3.134e-08\n  Newton Iteration 10, Residual Norm: 9.947e-09\n   Iter 0: Res_d=9.62e-09, Res_u=9.95e-09\n--- Time Step 299 ---\n  Newton Iteration 1, Residual Norm: 7.832e-09\n  Newton Iteration 1, Residual Norm: 9.222e-09\n  Newton Iteration 1, Residual Norm: 1.137e+00\n  Newton Iteration 2, Residual Norm: 2.855e-03\n  Newton Iteration 3, Residual Norm: 1.077e-02\n  Newton Iteration 4, Residual Norm: 3.755e-05\n  Newton Iteration 5, Residual Norm: 1.207e-05\n  Newton Iteration 6, Residual Norm: 1.606e-06\n  Newton Iteration 7, Residual Norm: 7.898e-07\n  Newton Iteration 8, Residual Norm: 4.992e-08\n  Newton Iteration 9, Residual Norm: 3.821e-08\n  Newton Iteration 10, Residual Norm: 9.949e-09\n   Iter 0: Res_d=9.22e-09, Res_u=9.95e-09\n--- Time Step 300 ---\n  Newton Iteration 1, Residual Norm: 7.842e-09\n  Newton Iteration 1, Residual Norm: 9.207e-09\n  Newton Iteration 1, Residual Norm: 1.132e+00\n  Newton Iteration 2, Residual Norm: 2.884e-03\n  Newton Iteration 3, Residual Norm: 1.127e-02\n  Newton Iteration 4, Residual Norm: 3.661e-05\n  Newton Iteration 5, Residual Norm: 1.189e-05\n  Newton Iteration 6, Residual Norm: 2.550e-06\n  Newton Iteration 7, Residual Norm: 4.051e-07\n  Newton Iteration 8, Residual Norm: 1.536e-07\n  Newton Iteration 9, Residual Norm: 1.493e-08\n  Newton Iteration 10, Residual Norm: 9.978e-09\n   Iter 0: Res_d=9.21e-09, Res_u=9.98e-09\n</code></pre> <pre><code>\n</code></pre>"},{"location":"examples/thermal_shock_fracture/#visualization","title":"Visualization","text":"<p>We plot the results. Notice how the cracks (Field \\(d\\)) initiate at the boundaries where the thermal gradient (and thus tensile stress) is highest.</p> Analtical solution for 1D transient heat conduction (for validation) <pre><code>import matplotlib.patches as patches\nimport matplotlib.tri as tri_mat\nfrom matplotlib.gridspec import GridSpec\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n\ndef set_size(fraction=1, height_ratio=\"golden\", width=\"two-column\", subplots=(1, 1)):\n    if width == \"two-column\":\n        width_pt = 180  # mm\n    elif width == \"one-column\":\n        width_pt = 90  # mm\n    else:\n        width_pt = width\n\n    if height_ratio == \"golden\":\n        ratio_pt = (np.sqrt(5) - 1.0) / 2.0\n    else:\n        ratio_pt = height_ratio\n\n    fig_width_pt = width_pt * fraction\n    inches_per_pt = 1.0 / 25.4\n    fig_width_in = fig_width_pt * inches_per_pt\n    fig_height_in = fig_width_in * ratio_pt * (subplots[0] / subplots[1])\n    fig_dim = (fig_width_in, fig_height_in)\n\n    return fig_dim\n\n\n\ndef compute_temperature(x, t, L, D, theta_0, theta_A=0, n_terms=50):\n    \"\"\"\n    Computes the 1D analytical solution of heat conduction based on Eq A.3.\n\n    Args:\n        x       : array-like, spatial coordinates (0 to L)\n        t       : float, time point to evaluate\n        L       : float, length of the domain\n        D       : float, thermal diffusivity\n        theta_0 : float, initial temperature of the domain\n        theta_A : float, fixed temperature at left edge (x=0). Default is 0 per Eq A.2.\n        n_terms : int, number of terms in the summation series (convergence factor)\n\n    Returns:\n        theta   : array-like, temperature profile at time t\n    \"\"\"\n    summation = np.zeros_like(x, dtype=float)\n\n    for n in range(1, n_terms * 2, 2):\n\n        spatial_part = np.sin((n * np.pi * x) / (2 * L)) / (n * np.pi)\n\n        exponent = - (n**2 * np.pi**2 * D * t) / (4 * L**2)\n        temporal_part = np.exp(exponent)\n\n        summation += spatial_part * temporal_part\n    theta = theta_A + 4 * (theta_0 - theta_A) * summation\n\n    return theta\n</code></pre> Visualization of temperature, damage, and comparison with analytical solution <pre><code>from matplotlib.lines import Line2D\n\ntriang = tri_mat.Triangulation(mesh.coords[:, 0], mesh.coords[:, 1], mesh.elements)\n\n\nfig = plt.figure(layout=\"constrained\", figsize=set_size(height_ratio=0.25, subplots=(3, 2)))\n\ngs = GridSpec(\n    3,\n    2,\n    figure=fig,\n    width_ratios=[1, 0.25],\n    height_ratios=[1, 1, 1],\n    wspace=0.15,\n    hspace=0.05,\n)\n\nnew_coords = mesh.coords.copy()\nnew_coords[:, 0] = mesh.coords[:, 1]\nnew_coords[:, 1] = mesh.coords[:, 0]\n\nstep_to_plot = 299\n\nwidth = x_max - x_min\nheight = y_max - y_min\n\n\ndef add_bounding_box(ax):\n    rect = patches.Rectangle(\n        (x_min, y_min),\n        width,\n        height,\n        linewidth=0.5,\n        edgecolor=\"black\",\n        facecolor=\"none\",\n    )\n    ax.add_patch(rect)\n\n\ndef add_zoom_box(ax):\n    rect = patches.Rectangle(\n        (0, 0), 1, 1, lw=0.7, ec=\"black\", fc=\"none\", transform=ax.transAxes\n    )\n    ax.add_patch(rect)\n\n\nax1 = fig.add_subplot(gs[0, 0])\ncb = ax1.tripcolor(\n    triang,\n    results_T[step_to_plot].flatten(),\n    alpha=0.95,\n    cmap=\"pink_r\",\n    shading=\"gouraud\",\n)\ncb.set_clim(jnp.min(results_T[step_to_plot]), jnp.max(results_T[step_to_plot]))\ncax = make_axes_locatable(ax1).append_axes(\"right\", size=\"1%\", pad=0.05)\nfig.colorbar(cb, cax=cax, label=r\"$T~[K]$\")\nadd_bounding_box(ax1)  # &lt;--- Add Box\nax1.set_aspect(\"equal\")\nax1.axis(\"off\")\n\nax2 = fig.add_subplot(gs[1, 0])\ncb = ax2.tripcolor(\n    triang,\n    results_d[step_to_plot - 190],\n    alpha=0.95,\n    cmap=\"berlin\",\n    shading=\"gouraud\",\n    vmin=0.0,\n    vmax=1.0,\n)\ncax = make_axes_locatable(ax2).append_axes(\"right\", size=\"1%\", pad=0.05)\nfig.colorbar(cb, cax=cax, label=r\"$\\mathsf{Damage}$\")\nadd_bounding_box(ax2)\nax2.text(\n    0.5,\n    -0.1,\n    r\"$t={:.2f}~\\mathsf{{ms}}$\".format(dt * (step_to_plot - 200) * 1000),\n    #rf\"$t=${dt * (step_to_plot - 200) * 1000}~\" + r\"$\\mathsf{ms}$\",\n    transform=ax2.transAxes,\n    ha=\"center\",\n    va=\"top\",\n)\n\n\nax2.set_aspect(\"equal\")\nax2.axis(\"off\")\n\n\nax3 = fig.add_subplot(gs[2, 0])\nu_reshaped = results_u[step_to_plot].reshape(-1, 2)\ngrad_u = op.grad(u_reshaped)\ntheta_quad = op.eval(results_T[step_to_plot])\ndelta_theta = theta_quad - theta_quad_ref\ndamage_quad = op.eval(results_d[step_to_plot])\n\npsi_plus_current, psi_minus_current = compute_elastic_energy_density(\n    grad_u, delta_theta, mu, lmbda, mat.alpha\n)\npsi_plus_degraded = degradation_function(damage_quad) * psi_plus_current\n\n\ncb = ax3.tripcolor(\n    triang,\n    results_d[step_to_plot],\n    alpha=0.95,\n    cmap=\"berlin\",\n    shading=\"gouraud\",\n    vmin=0.0,\n    vmax=1.0,\n)\ncax = make_axes_locatable(ax3).append_axes(\"right\", size=\"1%\", pad=0.05)\nfig.colorbar(cb, cax=cax, label=r\"$\\mathsf{Damage}$\")\n\nax3.text(\n    0.5,\n    -0.1,\n    r\"$t={:.2f}~\\mathsf{{ms}}$\".format(dt * step_to_plot * 1000.),\n    transform=ax3.transAxes,\n    ha=\"center\",\n    va=\"top\",\n)\n\n\nadd_bounding_box(ax3)\nax3.set_aspect(\"equal\")\nax3.axis(\"off\")\n\n\nL = y_max - y_min  # Length of domain (e.g., meters)\ntheta_0 = 550.0  # Initial temp of the bar (e.g., Celsius)\ntheta_A = 300.0  # Boundary temp at x=0 (Fixed per Eq A.2)\n\nx_values = np.linspace(0, L, 100)  # 100 spatial points from 0 to L\n\n\nprop_cycle = plt.rcParams[\"axes.prop_cycle\"]\ncolors = prop_cycle.by_key()[\"color\"]\n\nax4 = fig.add_subplot(gs[:, -1])\n\nfor index, i in enumerate(np.array([10, 100, 299])):\n    # Compute solution for this time step\n    t = dt * i\n    temp_profile = compute_temperature(x_values, t, L, mat.kappa, theta_0, theta_A)\n\n    # Plotting\n    label_str = f\"$t$ = {t * 1000}~\" + r\"$\\mathsf{ms}$\" if t &gt; 0 else \"t = 0 s (Initial)\"\n    ax4.plot(temp_profile, x_values, label=label_str, color=colors[index])\n    ax4.plot(\n        results_T[i][right_nodes].flatten(),\n        mesh.coords[right_nodes, 1].flatten() - y_min,\n        \"o\",\n        markeredgecolor=colors[index],\n        markerfacecolor=\"white\",\n        markeredgewidth=0.8,\n        markevery=2\n    )\n\nax4.set_xlabel(r\"$T~[\\mathsf{K}]$\")\nax4.set_ylabel(r\"$y~[\\mathsf{mm}]$\")\nax4.grid(True)\nax4.spines[\"top\"].set_visible(False)\nax4.spines[\"right\"].set_visible(False)\n#ax4.legend(frameon=False)\n\nlegend = ax4.legend(frameon=False, numpoints=1, markerscale=1.25)\nlegend_elements = [\n        Line2D([0], [0], color=\"k\", linestyle=\"solid\", label=\"analytical\"),\n        Line2D([0], [0], color=\"k\", linestyle=\"none\", marker=\"o\", markeredgewidth=0.8,  markerfacecolor=\"white\", markeredgecolor='k', label=\"tatva\"),\n    ]\nlegend = ax4.legend(handles=[*legend.legend_handles, *legend_elements], frameon=False, numpoints=1, markerscale=1.25)\n\n\n\nplt.show()\n</code></pre> <p></p> <pre><code>\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/","title":"Sparse Solver","text":""},{"location":"external_solvers/linear_elasticity_petsc4py/#linear-elasticity-with-petsc","title":"Linear elasticity with PETSc","text":"<p>In this notebook, we solve a linear elastic problem using <code>PETSc</code> based solvers.</p> <pre><code>from typing import NamedTuple\n\nimport gmsh\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nimport jax.numpy as jnp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator\nfrom tatva_coloring import distance2_color_and_seeds\nfrom tatva import sparse\n\nfrom petsc4py import PETSc\n</code></pre> Code for generating a plate with a hole and plotting the mesh <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nimport meshio\n\nimport numpy as np\nimport os\n\n\ndef plot_mesh(mesh: Mesh, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.tripcolor(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        facecolors=np.ones(len(mesh.elements)),\n        cmap=\"managua\",\n        edgecolors=\"k\",\n        linewidth=0.2,\n    )\n\n    ax.set_aspect(\"equal\")\n    ax.margins(0.0)\n\ndef generate_refined_plate_with_hole(\n    width: float,\n    height: float,\n    hole_radius: float,\n    mesh_size_fine: float,\n    mesh_size_coarse: float,\n):\n    mesh_dir = os.path.join(os.getcwd(), \"../meshes\")\n    os.makedirs(mesh_dir, exist_ok=True)\n    output_filename = os.path.join(mesh_dir, \"plate_hole_refined.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"plate_with_hole_refined\")\n    occ = gmsh.model.occ\n\n    rect = occ.addRectangle(0, 0, 0, width, height)\n    cx = width / 2.0\n    cy = height / 2.0\n    disk = occ.addDisk(cx, cy, 0, hole_radius, hole_radius)\n\n    out, _ = occ.cut([(2, rect)], [(2, disk)])\n    occ.synchronize()\n\n    surface_tag = out[0][1]\n    gmsh.model.addPhysicalGroup(2, [surface_tag], 1, name=\"domain\")\n\n    boundaries = gmsh.model.getBoundary(out, oriented=False)\n    boundary_tags = [b[1] for b in boundaries]\n    gmsh.model.addPhysicalGroup(1, boundary_tags, 2, name=\"boundaries\")\n\n    hole_curve_tags = []\n    for tag in boundary_tags:\n        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(1, tag)\n        # The hole is completely inside the outer rectangle\n        if xmin &gt; 0 and xmax &lt; width and ymin &gt; 0 and ymax &lt; height:\n            hole_curve_tags.append(tag)\n\n    gmsh.model.mesh.field.add(\"Distance\", 1)\n    gmsh.model.mesh.field.setNumbers(1, \"CurvesList\", hole_curve_tags)\n    gmsh.model.mesh.field.setNumber(1, \"NumPointsPerCurve\", 100)\n\n    gmsh.model.mesh.field.add(\"Threshold\", 2)\n    gmsh.model.mesh.field.setNumber(2, \"InField\", 1)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMin\", mesh_size_fine)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMax\", mesh_size_coarse)\n    # Start growing the mesh exactly at the hole boundary\n    gmsh.model.mesh.field.setNumber(2, \"DistMin\", 0.0)\n    # Reach maximum element size at a distance equal to 2 hole radii away\n    gmsh.model.mesh.field.setNumber(2, \"DistMax\", hole_radius * 2.0)\n\n    gmsh.model.mesh.field.setAsBackgroundMesh(2)\n\n    gmsh.option.setNumber(\"Mesh.MeshSizeExtendFromBoundary\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromPoints\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromCurvature\", 0)\n\n    gmsh.model.mesh.generate(2)\n    gmsh.write(output_filename)\n    gmsh.finalize()\n\n    _mesh = meshio.read(output_filename)\n    coords = _mesh.points[:, :2]\n    elements = _mesh.cells_dict[\"triangle\"]\n\n    return Mesh(coords=coords, elements=elements)\n</code></pre> <pre><code>lx = 1.0\nly = 1.0\nmesh = generate_refined_plate_with_hole(\n    lx, ly, hole_radius=0.2, mesh_size_fine=0.01, mesh_size_coarse=0.05\n)\n\nn_dofs_per_node = 2\nn_dofs = mesh.coords.shape[0] * n_dofs_per_node\n\nplot_mesh(mesh)\n</code></pre> <pre><code>Info    : Meshing 1D...                                                                                                                        \nInfo    : [  0%] Meshing curve 5 (Ellipse)\nInfo    : [ 30%] Meshing curve 6 (Line)\nInfo    : [ 50%] Meshing curve 7 (Line)\nInfo    : [ 70%] Meshing curve 8 (Line)\nInfo    : [ 90%] Meshing curve 9 (Line)\nInfo    : Done meshing 1D (Wall 0.0205777s, CPU 0.017819s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0496628s, CPU 0.049729s)\nInfo    : 1874 nodes 3753 elements\nInfo    : Writing '/home/mohit/Documents/dev/tatva-docs/docs/external_solvers/../meshes/plate_hole_refined.msh'...\nInfo    : Done writing '/home/mohit/Documents/dev/tatva-docs/docs/external_solvers/../meshes/plate_hole_refined.msh'\n</code></pre> <p></p>"},{"location":"external_solvers/linear_elasticity_petsc4py/#problem-setup","title":"Problem setup","text":"<pre><code>from tatva.element import Tri3\n\nop = Operator(mesh, Tri3())\n\n\nboundary_left = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nboundary_right = jnp.where(jnp.isclose(mesh.coords[:, 0], lx))[0]\npoint_at_y_0 = jnp.where(\n    jnp.isclose(mesh.coords[:, 0], lx) &amp; jnp.isclose(mesh.coords[:, 1], 0.0)\n)[0][0]\nassert point_at_y_0\n\nfixed_dofs = jnp.concatenate(\n    [\n        boundary_left * n_dofs_per_node,\n    ]\n)\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#defining-energy-functional","title":"Defining energy functional","text":"<p>We now define the functions to compute the total strain energy</p> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  \n    lmbda: float\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat = Material.from_youngs_poisson_2d(1, 0.3)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy_density(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#enforcing-boundary-condition-via-static-condensation","title":"Enforcing boundary condition via static condensation","text":"<pre><code>@jax.jit\ndef total_energy_full(u_flat: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat.reshape(-1, 2)\n    u_grad = op.grad(u)\n    e_density = strain_energy_density(u_grad, mat.mu, mat.lmbda)\n    return op.integrate(e_density)\n\n\n@jax.jit\ndef total_energy(u_free: Array, applied_disp: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = jnp.zeros(n_dofs).at[free_dofs].set(u_free)\n    u_full = u_full.at[fixed_dofs].set(applied_disp)\n    return total_energy_full(u_full)\n\n\nresidual = jax.jacrev(total_energy)\n</code></pre> <p>Now we can define the <code>sparsity_pattern</code> and use <code>sparse.jacfwd</code> to create a function that computes the sparse stiffness matrix using sparse differentiation.</p> <pre><code>import scipy\n\nnb_dofs_per_node = 2\n\nsparsity_pattern = sparse.create_sparsity_pattern(\n    mesh, n_dofs_per_node=nb_dofs_per_node\n)\n\nreduced_sparsity_pattern = sparse.reduce_sparsity_pattern(sparsity_pattern, free_dofs)\nreduced_sparsity_pattern_csr = scipy.sparse.csr_matrix(\n    (\n        reduced_sparsity_pattern.data,\n        (\n            reduced_sparsity_pattern.indices[:, 0],\n            reduced_sparsity_pattern.indices[:, 1],\n        ),\n    )\n)\n\ncolors = distance2_color_and_seeds(\n    reduced_sparsity_pattern_csr.indptr,\n    reduced_sparsity_pattern_csr.indices,\n    n_dofs=len(free_dofs),\n)[0]\n</code></pre> <pre><code>hessian_fn = sparse.jacfwd(\n    gradient=residual,\n    row_ptr=reduced_sparsity_pattern_csr.indptr,\n    col_indices=reduced_sparsity_pattern_csr.indices,\n    colors=colors,\n    color_batch_size=len(jnp.unique(colors)) + 1,\n)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#defining-the-loading-traction-on-right-edge","title":"Defining the loading traction on right edge","text":"<p>We define a new <code>Operator</code> consisting of line elements along the right edge and then use this <code>op_line</code> to integrate the traction along the nodes.</p> <pre><code>sig_loading = 1e-2\n\nf_ext_0 = jnp.zeros(n_dofs)\n\nidx_right = n_dofs_per_node * boundary_right\n\nf_ext_0 = f_ext_0.at[idx_right].add(sig_loading)\nf_ext = f_ext_0.at[free_dofs].get()\n</code></pre> <p>Now let us solve the linear problem using <code>PETSc</code></p> \\[ \\mathbf{K}\\boldsymbol{u} =\\boldsymbol{f}_\\text{ext} \\] <p>We will use the above defined <code>hessian_fn</code> to compute the sparse stiffness matrix and will convert it to <code>PETSc.Mat.AIJ</code> which is the the sparse matrix representation.</p> <pre><code>K_bcco = hessian_fn(jnp.zeros(len(free_dofs)), applied_disp=jnp.zeros(len(fixed_dofs)))\npetsc_mat = PETSc.Mat().createAIJ(\n    size=K_bcco.shape,\n    csr=(\n        reduced_sparsity_pattern_csr.indptr,\n        reduced_sparsity_pattern_csr.indices,\n        K_bcco.data,\n    ),\n)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#setting-up-petsc-solver-direct-linear-solver","title":"Setting up PETSc solver (Direct Linear Solver)","text":"<p>We first set a Direct Linear Solver in PETSc.</p> <pre><code>ksp = PETSc.KSP().create()\nksp.setOperators(petsc_mat)\nksp.setType('preonly')\nksp.setConvergenceHistory()\nksp.getPC().setType('lu')\n</code></pre> <p>We can now solve the linear system for the applied \\(\\boldsymbol{f}_\\text{ext}\\)</p> <pre><code>du = petsc_mat.createVecRight()\nb = petsc_mat.createVecLeft()\nb.setArray(f_ext)\nksp.solve(b, du)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#visualization-and-analyzing-the-results","title":"Visualization and analyzing the results","text":"Code to visualize the results <pre><code>from matplotlib.tri import Triangulation\n\nu = jnp.zeros(n_dofs).at[free_dofs].set(du.getArray())\nu = u.reshape(-1, 2)\n\nfig, ax = plt.subplots(figsize=(7.4, 3))\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\nsig = compute_stress(compute_strain(op.grad(u)), mat.mu, mat.lmbda).squeeze()\n\n\ndef plot_field(ax: Axes):\n    cb = ax.tripcolor(\n        tri,\n        sig[..., 0, 1],\n        alpha=0.95,\n        rasterized=True,\n        cmap=\"managua\",\n    )\n    ax.set_aspect(\"equal\")\n    ax.set(\n        xlabel=\"$x$\",\n        ylabel=\"$y$\",\n    )\n    return cb\n\n\ncb = plot_field(ax)\nax.set_axis_off()\nplt.colorbar(cb, ax=ax, label=r\"$\\sigma_{xy}$\", shrink=0.7)\nfig.tight_layout()\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py/#setting-up-petsc-solver-iterative-solver","title":"Setting up PETSc Solver (Iterative Solver)","text":"<p>We will use a <code>Conjugate Gradient</code> solver from <code>PETSc</code>. Although, here we will directly use the sparse matrix and pass it on to <code>PETSc</code>. </p> <p>Info</p> <p>Ideally, we should use the <code>JVP</code> and set the function.</p> <pre><code>ksp = PETSc.KSP().create()\nksp.setOperators(petsc_mat)\nksp.setType('cg')\nksp.setConvergenceHistory()\nksp.getPC().setType('none')\n</code></pre> <p>We can now solve the linear system for the applied \\(\\boldsymbol{f}_\\text{ext}\\)</p> <pre><code>du = petsc_mat.createVecRight()\nb = petsc_mat.createVecLeft()\nb.setArray(f_ext)\n\nksp.solve(b, du)\n</code></pre> <p>Lets see how the error evolved during the iterations.</p> Code to visualize the convergence history <pre><code>residuals = ksp.getConvergenceHistory()\n\nplt.figure(figsize=(7.4, 3))\nplt.semilogy(residuals)\nplt.xlabel(\"Iteration\")\nplt.ylabel(\"Residual\")\nplt.gca().margins(0.0)\nplt.show()\n</code></pre> <p></p> <p>We can visualize the deformation of the plate and it should be identical to the previous result.</p> Code to visualize the results <pre><code>from matplotlib.tri import Triangulation\n\nu = jnp.zeros(n_dofs).at[free_dofs].set(du.getArray())\nu = u.reshape(-1, 2)\n\nfig, ax = plt.subplots(figsize=(7.4, 3))\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\nsig = compute_stress(compute_strain(op.grad(u)), mat.mu, mat.lmbda).squeeze()\n\n\ndef plot_field(ax: Axes):\n    cb = ax.tripcolor(\n        tri,\n        sig[..., 0, 1],\n        alpha=0.95,\n        rasterized=True,\n        cmap=\"managua\",\n    )\n    ax.set_aspect(\"equal\")\n    ax.set(\n        xlabel=\"$x$\",\n        ylabel=\"$y$\",\n    )\n    return cb\n\n\ncb = plot_field(ax)\nax.set_axis_off()\nplt.colorbar(cb, ax=ax, label=r\"$\\sigma_{xy}$\", shrink=0.7)\nfig.tight_layout()\n</code></pre> <p></p>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/","title":"Matrix-Free Solver","text":""},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#matrix-free-approach-with-petsc","title":"Matrix-Free approach with PETSc","text":"<p>In this notebook, we solve a linear elastic problem using <code>PETSc</code> based solvers. In this example, we will use the Jacobian-Vector product to compute the action of sitffness matrix instead of materializing the stiffness matrix.</p> <p>In this example, we will use the <code>Python-Aware</code> PETSc types.</p> <pre><code>from typing import NamedTuple\n\nimport gmsh\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nimport jax.numpy as jnp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator\n\nfrom petsc4py import PETSc\n</code></pre> Code for generating a plate with a hole and plotting the mesh <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nimport meshio\n\nimport numpy as np\nimport os\n\n\ndef plot_mesh(mesh: Mesh, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.tripcolor(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        facecolors=np.ones(len(mesh.elements)),\n        cmap=\"managua\",\n        edgecolors=\"k\",\n        linewidth=0.2,\n    )\n\n    ax.set_aspect(\"equal\")\n    ax.margins(0.0)\n\n\ndef generate_refined_plate_with_hole(\n    width: float,\n    height: float,\n    hole_radius: float,\n    mesh_size_fine: float,\n    mesh_size_coarse: float,\n):\n    mesh_dir = os.path.join(os.getcwd(), \"../meshes\")\n    os.makedirs(mesh_dir, exist_ok=True)\n    output_filename = os.path.join(mesh_dir, \"plate_hole_refined.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"plate_with_hole_refined\")\n    occ = gmsh.model.occ\n\n    rect = occ.addRectangle(0, 0, 0, width, height)\n    cx = width / 2.0\n    cy = height / 2.0\n    disk = occ.addDisk(cx, cy, 0, hole_radius, hole_radius)\n\n    out, _ = occ.cut([(2, rect)], [(2, disk)])\n    occ.synchronize()\n\n    surface_tag = out[0][1]\n    gmsh.model.addPhysicalGroup(2, [surface_tag], 1, name=\"domain\")\n\n    boundaries = gmsh.model.getBoundary(out, oriented=False)\n    boundary_tags = [b[1] for b in boundaries]\n    gmsh.model.addPhysicalGroup(1, boundary_tags, 2, name=\"boundaries\")\n\n    hole_curve_tags = []\n    for tag in boundary_tags:\n        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(1, tag)\n        # The hole is completely inside the outer rectangle\n        if xmin &gt; 0 and xmax &lt; width and ymin &gt; 0 and ymax &lt; height:\n            hole_curve_tags.append(tag)\n\n    gmsh.model.mesh.field.add(\"Distance\", 1)\n    gmsh.model.mesh.field.setNumbers(1, \"CurvesList\", hole_curve_tags)\n    gmsh.model.mesh.field.setNumber(1, \"NumPointsPerCurve\", 100)\n\n    gmsh.model.mesh.field.add(\"Threshold\", 2)\n    gmsh.model.mesh.field.setNumber(2, \"InField\", 1)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMin\", mesh_size_fine)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMax\", mesh_size_coarse)\n    # Start growing the mesh exactly at the hole boundary\n    gmsh.model.mesh.field.setNumber(2, \"DistMin\", 0.0)\n    # Reach maximum element size at a distance equal to 2 hole radii away\n    gmsh.model.mesh.field.setNumber(2, \"DistMax\", hole_radius * 2.0)\n\n    gmsh.model.mesh.field.setAsBackgroundMesh(2)\n\n    gmsh.option.setNumber(\"Mesh.MeshSizeExtendFromBoundary\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromPoints\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromCurvature\", 0)\n\n    gmsh.model.mesh.generate(2)\n    gmsh.write(output_filename)\n    gmsh.finalize()\n\n    _mesh = meshio.read(output_filename)\n    coords = _mesh.points[:, :2]\n    elements = _mesh.cells_dict[\"triangle\"]\n\n    return Mesh(coords=coords, elements=elements)\n</code></pre> <pre><code>lx = 1.0\nly = 1.0\nmesh = generate_refined_plate_with_hole(\n    lx, ly, hole_radius=0.2, mesh_size_fine=0.01, mesh_size_coarse=0.05\n)\n\nn_dofs_per_node = 2\nn_dofs = mesh.coords.shape[0] * n_dofs_per_node\n\nplot_mesh(mesh)\n</code></pre> <pre><code>Info    : Meshing 1D...                                                                                                                        \nInfo    : [  0%] Meshing curve 5 (Ellipse)\nInfo    : [ 30%] Meshing curve 6 (Line)\nInfo    : [ 50%] Meshing curve 7 (Line)\nInfo    : [ 70%] Meshing curve 8 (Line)\nInfo    : [ 90%] Meshing curve 9 (Line)\nInfo    : Done meshing 1D (Wall 0.0317488s, CPU 0.028828s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0757454s, CPU 0.075845s)\nInfo    : 1874 nodes 3753 elements\nInfo    : Writing '/home/mohit/Documents/research_notes/tatva-examples/examples/../meshes/plate_hole_refined.msh'...\nInfo    : Done writing '/home/mohit/Documents/research_notes/tatva-examples/examples/../meshes/plate_hole_refined.msh'\n</code></pre> <p></p>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#problem-setup","title":"Problem setup","text":"<pre><code>from tatva.element import Tri3\n\nop = Operator(mesh, Tri3())\n\n\nboundary_left = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nboundary_right = jnp.where(jnp.isclose(mesh.coords[:, 0], lx))[0]\npoint_at_y_0 = jnp.where(\n    jnp.isclose(mesh.coords[:, 0], lx) &amp; jnp.isclose(mesh.coords[:, 1], 0.0)\n)[0][0]\nassert point_at_y_0\n\nfixed_dofs = jnp.concatenate(\n    [\n        boundary_left * n_dofs_per_node,\n    ]\n)\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#defining-energy-functional","title":"Defining energy functional","text":"<p>We now define the functions to compute the total strain energy</p> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  \n    lmbda: float\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat = Material.from_youngs_poisson_2d(1, 0.3)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy_density(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#enforcing-boundary-condition-via-static-condensation","title":"Enforcing boundary condition via static condensation","text":"<pre><code>@jax.jit\ndef total_energy_full(u_flat: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat.reshape(-1, 2)\n    u_grad = op.grad(u)\n    e_density = strain_energy_density(u_grad, mat.mu, mat.lmbda)\n    return op.integrate(e_density)\n\n\n@jax.jit\ndef total_energy(u_free: Array, applied_disp: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = jnp.zeros(n_dofs).at[free_dofs].set(u_free)\n    u_full = u_full.at[fixed_dofs].set(applied_disp)\n    return total_energy_full(u_full)\n\n\ncompute_internal = jax.jacrev(total_energy)\n\n@jax.jit\ndef compute_tangent(u: Array, v: Array, applied_disp: Array) -&gt; Array:\n    \"\"\"Compute the tangent stiffness matrix.\"\"\"\n    tangent = jax.jvp(compute_internal, (u, applied_disp), (v, applied_disp))[1]\n    return tangent\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#defining-the-loading-traction-on-right-edge","title":"Defining the loading traction on right edge","text":"<p>We define a new <code>Operator</code> consisting of line elements along the right edge and then use this <code>op_line</code> to integrate the traction along the nodes.</p> <pre><code>sig_loading = 1e-2\n\nf_ext_0 = jnp.zeros(n_dofs)\n\nidx_right = n_dofs_per_node * boundary_right\n\nf_ext_0 = f_ext_0.at[idx_right].add(sig_loading)\nf_ext = f_ext_0.at[free_dofs].get()\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#defining-true-matrix-free-approach-in-petsc","title":"Defining true <code>Matrix-Free</code> approach in <code>PETSc</code>","text":"<p>In the previous example, we use the sparse data to construct the <code>matrix-free</code> solver in <code>PETSc</code>. Which meant that we had to know the sparsity pattern beforehand and store the sparse data. </p> <p>However, since we can also express stiffness matrix as <code>Jacobian-vector</code> product, we can use this feature to truly define a matrix-free solver in <code>PETSc</code>.</p> <p>For this we will make use of the <code>PythonContext</code> in <code>PETSc</code> through <code>petsc4py.PETSc.Mat.Type.PYTHON</code> type.</p> <p>Below we define a <code>PythonContext</code> to describe the matrix-multiplication behavior which is what Jacobian-vector product will. We will need <code>ctx</code> to store the values of displacment at which we want to differentiate the internal forces</p> <pre><code>ctx = {}  # context for the Jacobian-vector product\n\n\nclass MatMultCtx:\n    def __init__(self):\n        self.x_cur = None # J(u) which is the last iterate state\n        self.applied_disp = None\n\n    def set_x(self, x: Array):\n        \"\"\"Set the current iterate for the Jacobian-vector product.\"\"\"\n        self.x_cur = x\n\n    def set_applied_disp(self, applied_disp: Array):\n        \"\"\"Set the applied displacement for the Jacobian-vector product.\"\"\"\n        self.applied_disp = applied_disp\n\n    def mult(self, A, V, Y):\n        \"Y = J(u) * V with current x stored in ctx['x']\"\n        v_np = V.getArray(readonly=True)\n        jvp = compute_tangent(self.x_cur, v_np, self.applied_disp)\n        Y.setArray(jvp)\n\n\nctx = MatMultCtx()\nJ = PETSc.Mat().createPython(\n    [len(free_dofs), len(free_dofs)], comm=PETSc.COMM_SELF, context=ctx\n)\nJ.setUp()\n</code></pre> <pre><code>&lt;petsc4py.PETSc.Mat at 0x7186dc0ef010&gt;\n</code></pre> <p>Now we wrap the above <code>ctx</code> in a typical <code>SNES</code> problem class which provides two functions:</p> <ul> <li>to compute the residual</li> <li>to compute the jacobian, note that the jacobian uses <code>ctx</code> to set the last iterate value for displacement and returns <code>True</code></li> </ul> <pre><code>class ElasticitySNES:\n    def __init__(self, applied_disp: Array, f_ext: Array):\n        self.applied_disp = applied_disp\n        self.f_ext = f_ext\n\n    def residual(self, snes, u_petsc, r_petsc):\n        \"\"\"Compute the residual of the nonlinear system.\"\"\"\n        u = u_petsc.getArray(readonly=True)\n        r = compute_internal(u, self.applied_disp)\n        res = r - self.f_ext\n        r_petsc.setArray(res)\n\n    def jacobian(self, snes, u_petsc, J_mat: PETSc.Mat, P_mat: PETSc.Mat):\n        \"\"\"Compute the Jacobian of the nonlinear system.\"\"\"\n        u = u_petsc.getArray(readonly=True)\n        ctx.set_x(u)\n        ctx.set_applied_disp(self.applied_disp)\n        return True\n</code></pre> <p>Setting up <code>SNES</code> solver which is basically Newton-Krylov Solver where for the Krylov solver we will use the <code>Conjugate-Gradient</code> solver.</p> <pre><code>problem = ElasticitySNES(applied_disp=jnp.zeros(len(fixed_dofs)), f_ext=f_ext)\n\n\nsnes = PETSc.SNES().create(comm=PETSc.COMM_SELF)\nx_sol = PETSc.Vec().createSeq(len(free_dofs))\n\nsnes.setFunction(problem.residual, x_sol)\nsnes.setJacobian(problem.jacobian, J, J)\n\nsnes.setType(\"newtonls\")\nsnes.setTolerances(atol=1e-8, rtol=1e-10)\nsnes.setConvergenceHistory()\nsnes.setConvergedReason(reason=PETSc.SNES.ConvergedReason.CONVERGED_FNORM_ABS)\n\nksp = snes.getKSP()\nksp.setType(\"cg\")  # Use Conjugate Gradient method\nksp.getPC().setType(\"none\")  # No preconditioner\nksp.setConvergedReason(reason=PETSc.KSP.ConvergedReason.CONVERGED_ATOL)\nksp.setTolerances(rtol=1e-2, atol=1e-8)\n\nconvergence_history = np.zeros(100)  # Preallocate convergence history array\n\ndef monitor_fn(_snes, it, residual):\n    convergence_history[it] = residual\n    print(it, residual)\n\n\nsnes.setMonitor(monitor_fn)\n</code></pre> <p>Finally, solving the problem</p> <pre><code>du = x_sol.duplicate()\ndu.setArray(jnp.zeros(len(free_dofs)))  # Initial guess (zero displacement)\nsnes.solve(None, du)\n</code></pre> <pre><code>0 0.04898979485566356\n1 0.0004664493197841444\n2 4.56924100496837e-06\n3 4.476608293234423e-08\n4 9.873898243606004e-09\n</code></pre>"},{"location":"external_solvers/linear_elasticity_petsc4py_mf/#visualization-and-analyzing-the-results","title":"Visualization and analyzing the results","text":"Code to visualize the results <pre><code>from matplotlib.tri import Triangulation\n\nu = jnp.zeros(n_dofs).at[free_dofs].set(du.getArray())\nu = u.reshape(-1, 2)\n\nfig, ax = plt.subplots(figsize=(7.4, 3))\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\nsig = compute_stress(compute_strain(op.grad(u)), mat.mu, mat.lmbda).squeeze()\n\n\ndef plot_field(ax: Axes):\n    cb = ax.tripcolor(\n        tri,\n        sig[..., 0, 1],\n        alpha=0.95,\n        rasterized=True,\n        cmap=\"managua\",\n    )\n    ax.set_aspect(\"equal\")\n    ax.set(\n        xlabel=\"$x$\",\n        ylabel=\"$y$\",\n    )\n    return cb\n\n\ncb = plot_field(ax)\nax.set_axis_off()\nplt.colorbar(cb, ax=ax, label=r\"$\\sigma_{xy}$\", shrink=0.7)\nfig.tight_layout()\n</code></pre>"},{"location":"external_solvers/linear_elasticity_scipy/","title":"SciPy","text":""},{"location":"external_solvers/linear_elasticity_scipy/#linear-elasticity-with-scipy","title":"Linear elasticity with SciPy","text":"<p>In this notebook, we solve a linear elastic problem using <code>scipy</code> based solvers.</p> <pre><code>from typing import NamedTuple\n\nimport gmsh\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nimport jax.numpy as jnp\nfrom jax import Array\nfrom jax_autovmap import autovmap\nfrom tatva import Mesh, Operator\nimport scipy\nfrom tatva_coloring import distance2_color_and_seeds\nfrom tatva import sparse\n</code></pre> Code for generating a plate with a hole and plotting the mesh <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nimport meshio\n\nimport numpy as np\nimport os\n\n\ndef plot_mesh(mesh: Mesh, ax: Axes | None = None) -&gt; None:\n    if ax is None:\n        fig, ax = plt.subplots()\n    ax.tripcolor(\n        mesh.coords[:, 0],\n        mesh.coords[:, 1],\n        mesh.elements,\n        facecolors=np.ones(len(mesh.elements)),\n        cmap=\"managua\",\n        edgecolors=\"k\",\n        linewidth=0.2,\n    )\n\n    ax.set_aspect(\"equal\")\n    ax.margins(0.0)\n\n\ndef generate_refined_plate_with_hole(\n    width: float,\n    height: float,\n    hole_radius: float,\n    mesh_size_fine: float,\n    mesh_size_coarse: float,\n):\n    mesh_dir = os.path.join(os.getcwd(), \"../meshes\")\n    os.makedirs(mesh_dir, exist_ok=True)\n    output_filename = os.path.join(mesh_dir, \"plate_hole_refined.msh\")\n\n    gmsh.initialize()\n    gmsh.model.add(\"plate_with_hole_refined\")\n    occ = gmsh.model.occ\n\n    rect = occ.addRectangle(0, 0, 0, width, height)\n    cx = width / 2.0\n    cy = height / 2.0\n    disk = occ.addDisk(cx, cy, 0, hole_radius, hole_radius)\n\n    out, _ = occ.cut([(2, rect)], [(2, disk)])\n    occ.synchronize()\n\n    surface_tag = out[0][1]\n    gmsh.model.addPhysicalGroup(2, [surface_tag], 1, name=\"domain\")\n\n    boundaries = gmsh.model.getBoundary(out, oriented=False)\n    boundary_tags = [b[1] for b in boundaries]\n    gmsh.model.addPhysicalGroup(1, boundary_tags, 2, name=\"boundaries\")\n\n    hole_curve_tags = []\n    for tag in boundary_tags:\n        xmin, ymin, zmin, xmax, ymax, zmax = gmsh.model.getBoundingBox(1, tag)\n        # The hole is completely inside the outer rectangle\n        if xmin &gt; 0 and xmax &lt; width and ymin &gt; 0 and ymax &lt; height:\n            hole_curve_tags.append(tag)\n\n    gmsh.model.mesh.field.add(\"Distance\", 1)\n    gmsh.model.mesh.field.setNumbers(1, \"CurvesList\", hole_curve_tags)\n    gmsh.model.mesh.field.setNumber(1, \"NumPointsPerCurve\", 100)\n\n    gmsh.model.mesh.field.add(\"Threshold\", 2)\n    gmsh.model.mesh.field.setNumber(2, \"InField\", 1)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMin\", mesh_size_fine)\n    gmsh.model.mesh.field.setNumber(2, \"SizeMax\", mesh_size_coarse)\n    # Start growing the mesh exactly at the hole boundary\n    gmsh.model.mesh.field.setNumber(2, \"DistMin\", 0.0)\n    # Reach maximum element size at a distance equal to 2 hole radii away\n    gmsh.model.mesh.field.setNumber(2, \"DistMax\", hole_radius * 2.0)\n\n    gmsh.model.mesh.field.setAsBackgroundMesh(2)\n\n    gmsh.option.setNumber(\"Mesh.MeshSizeExtendFromBoundary\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromPoints\", 0)\n    gmsh.option.setNumber(\"Mesh.MeshSizeFromCurvature\", 0)\n\n    gmsh.model.mesh.generate(2)\n    gmsh.write(output_filename)\n    gmsh.finalize()\n\n    _mesh = meshio.read(output_filename)\n    coords = _mesh.points[:, :2]\n    elements = _mesh.cells_dict[\"triangle\"]\n\n    return Mesh(coords=coords, elements=elements)\n</code></pre> <pre><code>lx = 1.0\nly = 1.0\nmesh = generate_refined_plate_with_hole(\n    lx, ly, hole_radius=0.2, mesh_size_fine=0.01, mesh_size_coarse=0.05\n)\n\nn_dofs_per_node = 2\nn_dofs = mesh.coords.shape[0] * n_dofs_per_node\n\nplot_mesh(mesh)\n</code></pre> <pre><code>Info    : Meshing 1D...                                                                                                                        \nInfo    : [  0%] Meshing curve 5 (Ellipse)\nInfo    : [ 30%] Meshing curve 6 (Line)\nInfo    : [ 50%] Meshing curve 7 (Line)\nInfo    : [ 70%] Meshing curve 8 (Line)\nInfo    : [ 90%] Meshing curve 9 (Line)\nInfo    : Done meshing 1D (Wall 0.0199007s, CPU 0.019292s)\nInfo    : Meshing 2D...\nInfo    : Meshing surface 1 (Plane, Frontal-Delaunay)\nInfo    : Done meshing 2D (Wall 0.0541642s, CPU 0.052903s)\nInfo    : 1874 nodes 3753 elements\nInfo    : Writing '/home/mohit/Documents/dev/tatva-docs/docs/external_solvers/../meshes/plate_hole_refined.msh'...\nInfo    : Done writing '/home/mohit/Documents/dev/tatva-docs/docs/external_solvers/../meshes/plate_hole_refined.msh'\n</code></pre> <p></p>"},{"location":"external_solvers/linear_elasticity_scipy/#problem-setup","title":"Problem setup","text":"<pre><code>from tatva.element import Tri3\n\nop = Operator(mesh, Tri3())\n\n\nboundary_left = jnp.where(jnp.isclose(mesh.coords[:, 0], 0.0))[0]\nboundary_right = jnp.where(jnp.isclose(mesh.coords[:, 0], lx))[0]\npoint_at_y_0 = jnp.where(\n    jnp.isclose(mesh.coords[:, 0], lx) &amp; jnp.isclose(mesh.coords[:, 1], 0.0)\n)[0][0]\nassert point_at_y_0\n\nfixed_dofs = jnp.concatenate(\n    [\n        boundary_left * n_dofs_per_node,\n    ]\n)\nfree_dofs = jnp.setdiff1d(jnp.arange(n_dofs), fixed_dofs)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_scipy/#defining-energy-functional","title":"Defining energy functional","text":"<p>We now define the functions to compute the total strain energy</p> <pre><code>class Material(NamedTuple):\n    \"\"\"Material properties for the elasticity operator.\"\"\"\n\n    mu: float  \n    lmbda: float\n\n    @classmethod\n    def from_youngs_poisson_2d(\n        cls, E: float, nu: float, plane_stress: bool = False\n    ) -&gt; \"Material\":\n        mu = E / 2 / (1 + nu)\n        if plane_stress:\n            lmbda = 2 * nu * mu / (1 - nu)\n        else:\n            lmbda = E * nu / (1 - 2 * nu) / (1 + nu)\n        return cls(mu=mu, lmbda=lmbda)\n\n\nmat = Material.from_youngs_poisson_2d(1, 0.3)\n\n\n@autovmap(grad_u=2)\ndef compute_strain(grad_u):\n    return 0.5 * (grad_u + grad_u.T)\n\n\n@autovmap(eps=2, mu=0, lmbda=0)\ndef compute_stress(eps, mu, lmbda):\n    return 2 * mu * eps + lmbda * jnp.trace(eps) * jnp.eye(2)\n\n\n@autovmap(grad_u=2, mu=0, lmbda=0)\ndef strain_energy_density(grad_u, mu, lmbda):\n    eps = compute_strain(grad_u)\n    sigma = compute_stress(eps, mu, lmbda)\n    return 0.5 * jnp.einsum(\"ij,ij-&gt;\", sigma, eps)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_scipy/#enforcing-boundary-condition-via-static-condensation","title":"Enforcing boundary condition via static condensation","text":"<pre><code>@jax.jit\ndef total_energy_full(u_flat: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u = u_flat.reshape(-1, 2)\n    u_grad = op.grad(u)\n    e_density = strain_energy_density(u_grad, mat.mu, mat.lmbda)\n    return op.integrate(e_density)\n\n\n@jax.jit\ndef total_energy(u_free: Array, applied_disp: Array) -&gt; Array:\n    \"\"\"Compute the total energy of the system.\"\"\"\n    u_full = jnp.zeros(n_dofs).at[free_dofs].set(u_free)\n    u_full = u_full.at[fixed_dofs].set(applied_disp)\n    return total_energy_full(u_full)\n\n\nresidual = jax.jacrev(total_energy)\n</code></pre> <p>Now we can define the <code>sparsity_pattern</code> and use <code>sparse.jacfwd</code> to create a function that computes the sparse stiffness matrix using sparse differentiation.</p> <pre><code>nb_dofs_per_node = 2\n\nsparsity_pattern = sparse.create_sparsity_pattern(\n    mesh, n_dofs_per_node=nb_dofs_per_node\n)\n\nreduced_sparsity_pattern = sparse.reduce_sparsity_pattern(sparsity_pattern, free_dofs)\nreduced_sparsity_pattern_csr = scipy.sparse.csr_matrix(\n    (\n        reduced_sparsity_pattern.data,\n        (\n            reduced_sparsity_pattern.indices[:, 0],\n            reduced_sparsity_pattern.indices[:, 1],\n        ),\n    )\n)\n\ncolors = distance2_color_and_seeds(\n    reduced_sparsity_pattern_csr.indptr,\n    reduced_sparsity_pattern_csr.indices,\n    n_dofs=len(free_dofs),\n)[0]\n</code></pre> <pre><code>hessian_fn = sparse.jacfwd(\n    gradient=residual,\n    row_ptr=reduced_sparsity_pattern_csr.indptr,\n    col_indices=reduced_sparsity_pattern_csr.indices,\n    colors=colors,\n    color_batch_size=len(jnp.unique(colors)) + 1,\n)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_scipy/#defining-the-loading-traction-on-right-edge","title":"Defining the loading traction on right edge","text":"<p>We define a new <code>Operator</code> consisting of line elements along the right edge and then use this <code>op_line</code> to integrate the traction along the nodes.</p> <pre><code>sig_loading = 1e-2\n\nf_ext_0 = jnp.zeros(n_dofs)\n\nidx_right = n_dofs_per_node * boundary_right\n\nf_ext_0 = f_ext_0.at[idx_right].add(sig_loading)\nf_ext = f_ext_0.at[free_dofs].get()\n</code></pre> <p>Now let us solve the linear problem using scipy sparse solver <code>scipy.sparse.linalg.spsolve</code></p> \\[ \\mathbf{K}\\boldsymbol{u} =\\boldsymbol{f}_\\text{ext} \\] <p>We will use the above defined <code>hessian_fn</code> to compute the sparse stiffness matrix and will convert it to <code>scipy.sparse.csr_matrix</code>.</p> <pre><code>K_bcco = hessian_fn(jnp.zeros(len(free_dofs)), applied_disp=jnp.zeros(len(fixed_dofs)))\nK_csr = scipy.sparse.csr_matrix(\n    (K_bcco.data, (K_bcco.indices[:, 0], K_bcco.indices[:, 1]))\n)\ndu = scipy.sparse.linalg.spsolve(K_csr, f_ext)\n</code></pre>"},{"location":"external_solvers/linear_elasticity_scipy/#visualization-and-analyzing-the-results","title":"Visualization and analyzing the results","text":"Code to visualize the results <pre><code>from matplotlib.tri import Triangulation\n\nu = jnp.zeros(n_dofs).at[free_dofs].set(du)\nu = u.reshape(-1, 2)\n\nfig, ax = plt.subplots(figsize=(7.4, 3))\nx_final = mesh.coords + u\ntri = Triangulation(x_final[:, 0], x_final[:, 1], mesh.elements)\n\nsig = compute_stress(compute_strain(op.grad(u)), mat.mu, mat.lmbda).squeeze()\n\n\ndef plot_field(ax: Axes):\n    cb = ax.tripcolor(\n        tri,\n        sig[..., 0, 1],\n        alpha=0.95,\n        rasterized=True,\n        cmap=\"managua\",\n    )\n    ax.set_aspect(\"equal\")\n    ax.set(\n        xlabel=\"$x$\",\n        ylabel=\"$y$\",\n    )\n    return cb\n\n\ncb = plot_field(ax)\nax.set_axis_off()\nplt.colorbar(cb, ax=ax, label=r\"$\\sigma_{xy}$\", shrink=0.7)\nfig.tight_layout()\n</code></pre> <pre><code>\n</code></pre>"}]}